Xilinx Zynq MP First Stage Boot Loader 
Release 2020.1   Nov 30 2021  -  13:31:53
NOTICE:  ATF running on XCZU5EV/silicon v4/RTL5.1 at 0xfffea000
NOTICE:  BL31: v2.2(release):xilinx_rebase_v2.2_2020.1
NOTICE:  BL31: Built : 13:29:52, Nov 30 2021


U-Boot 2020.01 (Nov 30 2021 - 13:30:56 +0000)

Model: Enclustra ME-XU5-5EV-2I-D12E SOM
Board: Xilinx ZynqMP
DRAM:  4 GiB
usb dr_mode not found
usb dr_mode not found
PMUFW:	v1.1
EL Level:	EL2
Chip ID:	zu5ev
NAND:  0 MiB
MMC:   mmc@ff160000: 0, mmc@ff170000: 1
In:    serial@ff000000
Out:   serial@ff000000
Err:   serial@ff000000
Bootmode: SD_MODE1
Reset reason:	EXTERNAL 
Net:   
ZYNQ GEM: ff0b0000, mdio bus ff0b0000, phyaddr 3, interface rgmii-id

Warning: ethernet@ff0b0000 (eth0) using random MAC address - fa:d8:0f:9a:84:ae
eth0: ethernet@ff0b0000
Hit any key to stop autoboot:  2  1  0 
switch to partitions #0, OK
mmc1 is current device
Scanning mmc 1:1...
Found U-Boot script /boot.scr
3694 bytes read in 19 ms (189.5 KiB/s)
## Executing script at 20000000
[L0MuESL] Before SD card scanning... 
[L0MuESL] SD card scanning now...
[L0MuESL] Loading uEnv.txt in SD1... 
1272 bytes read in 18 ms (68.4 KiB/s)
[L0MuESL] Loading u-boot environment by uenvcmd... 
[L0MuESL] SD card fatload now ...
8159148 bytes read in 605 ms (12.9 MiB/s)
[L0MuESL] SD card bootm command now...
## Loading kernel from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'kernel@1' kernel subimage
     Description:  Linux kernel
     Type:         Kernel Image
     Compression:  gzip compressed
     Data Start:   0x100000e8
     Data Size:    8114710 Bytes = 7.7 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00080000
     Entry Point:  0x00080000
     Hash algo:    sha256
     Hash value:   d8dbc87352877e020871a801ceda165f06fa467dc974d45677a3e9058465f51f
   Verifying Hash Integrity ... sha256+ OK
## Loading fdt from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'fdt@system-top.dtb' fdt subimage
     Description:  Flattened Device Tree blob
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x107bd410
     Data Size:    42547 Bytes = 41.5 KiB
     Architecture: AArch64
     Hash algo:    sha256
     Hash value:   c2cb860e94d3969dd7865705c3edff938ff4058f8cd3fe6c0a353a4664c16d1c
   Verifying Hash Integrity ... sha256+ OK
   Booting using the fdt blob at 0x107bd410
   Uncompressing Kernel Image
   Loading Device Tree to 000000000fff2000, end 000000000ffff632 ... OK

Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]
[    0.000000] Linux version 5.4.0-xilinx-v2020.1 (oe-user@oe-host) (gcc version 9.2.0 (GCC)) #1 SMP Tue Nov 30 13:29:56 UTC 2021
[    0.000000] Machine model: Enclustra ME-XU5-5EV-2I-D12E SOM
[    0.000000] earlycon: cdns0 at MMIO 0x00000000ff000000 (options '115200n8')
[    0.000000] printk: bootconsole [cdns0] enabled
[    0.000000] efi: Getting EFI parameters from FDT:
[    0.000000] efi: UEFI not found.
[    0.000000] cma: Reserved 256 MiB at 0x000000006fc00000
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.1 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
[    0.000000] psci: MIGRATE_INFO_TYPE not supported.
[    0.000000] psci: SMC Calling Convention v1.1
[    0.000000] percpu: Embedded 21 pages/cpu s49112 r8192 d28712 u86016
[    0.000000] Detected VIPT I-cache on CPU0
[    0.000000] CPU features: detected: ARM erratum 845719
[    0.000000] Speculative Store Bypass Disable mitigation not required
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 1031940
[    0.000000] Kernel command line: earlycon console=ttyPS0,115200 clk_ignore_unused root=/dev/mmcblk1p2 rootfstype=ext4 rw rootwait earlyprintk uio_pdrv_genirq.of_id=generic-uio cpuidle.off=1 ip=130.87.242.129:130.87.240.1:255.255.252.0:sl-xu5-eth0-01:eth0:off nameserver=130.87.240.2 nameserver=130.87.240.3
[    0.000000] Dentry cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)
[    0.000000] Inode-cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] software IO TLB: mapped [mem 0x6bc00000-0x6fc00000] (64MB)
[    0.000000] Memory: 3767708K/4193280K available (11644K kernel code, 670K rwdata, 3624K rodata, 704K init, 321K bss, 163428K reserved, 262144K cma-reserved)
[    0.000000] rcu: Hierarchical RCU implementation.
[    0.000000] rcu: 	RCU event tracing is enabled.
[    0.000000] rcu: 	RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] GIC: Adjusting CPU interface base to 0x00000000f902f000
[    0.000000] GIC: Using split EOI/Deactivate mode
[    0.000000] random: get_random_bytes called from start_kernel+0x2a8/0x42c with crng_init=0
[    0.000000] arch_timer: cp15 timer(s) running at 33.33MHz (phys).
[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x7b0074340, max_idle_ns: 440795202884 ns
[    0.000003] sched_clock: 56 bits at 33MHz, resolution 30ns, wraps every 2199023255543ns
[    0.008261] Console: colour dummy device 80x25
[    0.012390] Calibrating delay loop (skipped), value calculated using timer frequency.. 66.66 BogoMIPS (lpj=133332)
[    0.022667] pid_max: default: 32768 minimum: 301
[    0.027383] Mount-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.034614] Mountpoint-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.043250] ASID allocator initialised with 32768 entries
[    0.047804] rcu: Hierarchical SRCU implementation.
[    0.052692] EFI services will not be available.
[    0.057130] smp: Bringing up secondary CPUs ...
[    0.061816] Detected VIPT I-cache on CPU1
[    0.061846] CPU1: Booted secondary processor 0x0000000001 [0x410fd034]
[    0.062164] Detected VIPT I-cache on CPU2
[    0.062182] CPU2: Booted secondary processor 0x0000000002 [0x410fd034]
[    0.062481] Detected VIPT I-cache on CPU3
[    0.062498] CPU3: Booted secondary processor 0x0000000003 [0x410fd034]
[    0.062541] smp: Brought up 1 node, 4 CPUs
[    0.096970] SMP: Total of 4 processors activated.
[    0.101643] CPU features: detected: 32-bit EL0 Support
[    0.106746] CPU features: detected: CRC32 instructions
[    0.111876] CPU: All CPU(s) started at EL2
[    0.115926] alternatives: patching kernel code
[    0.121330] devtmpfs: initialized
[    0.127785] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[    0.133313] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)
[    0.145642] xor: measuring software checksum speed
[    0.184207]    8regs     :  2639.000 MB/sec
[    0.224231]    32regs    :  3027.000 MB/sec
[    0.264260]    arm64_neon:  2628.000 MB/sec
[    0.264296] xor: using function: 32regs (3027.000 MB/sec)
[    0.268167] pinctrl core: initialized pinctrl subsystem
[    0.273923] NET: Registered protocol family 16
[    0.278759] DMA: preallocated 256 KiB pool for atomic allocations
[    0.283842] audit: initializing netlink subsys (disabled)
[    0.289291] audit: type=2000 audit(0.228:1): state=initialized audit_enabled=0 res=1
[    0.289740] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    0.314348] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages
[    0.315400] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages
[    0.322068] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages
[    0.328725] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages
[    1.301439] DRBG: Continuing without Jitter RNG
[    1.377998] raid6: neonx8   gen()  1717 MB/s
[    1.446019] raid6: neonx8   xor()  1624 MB/s
[    1.514061] raid6: neonx4   gen()  1640 MB/s
[    1.582097] raid6: neonx4   xor()  1577 MB/s
[    1.650149] raid6: neonx2   gen()  1248 MB/s
[    1.718190] raid6: neonx2   xor()  1304 MB/s
[    1.786255] raid6: neonx1   gen()   809 MB/s
[    1.854244] raid6: neonx1   xor()   978 MB/s
[    1.922310] raid6: int64x8  gen()  1291 MB/s
[    1.990359] raid6: int64x8  xor()   844 MB/s
[    2.058392] raid6: int64x4  gen()  1085 MB/s
[    2.126412] raid6: int64x4  xor()   814 MB/s
[    2.194510] raid6: int64x2  gen()   753 MB/s
[    2.262491] raid6: int64x2  xor()   657 MB/s
[    2.330641] raid6: int64x1  gen()   500 MB/s
[    2.398567] raid6: int64x1  xor()   499 MB/s
[    2.398603] raid6: using algorithm neonx8 gen() 1717 MB/s
[    2.402556] raid6: .... xor() 1624 MB/s, rmw enabled
[    2.407486] raid6: using neon recovery algorithm
[    2.412376] iommu: Default domain type: Translated 
[    2.417103] SCSI subsystem initialized
[    2.420756] usbcore: registered new interface driver usbfs
[    2.426110] usbcore: registered new interface driver hub
[    2.431381] usbcore: registered new device driver usb
[    2.436417] mc: Linux media interface: v0.10
[    2.440631] videodev: Linux video capture interface: v2.00
[    2.446079] pps_core: LinuxPPS API ver. 1 registered
[    2.450996] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    2.460089] PTP clock support registered
[    2.463983] EDAC MC: Ver: 3.0.0
[    2.467427] zynqmp-ipi-mbox mailbox@ff990400: Registered ZynqMP IPI mbox with TX/RX channels.
[    2.475715] FPGA manager framework
[    2.479044] Advanced Linux Sound Architecture Driver Initialized.
[    2.485228] Bluetooth: Core ver 2.22
[    2.488553] NET: Registered protocol family 31
[    2.492951] Bluetooth: HCI device and connection manager initialized
[    2.499267] Bluetooth: HCI socket layer initialized
[    2.504109] Bluetooth: L2CAP socket layer initialized
[    2.509132] Bluetooth: SCO socket layer initialized
[    2.514374] clocksource: Switched to clocksource arch_sys_counter
[    2.520116] VFS: Disk quotas dquot_6.6.0
[    2.523955] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[    2.534429] NET: Registered protocol family 2
[    2.535378] tcp_listen_portaddr_hash hash table entries: 2048 (order: 3, 32768 bytes, linear)
[    2.543594] TCP established hash table entries: 32768 (order: 6, 262144 bytes, linear)
[    2.551605] TCP bind hash table entries: 32768 (order: 7, 524288 bytes, linear)
[    2.559037] TCP: Hash tables configured (established 32768 bind 32768)
[    2.565239] UDP hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.571903] UDP-Lite hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.579074] NET: Registered protocol family 1
[    2.583500] RPC: Registered named UNIX socket transport module.
[    2.589145] RPC: Registered udp transport module.
[    2.593811] RPC: Registered tcp transport module.
[    2.598481] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    2.605119] PCI: CLS 0 bytes, default 64
[    2.609286] hw perfevents: no interrupt-affinity property for /pmu, guessing.
[    2.616007] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    2.624260] Initialise system trusted keyrings
[    2.628057] workingset: timestamp_bits=46 max_order=20 bucket_order=0
[    2.635059] NFS: Registering the id_resolver key type
[    2.639409] Key type id_resolver registered
[    2.643548] Key type id_legacy registered
[    2.647533] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    2.654201] jffs2: version 2.2. (NAND) Â© 2001-2006 Red Hat, Inc.
[    2.671906] NET: Registered protocol family 38
[    2.671946] Key type asymmetric registered
[    2.674778] Asymmetric key parser 'x509' registered
[    2.679639] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 247)
[    2.686975] io scheduler mq-deadline registered
[    2.691470] io scheduler kyber registered
[    2.719102] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[    2.722623] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    2.729634] brd: module loaded
[    2.733683] loop: module loaded
[    2.734290] mtdoops: mtd device (mtddev=name/number) must be supplied
[    2.739380] libphy: Fixed MDIO Bus: probed
[    2.743316] tun: Universal TUN/TAP device driver, 1.6
[    2.747568] CAN device driver interface
[    2.752006] usbcore: registered new interface driver asix
[    2.756705] usbcore: registered new interface driver ax88179_178a
[    2.762739] usbcore: registered new interface driver cdc_ether
[    2.768532] usbcore: registered new interface driver net1080
[    2.774158] usbcore: registered new interface driver cdc_subset
[    2.780038] usbcore: registered new interface driver zaurus
[    2.785582] usbcore: registered new interface driver cdc_ncm
[    2.791270] uio_pdrv_genirq 80020000.debug_bridge: IRQ index 0 not found
[    2.798638] usbcore: registered new interface driver uas
[    2.803153] usbcore: registered new interface driver usb-storage
[    2.809569] rtc_zynqmp ffa60000.rtc: registered as rtc0
[    2.814315] i2c /dev entries driver
[    2.819007] usbcore: registered new interface driver uvcvideo
[    2.823449] USB Video Class driver (1.1.1)
[    2.827810] Bluetooth: HCI UART driver ver 2.3
[    2.831928] Bluetooth: HCI UART protocol H4 registered
[    2.837027] Bluetooth: HCI UART protocol BCSP registered
[    2.842314] Bluetooth: HCI UART protocol LL registered
[    2.847405] Bluetooth: HCI UART protocol ATH3K registered
[    2.852779] Bluetooth: HCI UART protocol Three-wire (H5) registered
[    2.859025] Bluetooth: HCI UART protocol Intel registered
[    2.864372] Bluetooth: HCI UART protocol QCA registered
[    2.869571] usbcore: registered new interface driver bcm203x
[    2.875193] usbcore: registered new interface driver bpa10x
[    2.880727] usbcore: registered new interface driver bfusb
[    2.886180] usbcore: registered new interface driver btusb
[    2.891640] usbcore: registered new interface driver ath3k
[    2.897196] EDAC MC0: 13 UE BankGroup Number 0 Block Number 0 on mc#0csrow#0channel#0 (csrow:0 channel:0 page:0x0 offset:0x0 grain:1)
[    2.909079] EDAC MC0: Giving out device to module 1 controller synps_ddr_controller: DEV synps_edac (INTERRUPT)
[    2.919145] EDAC DEVICE0: Giving out device to module edac controller cache_err: DEV edac (POLLED)
[    2.928083] EDAC DEVICE1: Giving out device to module zynqmp-ocm-edac controller zynqmp_ocm: DEV ff960000.memory-controller (INTERRUPT)
[    2.940368] sdhci: Secure Digital Host Controller Interface driver
[    2.946191] sdhci: Copyright(c) Pierre Ossman
[    2.950513] sdhci-pltfm: SDHCI platform and OF driver helper
[    2.956447] ledtrig-cpu: registered to indicate activity on CPUs
[    2.962143] zynqmp_firmware_probe Platform Management API v1.1
[    2.967904] zynqmp_firmware_probe Trustzone version v1.0
[    2.995811] alg: No test for xilinx-zynqmp-aes (zynqmp-aes)
[    2.995983] zynqmp_aes zynqmp_aes: AES Successfully Registered
[    2.995983] 
[    3.003231] alg: No test for xilinx-keccak-384 (zynqmp-keccak-384)
[    3.009440] alg: No test for xilinx-zynqmp-rsa (zynqmp-rsa)
[    3.015000] usbcore: registered new interface driver usbhid
[    3.020306] usbhid: USB HID core driver
[    3.026214] fpga_manager fpga0: Xilinx ZynqMP FPGA Manager registered
[    3.030774] usbcore: registered new interface driver snd-usb-audio
[    3.037345] pktgen: Packet Generator for packet performance testing. Version: 2.75
[    3.044659] Initializing XFRM netlink socket
[    3.048491] NET: Registered protocol family 10
[    3.053194] Segment Routing with IPv6
[    3.056565] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[    3.062653] NET: Registered protocol family 17
[    3.066765] NET: Registered protocol family 15
[    3.071179] bridge: filtering via arp/ip/ip6tables is no longer available by default. Update your scripts to load br_netfilter if you need this.
[    3.084054] can: controller area network core (rev 20170425 abi 9)
[    3.090218] NET: Registered protocol family 29
[    3.094608] can: raw protocol (rev 20170425)
[    3.098846] can: broadcast manager protocol (rev 20170425 t)
[    3.104470] can: netlink gateway (rev 20190810) max_hops=1
[    3.109978] Bluetooth: RFCOMM TTY layer initialized
[    3.114768] Bluetooth: RFCOMM socket layer initialized
[    3.119877] Bluetooth: RFCOMM ver 1.11
[    3.123588] Bluetooth: BNEP (Ethernet Emulation) ver 1.3
[    3.128862] Bluetooth: BNEP filters: protocol multicast
[    3.134052] Bluetooth: BNEP socket layer initialized
[    3.138982] Bluetooth: HIDP (Human Interface Emulation) ver 1.2
[    3.144868] Bluetooth: HIDP socket layer initialized
[    3.149892] 9pnet: Installing 9P2000 support
[    3.154051] Key type dns_resolver registered
[    3.158628] registered taskstats version 1
[    3.162332] Loading compiled-in X.509 certificates
[    3.167461] Btrfs loaded, crc32c=crc32c-generic
[    3.179423] ff000000.serial: ttyPS0 at MMIO 0xff000000 (irq = 41, base_baud = 6249999) is a xuartps
[    3.188436] printk: console [ttyPS0] enabled
[    3.188436] printk: console [ttyPS0] enabled
[    3.192731] printk: bootconsole [cdns0] disabled
[    3.192731] printk: bootconsole [cdns0] disabled
[    3.201885] of-fpga-region fpga-full: FPGA Region probed
[    3.211942] GPIO IRQ not connected
[    3.215339] XGpio: gpio@80010000: registered, base is 509
[    3.221304] xilinx-zynqmp-dma fd500000.dma: ZynqMP DMA driver Probe success
[    3.228391] xilinx-zynqmp-dma fd510000.dma: ZynqMP DMA driver Probe success
[    3.235479] xilinx-zynqmp-dma fd520000.dma: ZynqMP DMA driver Probe success
[    3.242566] xilinx-zynqmp-dma fd530000.dma: ZynqMP DMA driver Probe success
[    3.249657] xilinx-zynqmp-dma fd540000.dma: ZynqMP DMA driver Probe success
[    3.256746] xilinx-zynqmp-dma fd550000.dma: ZynqMP DMA driver Probe success
[    3.263838] xilinx-zynqmp-dma fd560000.dma: ZynqMP DMA driver Probe success
[    3.270933] xilinx-zynqmp-dma fd570000.dma: ZynqMP DMA driver Probe success
[    3.278090] xilinx-zynqmp-dma ffa80000.dma: ZynqMP DMA driver Probe success
[    3.285174] xilinx-zynqmp-dma ffa90000.dma: ZynqMP DMA driver Probe success
[    3.292264] xilinx-zynqmp-dma ffaa0000.dma: ZynqMP DMA driver Probe success
[    3.299347] xilinx-zynqmp-dma ffab0000.dma: ZynqMP DMA driver Probe success
[    3.306437] xilinx-zynqmp-dma ffac0000.dma: ZynqMP DMA driver Probe success
[    3.313523] xilinx-zynqmp-dma ffad0000.dma: ZynqMP DMA driver Probe success
[    3.320612] xilinx-zynqmp-dma ffae0000.dma: ZynqMP DMA driver Probe success
[    3.327696] xilinx-zynqmp-dma ffaf0000.dma: ZynqMP DMA driver Probe success
[    3.334887] zynqmp-qspi ff0f0000.spi: rx bus width not found
[    3.340542] zynqmp-qspi ff0f0000.spi: tx bus width not found
[    3.346343] spi_master spi0: cannot find modalias for /amba/spi@ff0f0000/flash@0
[    3.353737] spi_master spi0: Failed to create SPI device for /amba/spi@ff0f0000/flash@0
[    3.362028] macb ff0b0000.ethernet: Not enabling partial store and forward
[    3.369376] libphy: MACB_mii_bus: probed
[    3.395992] zynqmp_pll_disable() clock disable failed for dpll_int, ret = -13
[    3.443540] Micrel KSZ9031 Gigabit PHY ff0b0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0b0000.ethernet-ffffffff:03, irq=POLL)
[    3.459352] macb ff0b0000.ethernet eth0: Cadence GEM rev 0x50070106 at 0xff0b0000 irq 29 (ca:9f:1e:3a:b6:24)
[    3.469434] macb ff0c0000.ethernet: Not enabling partial store and forward
[    3.476695] libphy: MACB_mii_bus: probed
[    3.551537] Micrel KSZ9031 Gigabit PHY ff0c0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0c0000.ethernet-ffffffff:03, irq=POLL)
[    3.567347] macb ff0c0000.ethernet eth1: Cadence GEM rev 0x50070106 at 0xff0c0000 irq 30 (ca:9f:1e:3a:b6:25)
[    3.577419] xilinx-axipmon ffa00000.perf-monitor: Probed Xilinx APM
[    3.583920] xilinx-axipmon fd0b0000.perf-monitor: Probed Xilinx APM
[    3.590391] xilinx-axipmon fd490000.perf-monitor: Probed Xilinx APM
[    3.596919] xilinx-axipmon ffa10000.perf-monitor: Probed Xilinx APM
[    3.603398] dwc3-of-simple ff9d0000.usb0: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.611681] dwc3 fe200000.dwc3: Failed to get clk 'ref': -2
[    3.617651] dwc3-of-simple ff9e0000.usb1: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.625874] dwc3 fe300000.dwc3: Failed to get clk 'ref': -2
[    3.632483] i2c i2c-0: Added multiplexed i2c bus 1
[    3.637589] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.643079] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 1
[    3.650814] xhci-hcd xhci-hcd.0.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.660222] xhci-hcd xhci-hcd.0.auto: irq 43, io mem 0xfe200000
[    3.666295] i2c i2c-0: Added multiplexed i2c bus 2
[    3.671378] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.676910] i2c i2c-0: Added multiplexed i2c bus 3
[    3.681886] i2c i2c-0: Added multiplexed i2c bus 4
[    3.686860] i2c i2c-0: Added multiplexed i2c bus 5
[    3.691749] i2c i2c-0: Added multiplexed i2c bus 6
[    3.696641] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.704900] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.712117] usb usb1: Product: xHCI Host Controller
[    3.716986] usb usb1: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.723591] usb usb1: SerialNumber: xhci-hcd.0.auto
[    3.728685] i2c i2c-0: Added multiplexed i2c bus 7
[    3.733617] i2c i2c-0: Added multiplexed i2c bus 8
[    3.738408] pca954x 0-0070: registered 8 multiplexed busses for I2C switch pca9548
[    3.745991] cdns-i2c ff020000.i2c: 400 kHz mmio ff020000 irq 32
[    3.752263] cpufreq: cpufreq_online: CPU0: Running at unlisted freq: 1333333 KHz
[    3.759661] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.768391] cpufreq: cpufreq_online: CPU0: Unlisted initial frequency changed to: 1199999 KHz
[    3.776919] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.786653] hub 1-0:1.0: USB hub found
[    3.790421] hub 1-0:1.0: 1 port detected
[    3.794507] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.799993] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 2
[    3.807652] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed
[    3.814223] usb usb2: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.822374] usb usb2: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.830627] usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.837839] usb usb2: Product: xHCI Host Controller
[    3.842709] usb usb2: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.849313] usb usb2: SerialNumber: xhci-hcd.0.auto
[    3.854552] hub 2-0:1.0: USB hub found
[    3.858309] hub 2-0:1.0: 1 port detected
[    3.862411] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 3
[    3.870146] xhci-hcd xhci-hcd.1.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.879552] xhci-hcd xhci-hcd.1.auto: irq 46, io mem 0xfe300000
[    3.885691] usb usb3: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.893952] usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.901174] usb usb3: Product: xHCI Host Controller
[    3.906057] usb usb3: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.912664] usb usb3: SerialNumber: xhci-hcd.1.auto
[    3.917618] mmc0: SDHCI controller on ff160000.mmc [ff160000.mmc] using ADMA 64-bit
[    3.926560] hub 3-0:1.0: USB hub found
[    3.930371] hub 3-0:1.0: 1 port detected
[    3.934525] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.940015] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 4
[    3.947667] xhci-hcd xhci-hcd.1.auto: Host supports USB 3.0 SuperSpeed
[    3.954279] usb usb4: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.962502] usb usb4: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.970762] usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.977979] usb usb4: Product: xHCI Host Controller
[    3.982849] usb usb4: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.989453] usb usb4: SerialNumber: xhci-hcd.1.auto
[    3.994447] mmc1: SDHCI controller on ff170000.mmc [ff170000.mmc] using ADMA 64-bit
[    4.004398] rtc_zynqmp ffa60000.rtc: setting system clock to 1970-01-01T00:00:08 UTC (8)
[    4.012487] of_cfs_init
[    4.014944] of_cfs_init: OK
[    4.018101] hub 4-0:1.0: USB hub found
[    4.021970] hub 4-0:1.0: 1 port detected
[    4.061962] mmc1: new high speed SDHC card at address aaaa
[    4.067806] mmcblk1: mmc1:aaaa SL16G 14.8 GiB 
[    4.077362]  mmcblk1: p1 p2
[    4.102318] mmc0: new HS200 MMC card at address 0001
[    4.107589] mmcblk0: mmc0:0001 W52516 14.3 GiB 
[    4.112283] mmcblk0boot0: mmc0:0001 W52516 partition 1 4.00 MiB
[    4.118372] mmcblk0boot1: mmc0:0001 W52516 partition 2 4.00 MiB
[    4.124347] mmcblk0rpmb: mmc0:0001 W52516 partition 3 4.00 MiB, chardev (245:0)
[    4.133591]  mmcblk0: p1
[   16.286388] cfg80211: Loading compiled-in X.509 certificates for regulatory database
[   16.410085] cfg80211: Loaded X.509 cert 'sforshee: 00b28ddf47aef9cea7'
[   16.416609] clk: Not disabling unused clocks
[   16.420875] ALSA device list:
[   16.423833]   No soundcards found.
[   16.427496] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2
[   16.436106] cfg80211: failed to load regulatory.db
[   16.449058] EXT4-fs (mmcblk1p2): mounted filesystem with ordered data mode. Opts: (null)
[   16.457169] VFS: Mounted root (ext4 filesystem) on device 179:2.
[   16.467946] devtmpfs: mounted
[   16.471067] Freeing unused kernel memory: 704K
[   16.490396] Run /sbin/init as init process
INIT: version 2.88 booting
[   16.684965] random: fast init done
Starting udev
[   16.865829] udevd[167]: starting version 3.2.8
[   16.875583] random: udevd: uninitialized urandom read (16 bytes read)
[   16.885593] random: udevd: uninitialized urandom read (16 bytes read)
[   16.892793] random: udevd: uninitialized urandom read (16 bytes read)
[   16.924467] udevd[168]: starting eudev-3.2.8
[   17.375048] dmaproxy: loading out-of-tree module taints kernel.
[   17.394043] EXT4-fs (mmcblk1p2): re-mounted. Opts: (null)
Tue Nov 30 15:44:35 UTC 2021
Configuring packages on first boot....
 (This may take several minutes. Please do not power off the machine.)
Running postinst /etc/rpm-postinsts/100-sysvinit-inittab...
update-rc.d: /etc/init.d/run-postinsts exists during rc.d purge (continuing)
 Removing any system startup links for run-postinsts ...
 INIT: Entering runlevel: 5
Configuring network interfaces... [   17.857470] pps pps0: new PPS source ptp0
[   17.861497] macb ff0b0000.ethernet: gem-ptp-timer ptp clock registered.
done.
Starting haveged: haveged: listening socket at 3
haveged: haveged starting up


Starting Dropbear SSH server: [   17.939064] urandom_read: 5 callbacks suppressed
[   17.939068] random: dropbearkey: uninitialized urandom read (32 bytes read)
[   17.953080] random: dropbearkey: uninitialized urandom read (32 bytes read)
Generating 2048 bit rsa key, this may take a while...
haveged: haveged: ver: 1.9.5; arch: generic; vend: ; build: (gcc 9.2.0 CTV); collect: 128K

haveged: haveged: cpu: (VC); data: 16K (D); inst: 16K (D); idx: 11/40; sz: 15456/64452

haveged: haveged: tot tests(BA8): A:1/1 B:1/1 continuous tests(B):  last entropy estimate 7.99615

haveged: haveged: fills: 0, generated: 0 

[   18.600675] random: crng init done
Public key portion is:
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCck7aCXV3ap99YCo1zP1urhOXf6lebSDpMzedZ5irPR9Kjo2UE7LLMBXvNFfz0PZ/5vqvPZhK1R7PLk+3YF4/D3iqcGdhZLBMovDYAxnRZHyJxdB20sUtUFnGPntXqnaPq+68WgXlMIPySkDPUMJ7voXPqfSG2ZcBlzac9nCmP23PTvyZUNOi5Bw485RR9rAQ/Dj8YmHekjpyItb+ydQPB+OE6BqCLp3huayZ4HXiXJEIu+7AJnXHzwxBW3CvIx+1+OwRkYZO5selxvNYYa5sNQUWigwKGcYU8VhKK4H6qGYE8hgkt9xdHJ4NzsX12fy2XklU23A0wthzNgN9oAekV root@plnx_MercuryXU5_EndcapSL
Fingerprint: sha1!! 94:7d:35:b9:0d:75:18:c1:d5:b2:98:10:68:c9:f5:6d:66:bd:e6:80
dropbear.
Starting internet superserver: inetd.
Starting syslogd/klogd: done
Starting tcf-agent: OK

PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: [   21.950944] macb ff0b0000.ethernet eth0: link up (1000/Full)
[   21.956613] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready

PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: 
PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: root
Password: 
7[r[999;999H[6n8root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether ca:9f:1e:3a:b6:24 brd ff:ff:ff:ff:ff:ff
    inet 130.87.242.129/22 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::c89f:1eff:fe3a:b624/64 scope link 
       valid_lft forever preferred_lft forever
4: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether ca:9f:1e:3a:b6:25 brd ff:ff:ff:ff:ff:ff
root@plnx_MercuryXU5_EndcapSL:~# ping www/ .go  google.com
ping: bad address 'www.google.com'
root@plnx_MercuryXU5_EndcapSL:~# ping tkyice.icepp.s.u-tolyp.ac.jp
ping: bad address 'tkyice.icepp.s.u-tolyp.ac.jp'
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# cat /syts  s/class/uio/uio
uio0/ uio1/ uio2/ uio3/ uio4/ 
root@plnx_MercuryXU5_EndcapSL:~# cat /sys/class/uio/uio*/name
debug_bridge
axi-pmon
axi-pmon
axi-pmon
axi-pmon
root@plnx_MercuryXU5_EndcapSL:~# xvcserver 
[  328.730631] TCP: request_sock_TCP: Possible SYN flooding on port 2542. Sending cookies.  Check SNMP counters.
connection accepted - fd 3
setting TCP_NODELAY to 1
invalid cmd 'E'
connection accepted - fd 3
setting TCP_NODELAY to 1
invalid cmd 'E'
^[[A^[[A^[[A^[[A^[[A^[[A^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B^[[B


^C
root@plnx_MercuryXU5_EndcapSL:~# xvcserver cat /sys/class/uio/uio*/nameping tkyice.icepp.s.u-tolyp.ac.jp[P[P[P[P[P[P[P[P[P[P[P[P[P[Pwww.google.comip a[K
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether ca:9f:1e:3a:b6:24 brd ff:ff:ff:ff:ff:ff
    inet 130.87.242.129/22 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::c89f:1eff:fe3a:b624/64 scope link 
       valid_lft forever preferred_lft forever
4: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether ca:9f:1e:3a:b6:25 brd ff:ff:ff:ff:ff:ff
root@plnx_MercuryXU5_EndcapSL:~# ip axvcserver 



^C
root@plnx_MercuryXU5_EndcapSL:~# find / name      -name ""x"v"c"s"e"r"v"e"r"
/media/sd-mmcblk1p2/usr/bin/xvcserver
/media/sd-mmcblk1p2/usr/share/licenses/xvcserver
/usr/bin/xvcserver
/usr/share/licenses/xvcserver
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# Xilinx Zynq MP First Stage Boot Loader 
Release 2020.1   Nov 30 2021  -  13:31:53
NOTICE:  ATF running on XCZU5EV/silicon v4/RTL5.1 at 0xfffea000
NOTICE:  BL31: v2.2(release):xilinx_rebase_v2.2_2020.1
NOTICE:  BL31: Built : 13:29:52, Nov 30 2021


U-Boot 2020.01 (Nov 30 2021 - 13:30:56 +0000)

Model: Enclustra ME-XU5-5EV-2I-D12E SOM
Board: Xilinx ZynqMP
DRAM:  4 GiB
usb dr_mode not found
usb dr_mode not found
PMUFW:	v1.1
EL Level:	EL2
Chip ID:	zu5ev
NAND:  0 MiB
MMC:   mmc@ff160000: 0, mmc@ff170000: 1
In:    serial@ff000000
Out:   serial@ff000000
Err:   serial@ff000000
Bootmode: SD_MODE1
Reset reason:	EXTERNAL 
Net:   
ZYNQ GEM: ff0b0000, mdio bus ff0b0000, phyaddr 3, interface rgmii-id

Warning: ethernet@ff0b0000 (eth0) using random MAC address - ca:fd:e6:f8:b3:2c
eth0: ethernet@ff0b0000
Hit any key to stop autoboot:  2  1  0 
switch to partitions #0, OK
mmc1 is current device
Scanning mmc 1:1...
Found U-Boot script /boot.scr
3694 bytes read in 19 ms (189.5 KiB/s)
## Executing script at 20000000
[L0MuESL] Before SD card scanning... 
[L0MuESL] SD card scanning now...
[L0MuESL] Loading uEnv.txt in SD1... 
1272 bytes read in 18 ms (68.4 KiB/s)
[L0MuESL] Loading u-boot environment by uenvcmd... 
[L0MuESL] SD card fatload now ...
8159148 bytes read in 609 ms (12.8 MiB/s)
[L0MuESL] SD card bootm command now...
## Loading kernel from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'kernel@1' kernel subimage
     Description:  Linux kernel
     Type:         Kernel Image
     Compression:  gzip compressed
     Data Start:   0x100000e8
     Data Size:    8114710 Bytes = 7.7 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00080000
     Entry Point:  0x00080000
     Hash algo:    sha256
     Hash value:   d8dbc87352877e020871a801ceda165f06fa467dc974d45677a3e9058465f51f
   Verifying Hash Integrity ... sha256+ OK
## Loading fdt from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'fdt@system-top.dtb' fdt subimage
     Description:  Flattened Device Tree blob
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x107bd410
     Data Size:    42547 Bytes = 41.5 KiB
     Architecture: AArch64
     Hash algo:    sha256
     Hash value:   c2cb860e94d3969dd7865705c3edff938ff4058f8cd3fe6c0a353a4664c16d1c
   Verifying Hash Integrity ... sha256+ OK
   Booting using the fdt blob at 0x107bd410
   Uncompressing Kernel Image
   Loading Device Tree to 000000000fff2000, end 000000000ffff632 ... OK

Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]
[    0.000000] Linux version 5.4.0-xilinx-v2020.1 (oe-user@oe-host) (gcc version 9.2.0 (GCC)) #1 SMP Tue Nov 30 13:29:56 UTC 2021
[    0.000000] Machine model: Enclustra ME-XU5-5EV-2I-D12E SOM
[    0.000000] earlycon: cdns0 at MMIO 0x00000000ff000000 (options '115200n8')
[    0.000000] printk: bootconsole [cdns0] enabled
[    0.000000] efi: Getting EFI parameters from FDT:
[    0.000000] efi: UEFI not found.
[    0.000000] cma: Reserved 256 MiB at 0x000000006fc00000
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.1 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
[    0.000000] psci: MIGRATE_INFO_TYPE not supported.
[    0.000000] psci: SMC Calling Convention v1.1
[    0.000000] percpu: Embedded 21 pages/cpu s49112 r8192 d28712 u86016
[    0.000000] Detected VIPT I-cache on CPU0
[    0.000000] CPU features: detected: ARM erratum 845719
[    0.000000] Speculative Store Bypass Disable mitigation not required
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 1031940
[    0.000000] Kernel command line: earlycon console=ttyPS0,115200 clk_ignore_unused root=/dev/mmcblk1p2 rootfstype=ext4 rw rootwait earlyprintk uio_pdrv_genirq.of_id=generic-uio cpuidle.off=1 ip=130.87.242.129:130.87.240.1:255.255.252.0:sl-xu5-eth0-01:eth0:off nameserver=130.87.240.2 nameserver=130.87.240.3
[    0.000000] Dentry cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)
[    0.000000] Inode-cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] software IO TLB: mapped [mem 0x6bc00000-0x6fc00000] (64MB)
[    0.000000] Memory: 3767708K/4193280K available (11644K kernel code, 670K rwdata, 3624K rodata, 704K init, 321K bss, 163428K reserved, 262144K cma-reserved)
[    0.000000] rcu: Hierarchical RCU implementation.
[    0.000000] rcu: 	RCU event tracing is enabled.
[    0.000000] rcu: 	RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] GIC: Adjusting CPU interface base to 0x00000000f902f000
[    0.000000] GIC: Using split EOI/Deactivate mode
[    0.000000] random: get_random_bytes called from start_kernel+0x2a8/0x42c with crng_init=0
[    0.000000] arch_timer: cp15 timer(s) running at 33.33MHz (phys).
[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x7b0074340, max_idle_ns: 440795202884 ns
[    0.000003] sched_clock: 56 bits at 33MHz, resolution 30ns, wraps every 2199023255543ns
[    0.008259] Console: colour dummy device 80x25
[    0.012390] Calibrating delay loop (skipped), value calculated using timer frequency.. 66.66 BogoMIPS (lpj=133332)
[    0.022667] pid_max: default: 32768 minimum: 301
[    0.027382] Mount-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.034614] Mountpoint-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.043261] ASID allocator initialised with 32768 entries
[    0.047805] rcu: Hierarchical SRCU implementation.
[    0.052693] EFI services will not be available.
[    0.057132] smp: Bringing up secondary CPUs ...
[    0.061816] Detected VIPT I-cache on CPU1
[    0.061845] CPU1: Booted secondary processor 0x0000000001 [0x410fd034]
[    0.062163] Detected VIPT I-cache on CPU2
[    0.062181] CPU2: Booted secondary processor 0x0000000002 [0x410fd034]
[    0.062477] Detected VIPT I-cache on CPU3
[    0.062494] CPU3: Booted secondary processor 0x0000000003 [0x410fd034]
[    0.062537] smp: Brought up 1 node, 4 CPUs
[    0.096970] SMP: Total of 4 processors activated.
[    0.101643] CPU features: detected: 32-bit EL0 Support
[    0.106746] CPU features: detected: CRC32 instructions
[    0.111876] CPU: All CPU(s) started at EL2
[    0.115925] alternatives: patching kernel code
[    0.121333] devtmpfs: initialized
[    0.127794] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[    0.133313] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)
[    0.145622] xor: measuring software checksum speed
[    0.184206]    8regs     :  2639.000 MB/sec
[    0.224230]    32regs    :  3027.000 MB/sec
[    0.264259]    arm64_neon:  2628.000 MB/sec
[    0.264295] xor: using function: 32regs (3027.000 MB/sec)
[    0.268168] pinctrl core: initialized pinctrl subsystem
[    0.273930] NET: Registered protocol family 16
[    0.278754] DMA: preallocated 256 KiB pool for atomic allocations
[    0.283843] audit: initializing netlink subsys (disabled)
[    0.289294] audit: type=2000 audit(0.228:1): state=initialized audit_enabled=0 res=1
[    0.289745] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    0.314331] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages
[    0.315383] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages
[    0.322050] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages
[    0.328707] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages
[    1.301719] DRBG: Continuing without Jitter RNG
[    1.378097] raid6: neonx8   gen()  1717 MB/s
[    1.446141] raid6: neonx8   xor()  1624 MB/s
[    1.514192] raid6: neonx4   gen()  1644 MB/s
[    1.582197] raid6: neonx4   xor()  1577 MB/s
[    1.650282] raid6: neonx2   gen()  1249 MB/s
[    1.718291] raid6: neonx2   xor()  1303 MB/s
[    1.786317] raid6: neonx1   gen()   808 MB/s
[    1.854369] raid6: neonx1   xor()   979 MB/s
[    1.922408] raid6: int64x8  gen()  1291 MB/s
[    1.990429] raid6: int64x8  xor()   840 MB/s
[    2.058498] raid6: int64x4  gen()  1085 MB/s
[    2.126521] raid6: int64x4  xor()   814 MB/s
[    2.194580] raid6: int64x2  gen()   753 MB/s
[    2.262615] raid6: int64x2  xor()   657 MB/s
[    2.330654] raid6: int64x1  gen()   499 MB/s
[    2.398700] raid6: int64x1  xor()   500 MB/s
[    2.398736] raid6: using algorithm neonx8 gen() 1717 MB/s
[    2.402694] raid6: .... xor() 1624 MB/s, rmw enabled
[    2.407624] raid6: using neon recovery algorithm
[    2.412511] iommu: Default domain type: Translated 
[    2.417243] SCSI subsystem initialized
[    2.420896] usbcore: registered new interface driver usbfs
[    2.426248] usbcore: registered new interface driver hub
[    2.431520] usbcore: registered new device driver usb
[    2.436554] mc: Linux media interface: v0.10
[    2.440770] videodev: Linux video capture interface: v2.00
[    2.446218] pps_core: LinuxPPS API ver. 1 registered
[    2.451135] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    2.460227] PTP clock support registered
[    2.464118] EDAC MC: Ver: 3.0.0
[    2.467569] zynqmp-ipi-mbox mailbox@ff990400: Registered ZynqMP IPI mbox with TX/RX channels.
[    2.475855] FPGA manager framework
[    2.479183] Advanced Linux Sound Architecture Driver Initialized.
[    2.485369] Bluetooth: Core ver 2.22
[    2.488690] NET: Registered protocol family 31
[    2.493089] Bluetooth: HCI device and connection manager initialized
[    2.499405] Bluetooth: HCI socket layer initialized
[    2.504248] Bluetooth: L2CAP socket layer initialized
[    2.509269] Bluetooth: SCO socket layer initialized
[    2.514507] clocksource: Switched to clocksource arch_sys_counter
[    2.520263] VFS: Disk quotas dquot_6.6.0
[    2.524102] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[    2.534602] NET: Registered protocol family 2
[    2.535511] tcp_listen_portaddr_hash hash table entries: 2048 (order: 3, 32768 bytes, linear)
[    2.543734] TCP established hash table entries: 32768 (order: 6, 262144 bytes, linear)
[    2.551746] TCP bind hash table entries: 32768 (order: 7, 524288 bytes, linear)
[    2.559176] TCP: Hash tables configured (established 32768 bind 32768)
[    2.565375] UDP hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.572042] UDP-Lite hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.579211] NET: Registered protocol family 1
[    2.583642] RPC: Registered named UNIX socket transport module.
[    2.589283] RPC: Registered udp transport module.
[    2.593950] RPC: Registered tcp transport module.
[    2.598622] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    2.605247] PCI: CLS 0 bytes, default 64
[    2.609429] hw perfevents: no interrupt-affinity property for /pmu, guessing.
[    2.616148] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    2.624388] Initialise system trusted keyrings
[    2.628189] workingset: timestamp_bits=46 max_order=20 bucket_order=0
[    2.635201] NFS: Registering the id_resolver key type
[    2.639548] Key type id_resolver registered
[    2.643687] Key type id_legacy registered
[    2.647671] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    2.654340] jffs2: version 2.2. (NAND) Â© 2001-2006 Red Hat, Inc.
[    2.671745] NET: Registered protocol family 38
[    2.671784] Key type asymmetric registered
[    2.674614] Asymmetric key parser 'x509' registered
[    2.679473] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 247)
[    2.686809] io scheduler mq-deadline registered
[    2.691306] io scheduler kyber registered
[    2.719642] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[    2.723169] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    2.730169] brd: module loaded
[    2.734205] loop: module loaded
[    2.734834] mtdoops: mtd device (mtddev=name/number) must be supplied
[    2.739909] libphy: Fixed MDIO Bus: probed
[    2.743858] tun: Universal TUN/TAP device driver, 1.6
[    2.748110] CAN device driver interface
[    2.752548] usbcore: registered new interface driver asix
[    2.757236] usbcore: registered new interface driver ax88179_178a
[    2.763275] usbcore: registered new interface driver cdc_ether
[    2.769069] usbcore: registered new interface driver net1080
[    2.774693] usbcore: registered new interface driver cdc_subset
[    2.780574] usbcore: registered new interface driver zaurus
[    2.786118] usbcore: registered new interface driver cdc_ncm
[    2.791806] uio_pdrv_genirq 80020000.debug_bridge: IRQ index 0 not found
[    2.799173] usbcore: registered new interface driver uas
[    2.803681] usbcore: registered new interface driver usb-storage
[    2.810106] rtc_zynqmp ffa60000.rtc: registered as rtc0
[    2.814848] i2c /dev entries driver
[    2.819542] usbcore: registered new interface driver uvcvideo
[    2.823984] USB Video Class driver (1.1.1)
[    2.828350] Bluetooth: HCI UART driver ver 2.3
[    2.832462] Bluetooth: HCI UART protocol H4 registered
[    2.837562] Bluetooth: HCI UART protocol BCSP registered
[    2.842851] Bluetooth: HCI UART protocol LL registered
[    2.847941] Bluetooth: HCI UART protocol ATH3K registered
[    2.853315] Bluetooth: HCI UART protocol Three-wire (H5) registered
[    2.859561] Bluetooth: HCI UART protocol Intel registered
[    2.864908] Bluetooth: HCI UART protocol QCA registered
[    2.870109] usbcore: registered new interface driver bcm203x
[    2.875729] usbcore: registered new interface driver bpa10x
[    2.881263] usbcore: registered new interface driver bfusb
[    2.886715] usbcore: registered new interface driver btusb
[    2.892177] usbcore: registered new interface driver ath3k
[    2.897734] EDAC MC0: 13 UE BankGroup Number 0 Block Number 0 on mc#0csrow#0channel#0 (csrow:0 channel:0 page:0x0 offset:0x0 grain:1)
[    2.909620] EDAC MC0: Giving out device to module 1 controller synps_ddr_controller: DEV synps_edac (INTERRUPT)
[    2.919684] EDAC DEVICE0: Giving out device to module edac controller cache_err: DEV edac (POLLED)
[    2.928617] EDAC DEVICE1: Giving out device to module zynqmp-ocm-edac controller zynqmp_ocm: DEV ff960000.memory-controller (INTERRUPT)
[    2.940903] sdhci: Secure Digital Host Controller Interface driver
[    2.946729] sdhci: Copyright(c) Pierre Ossman
[    2.951050] sdhci-pltfm: SDHCI platform and OF driver helper
[    2.956981] ledtrig-cpu: registered to indicate activity on CPUs
[    2.962684] zynqmp_firmware_probe Platform Management API v1.1
[    2.968440] zynqmp_firmware_probe Trustzone version v1.0
[    2.996261] alg: No test for xilinx-zynqmp-aes (zynqmp-aes)
[    2.996425] zynqmp_aes zynqmp_aes: AES Successfully Registered
[    2.996425] 
[    3.003677] alg: No test for xilinx-keccak-384 (zynqmp-keccak-384)
[    3.009887] alg: No test for xilinx-zynqmp-rsa (zynqmp-rsa)
[    3.015440] usbcore: registered new interface driver usbhid
[    3.020755] usbhid: USB HID core driver
[    3.026675] fpga_manager fpga0: Xilinx ZynqMP FPGA Manager registered
[    3.031221] usbcore: registered new interface driver snd-usb-audio
[    3.037790] pktgen: Packet Generator for packet performance testing. Version: 2.75
[    3.045108] Initializing XFRM netlink socket
[    3.048941] NET: Registered protocol family 10
[    3.053641] Segment Routing with IPv6
[    3.057013] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[    3.063098] NET: Registered protocol family 17
[    3.067215] NET: Registered protocol family 15
[    3.071629] bridge: filtering via arp/ip/ip6tables is no longer available by default. Update your scripts to load br_netfilter if you need this.
[    3.084507] can: controller area network core (rev 20170425 abi 9)
[    3.090667] NET: Registered protocol family 29
[    3.095059] can: raw protocol (rev 20170425)
[    3.099296] can: broadcast manager protocol (rev 20170425 t)
[    3.104920] can: netlink gateway (rev 20190810) max_hops=1
[    3.110438] Bluetooth: RFCOMM TTY layer initialized
[    3.115218] Bluetooth: RFCOMM socket layer initialized
[    3.120323] Bluetooth: RFCOMM ver 1.11
[    3.124040] Bluetooth: BNEP (Ethernet Emulation) ver 1.3
[    3.129310] Bluetooth: BNEP filters: protocol multicast
[    3.134505] Bluetooth: BNEP socket layer initialized
[    3.139432] Bluetooth: HIDP (Human Interface Emulation) ver 1.2
[    3.145316] Bluetooth: HIDP socket layer initialized
[    3.150344] 9pnet: Installing 9P2000 support
[    3.154506] Key type dns_resolver registered
[    3.159074] registered taskstats version 1
[    3.162790] Loading compiled-in X.509 certificates
[    3.167908] Btrfs loaded, crc32c=crc32c-generic
[    3.179809] ff000000.serial: ttyPS0 at MMIO 0xff000000 (irq = 41, base_baud = 6249999) is a xuartps
[    3.188826] printk: console [ttyPS0] enabled
[    3.188826] printk: console [ttyPS0] enabled
[    3.193120] printk: bootconsole [cdns0] disabled
[    3.193120] printk: bootconsole [cdns0] disabled
[    3.202279] of-fpga-region fpga-full: FPGA Region probed
[    3.212335] GPIO IRQ not connected
[    3.215729] XGpio: gpio@80010000: registered, base is 509
[    3.221698] xilinx-zynqmp-dma fd500000.dma: ZynqMP DMA driver Probe success
[    3.228785] xilinx-zynqmp-dma fd510000.dma: ZynqMP DMA driver Probe success
[    3.235878] xilinx-zynqmp-dma fd520000.dma: ZynqMP DMA driver Probe success
[    3.242966] xilinx-zynqmp-dma fd530000.dma: ZynqMP DMA driver Probe success
[    3.250052] xilinx-zynqmp-dma fd540000.dma: ZynqMP DMA driver Probe success
[    3.257135] xilinx-zynqmp-dma fd550000.dma: ZynqMP DMA driver Probe success
[    3.264220] xilinx-zynqmp-dma fd560000.dma: ZynqMP DMA driver Probe success
[    3.271310] xilinx-zynqmp-dma fd570000.dma: ZynqMP DMA driver Probe success
[    3.278461] xilinx-zynqmp-dma ffa80000.dma: ZynqMP DMA driver Probe success
[    3.285546] xilinx-zynqmp-dma ffa90000.dma: ZynqMP DMA driver Probe success
[    3.292637] xilinx-zynqmp-dma ffaa0000.dma: ZynqMP DMA driver Probe success
[    3.299720] xilinx-zynqmp-dma ffab0000.dma: ZynqMP DMA driver Probe success
[    3.306807] xilinx-zynqmp-dma ffac0000.dma: ZynqMP DMA driver Probe success
[    3.313896] xilinx-zynqmp-dma ffad0000.dma: ZynqMP DMA driver Probe success
[    3.320985] xilinx-zynqmp-dma ffae0000.dma: ZynqMP DMA driver Probe success
[    3.328068] xilinx-zynqmp-dma ffaf0000.dma: ZynqMP DMA driver Probe success
[    3.335270] zynqmp-qspi ff0f0000.spi: rx bus width not found
[    3.340926] zynqmp-qspi ff0f0000.spi: tx bus width not found
[    3.346735] spi_master spi0: cannot find modalias for /amba/spi@ff0f0000/flash@0
[    3.354127] spi_master spi0: Failed to create SPI device for /amba/spi@ff0f0000/flash@0
[    3.362416] macb ff0b0000.ethernet: Not enabling partial store and forward
[    3.369771] libphy: MACB_mii_bus: probed
[    3.375121] zynqmp_pll_disable() clock disable failed for dpll_int, ret = -13
[    3.443684] Micrel KSZ9031 Gigabit PHY ff0b0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0b0000.ethernet-ffffffff:03, irq=POLL)
[    3.459498] macb ff0b0000.ethernet eth0: Cadence GEM rev 0x50070106 at 0xff0b0000 irq 29 (ca:9f:1e:3a:b6:24)
[    3.469578] macb ff0c0000.ethernet: Not enabling partial store and forward
[    3.476841] libphy: MACB_mii_bus: probed
[    3.551678] Micrel KSZ9031 Gigabit PHY ff0c0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0c0000.ethernet-ffffffff:03, irq=POLL)
[    3.567494] macb ff0c0000.ethernet eth1: Cadence GEM rev 0x50070106 at 0xff0c0000 irq 30 (ca:9f:1e:3a:b6:25)
[    3.577569] xilinx-axipmon ffa00000.perf-monitor: Probed Xilinx APM
[    3.584066] xilinx-axipmon fd0b0000.perf-monitor: Probed Xilinx APM
[    3.590618] xilinx-axipmon fd490000.perf-monitor: Probed Xilinx APM
[    3.597088] xilinx-axipmon ffa10000.perf-monitor: Probed Xilinx APM
[    3.603565] dwc3-of-simple ff9d0000.usb0: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.611845] dwc3 fe200000.dwc3: Failed to get clk 'ref': -2
[    3.617807] dwc3-of-simple ff9e0000.usb1: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.626026] dwc3 fe300000.dwc3: Failed to get clk 'ref': -2
[    3.632646] i2c i2c-0: Added multiplexed i2c bus 1
[    3.637759] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.643252] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 1
[    3.650994] xhci-hcd xhci-hcd.0.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.660402] xhci-hcd xhci-hcd.0.auto: irq 43, io mem 0xfe200000
[    3.666475] i2c i2c-0: Added multiplexed i2c bus 2
[    3.671563] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.677093] i2c i2c-0: Added multiplexed i2c bus 3
[    3.682068] i2c i2c-0: Added multiplexed i2c bus 4
[    3.687046] i2c i2c-0: Added multiplexed i2c bus 5
[    3.691942] i2c i2c-0: Added multiplexed i2c bus 6
[    3.696815] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.705072] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.712290] usb usb1: Product: xHCI Host Controller
[    3.717158] usb usb1: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.723764] usb usb1: SerialNumber: xhci-hcd.0.auto
[    3.728858] i2c i2c-0: Added multiplexed i2c bus 7
[    3.733792] i2c i2c-0: Added multiplexed i2c bus 8
[    3.738581] pca954x 0-0070: registered 8 multiplexed busses for I2C switch pca9548
[    3.746164] cdns-i2c ff020000.i2c: 400 kHz mmio ff020000 irq 32
[    3.752428] cpufreq: cpufreq_online: CPU0: Running at unlisted freq: 1333333 KHz
[    3.759823] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.768556] cpufreq: cpufreq_online: CPU0: Unlisted initial frequency changed to: 1199999 KHz
[    3.777082] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.786810] hub 1-0:1.0: USB hub found
[    3.790577] hub 1-0:1.0: 1 port detected
[    3.794660] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.800148] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 2
[    3.807807] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed
[    3.814375] usb usb2: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.822530] usb usb2: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.830791] usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.838003] usb usb2: Product: xHCI Host Controller
[    3.842872] usb usb2: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.849477] usb usb2: SerialNumber: xhci-hcd.0.auto
[    3.854716] hub 2-0:1.0: USB hub found
[    3.858470] hub 2-0:1.0: 1 port detected
[    3.862578] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 3
[    3.870312] xhci-hcd xhci-hcd.1.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.879716] xhci-hcd xhci-hcd.1.auto: irq 46, io mem 0xfe300000
[    3.885854] usb usb3: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.894115] usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.901338] usb usb3: Product: xHCI Host Controller
[    3.906219] usb usb3: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.912826] usb usb3: SerialNumber: xhci-hcd.1.auto
[    3.917785] mmc0: SDHCI controller on ff160000.mmc [ff160000.mmc] using ADMA 64-bit
[    3.926735] hub 3-0:1.0: USB hub found
[    3.930551] hub 3-0:1.0: 1 port detected
[    3.934714] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.940203] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 4
[    3.947856] xhci-hcd xhci-hcd.1.auto: Host supports USB 3.0 SuperSpeed
[    3.954468] usb usb4: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.962684] usb usb4: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.970943] usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.978160] usb usb4: Product: xHCI Host Controller
[    3.983030] usb usb4: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.989635] usb usb4: SerialNumber: xhci-hcd.1.auto
[    3.994621] mmc1: SDHCI controller on ff170000.mmc [ff170000.mmc] using ADMA 64-bit
[    4.004574] rtc_zynqmp ffa60000.rtc: setting system clock to 1970-01-01T00:00:09 UTC (9)
[    4.012658] of_cfs_init
[    4.015107] of_cfs_init: OK
[    4.018264] hub 4-0:1.0: USB hub found
[    4.022136] hub 4-0:1.0: 1 port detected
[    4.059816] mmc1: new high speed SDHC card at address 5048
[    4.065686] mmcblk1: mmc1:5048 SD16G 14.4 GiB 
[    4.071496]  mmcblk1: p1 p2
[    4.103195] mmc0: new HS200 MMC card at address 0001
[    4.108463] mmcblk0: mmc0:0001 W52516 14.3 GiB 
[    4.113163] mmcblk0boot0: mmc0:0001 W52516 partition 1 4.00 MiB
[    4.119241] mmcblk0boot1: mmc0:0001 W52516 partition 2 4.00 MiB
[    4.125212] mmcblk0rpmb: mmc0:0001 W52516 partition 3 4.00 MiB, chardev (245:0)
[    4.134455]  mmcblk0: p1
[   16.286523] cfg80211: Loading compiled-in X.509 certificates for regulatory database
[   16.410199] cfg80211: Loaded X.509 cert 'sforshee: 00b28ddf47aef9cea7'
[   16.416721] clk: Not disabling unused clocks
[   16.420986] ALSA device list:
[   16.423944]   No soundcards found.
[   16.427609] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2
[   16.436217] cfg80211: failed to load regulatory.db
[   16.713240] random: fast init done
[   17.368192] EXT4-fs (mmcblk1p2): recovery complete
[   17.377041] EXT4-fs (mmcblk1p2): mounted filesystem with ordered data mode. Opts: (null)
[   17.385161] VFS: Mounted root (ext4 filesystem) on device 179:2.
[   17.399455] devtmpfs: mounted
[   17.402571] Freeing unused kernel memory: 704K
[   17.407039] Run /sbin/init as init process
[   17.890412] random: systemd: uninitialized urandom read (16 bytes read)
[   17.906428] random: systemd: uninitialized urandom read (16 bytes read)
[   17.943502] systemd[1]: systemd 219 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 -SECCOMP +BLKID +ELFUTILS +KMOD +IDN)
[   17.961807] systemd[1]: Detected architecture arm64.

Welcome to [0;31mCentOS Linux 7 (AltArch)[0m!

[   17.987530] systemd[1]: Set hostname to <sl-xu5-01>.
[   18.011577] random: systemd: uninitialized urandom read (16 bytes read)
[   18.583340] systemd[1]: Reached target Swap.
[[32m  OK  [0m] Reached target Swap.
[   18.599198] systemd[1]: Created slice Root Slice.
[[32m  OK  [0m] Created slice Root Slice.
[   18.614622] systemd[1]: Listening on Device-mapper event daemon FIFOs.
[[32m  OK  [0m] Listening on Device-mapper event daemon FIFOs.
[   18.638608] systemd[1]: Listening on LVM2 metadata daemon socket.
[[32m  OK  [0m] Listening on LVM2 metadata daemon socket.
[   18.654609] systemd[1]: Listening on /dev/initctl Compatibility Named Pipe.
[[32m  OK  [0m] Listening on /dev/initctl Compatibility Named Pipe.
[   18.678616] systemd[1]: Listening on udev Control Socket.
[[32m  OK  [0m] Listening on udev Control Socket.
[   18.694667] systemd[1]: Listening on Journal Socket.
[[32m  OK  [0m] Listening on Journal Socket.
[[32m  OK  [0m] Listening on udev Kernel Socket.
[[32m  OK  [0m] Created slice System Slice.
         Starting Monitoring of LVM2 mirrors... dmeventd or progress polling...
         Starting Read and set NIS domainname from /etc/sysconfig/network...
         Starting Journal Service...
[[32m  OK  [0m] Created slice system-selinux\x2dpol...grate\x2dlocal\x2dchanges.slice.
[[32m  OK  [0m] Created slice system-serial\x2dgetty.slice.
         Mounting Huge Pages File System...
         Mounting Debug File System...
[[32m  OK  [0m] Listening on LVM2 poll daemon socket.
[[32m  OK  [0m] Created slice User and Session Slice.
[[32m  OK  [0m] Reached target Slices.
[[32m  OK  [0m] Created slice system-getty.slice.
         Mounting POSIX Message Queue File System...
[[32m  OK  [0m] Started Forward Password Requests to Wall Directory Watch.
[[32m  OK  [0m] Listening on Delayed Shutdown Socket.
         Starting Collect Read-Ahead Data...
[[32m  OK  [0m] Mounted POSIX Message Queue File System.
[[32m  OK  [0m] Mounted Huge Pages File System.
[   18.992485] systemd-readahead[170]: Failed to create fanotify object: Function not implemented
[[32m  OK  [0m] Mounted Debug File System.
[[32m  OK  [0m] Started Journal Service.
[[32m  OK  [0m] Started Read and set NIS domainname from /etc/sysconfig/network.
[[1;31mFAILED[0m] Failed to start Collect Read-Ahead Data.
See 'systemctl status systemd-readahead-collect.service' for details.
[[32m  OK  [0m] Started LVM2 metadata daemon.
         Starting Create Static Device Nodes in /dev...
         Starting Setup Virtual Console...
         Starting Configure read-only root support...
         Starting udev Coldplug all Devices...
         Mounting Configuration File System...
         Starting Apply Kernel Variables...
         Starting Flush Journal to Persistent Storage...
[[32m  OK  [0m] Mounted Configuration File System.
[[32m  OK  [0m] Started Configure read-only root support.
         Starting Load/Save Random Seed...
[[32m  OK  [0m] Started Create Static Device Nodes in /dev.
         Starting udev Kernel Device Manager...
[[32m  OK  [0m] Started Apply Kernel Variables.
[   19.306760] systemd-journald[160]: Received request to flush runtime journal from PID 1
[[32m  OK  [0m] Started udev Coldplug all Devices.
[[32m  OK  [0m] Started Load/Save Random Seed.
[[32m  OK  [0m] Started Flush Journal to Persistent Storage.
         Starting udev Wait for Complete Device Initialization...
[[32m  OK  [0m] Started udev Kernel Device Manager.
[[32m  OK  [0m] Started Setup Virtual Console.
         Starting Show Plymouth Boot Screen...
[[32m  OK  [0m] Found device /dev/ttyPS0.
[[32m  OK  [0m] Started Show Plymouth Boot Screen.
[[32m  OK  [0m] Started Forward Password Requests to Plymouth Directory Watch.
%G[[32m  OK  [0m] Started udev Wait for Complete Device Initialization.
         Starting Activation of DM RAID sets...
[[32m  OK  [0m] Started Monitoring of LVM2 mirrors,...ng dmeventd or progress polling.
[[32m  OK  [0m] Reached target Local File Systems (Pre).
[[32m  OK  [0m] Started Activation of DM RAID sets.
[[32m  OK  [0m] Reached target Local File Systems.
         Starting Create Volatile Files and Directories...
         Starting Tell Plymouth To Write Out Runtime Data...
[[32m  OK  [0m] Reached target Local Encrypted Volumes.
[[32m  OK  [0m] Started Tell Plymouth To Write Out Runtime Data.
[[32m  OK  [0m] Started Create Volatile Files and Directories.
         Starting Security Auditing Service...
[[32m  OK  [0m] Started Security Auditing Service.
         Starting Update UTMP about System Boot/Shutdown...
[[32m  OK  [0m] Started Update UTMP about System Boot/Shutdown.
[[32m  OK  [0m] Reached target System Initialization.
[[32m  OK  [0m] Listening on D-Bus System Message Bus Socket.
[[32m  OK  [0m] Listening on PC/SC Smart Card Daemon Activation Socket.
[[32m  OK  [0m] Listening on Open-iSCSI iscsid Socket.
[[32m  OK  [0m] Started Flexible branding.
[[32m  OK  [0m] Reached target Paths.
[[32m  OK  [0m] Listening on Open-iSCSI iscsiuio Socket.
[[32m  OK  [0m] Reached target Sockets.
[[32m  OK  [0m] Reached target Basic System.
         Starting NTP client/server...
[[32m  OK  [0m] Started irqbalance daemon.
[[32m  OK  [0m] Started D-Bus System Message Bus.
         Starting Login Service...
         Starting Authorization Manager...
         Starting Dump dmesg to /var/log/dmesg...
[[32m  OK  [0m] Started Daily Cleanup of Temporary Directories.
[[32m  OK  [0m] Reached target Timers.
[[32m  OK  [0m] Started NTP client/server.
[[32m  OK  [0m] Started Login Service.
[[32m  OK  [0m] Started Dump dmesg to /var/log/dmesg.
[[32m  OK  [0m] Started Authorization Manager.
         Starting firewalld - dynamic firewall daemon...
[[32m  OK  [0m] Started firewalld - dynamic firewall daemon.
[[32m  OK  [0m] Reached target Network (Pre).
         Starting Network Manager...
[[32m  OK  [0m] Started Network Manager.
         Starting Network Manager Wait Online...
         Starting Hostname Service...
[[32m  OK  [0m] Started Hostname Service.
         Starting Network Manager Script Dispatcher Service...
[[32m  OK  [0m] Started Network Manager Script Dispatcher Service.
[   25.046415] pps pps0: new PPS source ptp0
[   25.050461] macb ff0b0000.ethernet: gem-ptp-timer ptp clock registered.
[   25.093148] pps pps1: new PPS source ptp1
[   25.097199] macb ff0c0000.ethernet: gem-ptp-timer ptp clock registered.
[   29.119157] macb ff0b0000.ethernet eth0: link up (1000/Full)
[   29.124828] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[   29.182815] macb ff0c0000.ethernet eth1: unable to generate target frequency: 125000000 Hz
[   29.191084] macb ff0c0000.ethernet eth1: link up (1000/Full)
[   29.196758] IPv6: ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
[[0m[31m*     [0m] A start job is running for Network ...ger Wait Online (11s / no limit)[K[[1;31m*[0m[31m*    [0m] A start job is running for Network ...ger Wait Online (12s / no limit)[K[[31m*[1;31m*[0m[31m*   [0m] A start job is running for Network ...ger Wait Online (12s / no limit)[K[ [31m*[1;31m*[0m[31m*  [0m] A start job is running for Network ...ger Wait Online (13s / no limit)[K[  [31m*[1;31m*[0m[31m* [0m] A start job is running for Network ...ger Wait Online (13s / no limit)[K[   [31m*[1;31m*[0m[31m*[0m] A start job is running for Network ...ger Wait Online (14s / no limit)[K[    [31m*[1;31m*[0m] A start job is running for Network ...ger Wait Online (15s / no limit)[K[     [31m*[0m] A start job is running for Network ...ger Wait Online (15s / no limit)[K[    [31m*[1;31m*[0m] A start job is running for Network ...ger Wait Online (16s / no limit)[K[   [31m*[1;31m*[0m[31m*[0m] A start job is running for Network ...ger Wait Online (16s / no limit)[K[  [31m*[1;31m*[0m[31m* [0m] A start job is running for Network ...ger Wait Online (17s / no limit)[K[ [31m*[1;31m*[0m[31m*  [0m] A start job is running for Network ...ger Wait Online (17s / no limit)[K[[31m*[1;31m*[0m[31m*   [0m] A start job is running for Network ...ger Wait Online (18s / no limit)[K         Starting Network Manager Script Dispatcher Service...
[[32m  OK  [0m] Started Network Manager Script Dispatcher Service.
[[1;31m*[0m[31m*    [0m] A start job is running for Network ...ger Wait Online (23s / no limit)[K[[0m[31m*     [0m] A start job is running for Network ...ger Wait Online (24s / no limit)[K[[1;31m*[0m[31m*    [0m] A start job is running for Network ...ger Wait Online (25s / no limit)[K[[31m*[1;31m*[0m[31m*   [0m] A start job is running for Network ...ger Wait Online (25s / no limit)[K[ [31m*[1;31m*[0m[31m*  [0m] A start job is running for Network ...ger Wait Online (26s / no limit)[K[  [31m*[1;31m*[0m[31m* [0m] A start job is running for Network ...ger Wait Online (26s / no limit)[K[   [31m*[1;31m*[0m[31m*[0m] A start job is running for Network ...ger Wait Online (27s / no limit)[K[    [31m*[1;31m*[0m] A start job is running for Network ...ger Wait Online (28s / no limit)[K[     [31m*[0m] A start job is running for Network ...ger Wait Online (28s / no limit)[K[    [31m*[1;31m*[0m] A start job is running for Network ...ger Wait Online (29s / no limit)[K[   [31m*[1;31m*[0m[31m*[0m] A start job is running for Network ...ger Wait Online (29s / no limit)[K[  [31m*[1;31m*[0m[31m* [0m] A start job is running for Network ...ger Wait Online (30s / no limit)[K[ [31m*[1;31m*[0m[31m*  [0m] A start job is running for Network ...ger Wait Online (30s / no limit)[K[[31m*[1;31m*[0m[31m*   [0m] A start job is running for Network ...ger Wait Online (31s / no limit)[K[[1;31m*[0m[31m*    [0m] A start job is running for Network ...ger Wait Online (31s / no limit)[K[[0m[31m*     [0m] A start job is running for Network ...ger Wait Online (32s / no limit)[K[[1;31m*[0m[31m*    [0m] A start job is running for Network ...ger Wait Online (33s / no limit)[K[[31m*[1;31m*[0m[31m*   [0m] A start job is running for Network ...ger Wait Online (33s / no limit)[K[ [31m*[1;31m*[0m[31m*  [0m] A start job is running for Network ...ger Wait Online (34s / no limit)[K[  [31m*[1;31m*[0m[31m* [0m] A start job is running for Network ...ger Wait Online (34s / no limit)[K[   [31m*[1;31m*[0m[31m*[0m] A start job is running for Network ...ger Wait Online (35s / no limit)[K[    [31m*[1;31m*[0m] A start job is running for Network ...ger Wait Online (35s / no limit)[K[     [31m*[0m] A start job is running for Network ...ger Wait Online (36s / no limit)[K[[1;31mFAILED[0m] Failed to start Network Manager Wait Online.
See 'systemctl status NetworkManager-wait-online.service' for details.
         Starting LSB: Bring up/down networking...
[[1;31mFAILED[0m] Failed to start LSB: Bring up/down networking.
See 'systemctl status network.service' for details.
[[32m  OK  [0m] Reached target Network.
         Starting Logout off all iSCSI sessions on shutdown...
[[32m  OK  [0m] Reached target Network is Online.
         Starting System Logging Service...
         Starting Dynamic System Tuning Daemon...
         Starting OpenSSH server daemon...
         Starting Postfix Mail Transport Agent...
[[32m  OK  [0m] Started Logout off all iSCSI sessions on shutdown.
         Starting Availability of block devices...
[[32m  OK  [0m] Reached target Remote File Systems (Pre).
[[32m  OK  [0m] Reached target Remote File Systems.
         Starting Crash recovery kernel arming...
         Starting Permit User Sessions...
[[32m  OK  [0m] Started Availability of block devices.
[[32m  OK  [0m] Started Permit User Sessions.
         Starting Wait for Plymouth Boot Screen to Quit...
[[32m  OK  [0m] Started Command Scheduler.
         Starting Terminate Plymouth Boot Screen...

CentOS Linux 7 (AltArch)
Kernel 5.4.0-xilinx-v2020.1 on an aarch64

sl-xu5-01 login: [  104.212118] random: crng init done
[  104.215512] random: 7 urandom warning(s) missed due to ratelimiting
Xilinx Zynq MP First Stage Boot Loader 
Release 2020.1   Nov 30 2021  -  13:31:53
Xilinx Zynq MP First Stage Boot Loader 
Release 2020.1   Nov 30 2021  -  13:31:53
NOTICE:  ATF running on XCZU5EV/silicon v4/RTL5.1 at 0xfffea000
NOTICE:  BL31: v2.2(release):xilinx_rebase_v2.2_2020.1
NOTICE:  BL31: Built : 13:29:52, Nov 30 2021


U-Boot 2020.01 (Nov 30 2021 - 13:30:56 +0000)

Model: Enclustra ME-XU5-5EV-2I-D12E SOM
Board: Xilinx ZynqMP
DRAM:  4 GiB
usb dr_mode not found
usb dr_mode not found
PMUFW:	v1.1
EL Level:	EL2
Chip ID:	zu5ev
NAND:  0 MiB
MMC:   mmc@ff160000: 0, mmc@ff170000: 1
In:    serial@ff000000
Out:   serial@ff000000
Err:   serial@ff000000
Bootmode: SD_MODE1
Reset reason:	EXTERNAL 
Net:   
ZYNQ GEM: ff0b0000, mdio bus ff0b0000, phyaddr 3, interface rgmii-id

Warning: ethernet@ff0b0000 (eth0) using random MAC address - de:b5:ba:41:23:d1
eth0: ethernet@ff0b0000
Hit any key to stop autoboot:  2  1  0 
switch to partitions #0, OK
mmc1 is current device
Scanning mmc 1:1...
Found U-Boot script /boot.scr
3694 bytes read in 18 ms (200.2 KiB/s)
## Executing script at 20000000
[L0MuESL] Before SD card scanning... 
[L0MuESL] SD card scanning now...
[L0MuESL] Loading uEnv.txt in SD1... 
1272 bytes read in 18 ms (68.4 KiB/s)
[L0MuESL] Loading u-boot environment by uenvcmd... 
[L0MuESL] SD card fatload now ...
8159148 bytes read in 611 ms (12.7 MiB/s)
[L0MuESL] SD card bootm command now...
## Loading kernel from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'kernel@1' kernel subimage
     Description:  Linux kernel
     Type:         Kernel Image
     Compression:  gzip compressed
     Data Start:   0x100000e8
     Data Size:    8114710 Bytes = 7.7 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00080000
     Entry Point:  0x00080000
     Hash algo:    sha256
     Hash value:   d8dbc87352877e020871a801ceda165f06fa467dc974d45677a3e9058465f51f
   Verifying Hash Integrity ... sha256+ OK
## Loading fdt from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'fdt@system-top.dtb' fdt subimage
     Description:  Flattened Device Tree blob
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x107bd410
     Data Size:    42547 Bytes = 41.5 KiB
     Architecture: AArch64
     Hash algo:    sha256
     Hash value:   c2cb860e94d3969dd7865705c3edff938ff4058f8cd3fe6c0a353a4664c16d1c
   Verifying Hash Integrity ... sha256+ OK
   Booting using the fdt blob at 0x107bd410
   Uncompressing Kernel Image
   Loading Device Tree to 000000000fff2000, end 000000000ffff632 ... OK

Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]
[    0.000000] Linux version 5.4.0-xilinx-v2020.1 (oe-user@oe-host) (gcc version 9.2.0 (GCC)) #1 SMP Tue Nov 30 13:29:56 UTC 2021
[    0.000000] Machine model: Enclustra ME-XU5-5EV-2I-D12E SOM
[    0.000000] earlycon: cdns0 at MMIO 0x00000000ff000000 (options '115200n8')
[    0.000000] printk: bootconsole [cdns0] enabled
[    0.000000] efi: Getting EFI parameters from FDT:
[    0.000000] efi: UEFI not found.
[    0.000000] cma: Reserved 256 MiB at 0x000000006fc00000
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.1 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
[    0.000000] psci: MIGRATE_INFO_TYPE not supported.
[    0.000000] psci: SMC Calling Convention v1.1
[    0.000000] percpu: Embedded 21 pages/cpu s49112 r8192 d28712 u86016
[    0.000000] Detected VIPT I-cache on CPU0
[    0.000000] CPU features: detected: ARM erratum 845719
[    0.000000] Speculative Store Bypass Disable mitigation not required
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 1031940
[    0.000000] Kernel command line: earlycon console=ttyPS0,115200 clk_ignore_unused root=/dev/mmcblk1p2 rootfstype=ext4 rw rootwait earlyprintk uio_pdrv_genirq.of_id=generic-uio cpuidle.off=1 ip=130.87.242.129:130.87.240.1:255.255.252.0:sl-xu5-eth0-01:eth0:off nameserver=130.87.240.2 nameserver=130.87.240.3
[    0.000000] Dentry cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)
[    0.000000] Inode-cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] software IO TLB: mapped [mem 0x6bc00000-0x6fc00000] (64MB)
[    0.000000] Memory: 3767708K/4193280K available (11644K kernel code, 670K rwdata, 3624K rodata, 704K init, 321K bss, 163428K reserved, 262144K cma-reserved)
[    0.000000] rcu: Hierarchical RCU implementation.
[    0.000000] rcu: 	RCU event tracing is enabled.
[    0.000000] rcu: 	RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] GIC: Adjusting CPU interface base to 0x00000000f902f000
[    0.000000] GIC: Using split EOI/Deactivate mode
[    0.000000] random: get_random_bytes called from start_kernel+0x2a8/0x42c with crng_init=0
[    0.000000] arch_timer: cp15 timer(s) running at 33.33MHz (phys).
[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x7b0074340, max_idle_ns: 440795202884 ns
[    0.000003] sched_clock: 56 bits at 33MHz, resolution 30ns, wraps every 2199023255543ns
[    0.008261] Console: colour dummy device 80x25
[    0.012389] Calibrating delay loop (skipped), value calculated using timer frequency.. 66.66 BogoMIPS (lpj=133332)
[    0.022667] pid_max: default: 32768 minimum: 301
[    0.027382] Mount-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.034614] Mountpoint-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.043251] ASID allocator initialised with 32768 entries
[    0.047806] rcu: Hierarchical SRCU implementation.
[    0.052694] EFI services will not be available.
[    0.057130] smp: Bringing up secondary CPUs ...
[    0.061817] Detected VIPT I-cache on CPU1
[    0.061845] CPU1: Booted secondary processor 0x0000000001 [0x410fd034]
[    0.062162] Detected VIPT I-cache on CPU2
[    0.062180] CPU2: Booted secondary processor 0x0000000002 [0x410fd034]
[    0.062478] Detected VIPT I-cache on CPU3
[    0.062495] CPU3: Booted secondary processor 0x0000000003 [0x410fd034]
[    0.062538] smp: Brought up 1 node, 4 CPUs
[    0.096970] SMP: Total of 4 processors activated.
[    0.101643] CPU features: detected: 32-bit EL0 Support
[    0.106746] CPU features: detected: CRC32 instructions
[    0.111877] CPU: All CPU(s) started at EL2
[    0.115926] alternatives: patching kernel code
[    0.121331] devtmpfs: initialized
[    0.127785] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[    0.133314] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)
[    0.145648] xor: measuring software checksum speed
[    0.184207]    8regs     :  2639.000 MB/sec
[    0.224231]    32regs    :  3027.000 MB/sec
[    0.264260]    arm64_neon:  2628.000 MB/sec
[    0.264296] xor: using function: 32regs (3027.000 MB/sec)
[    0.268167] pinctrl core: initialized pinctrl subsystem
[    0.273935] NET: Registered protocol family 16
[    0.278755] DMA: preallocated 256 KiB pool for atomic allocations
[    0.283842] audit: initializing netlink subsys (disabled)
[    0.289291] audit: type=2000 audit(0.228:1): state=initialized audit_enabled=0 res=1
[    0.289743] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    0.314340] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages
[    0.315392] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages
[    0.322059] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages
[    0.328716] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages
[    1.301684] DRBG: Continuing without Jitter RNG
[    1.378106] raid6: neonx8   gen()  1714 MB/s
[    1.446134] raid6: neonx8   xor()  1624 MB/s
[    1.514190] raid6: neonx4   gen()  1642 MB/s
[    1.582200] raid6: neonx4   xor()  1577 MB/s
[    1.650264] raid6: neonx2   gen()  1248 MB/s
[    1.718269] raid6: neonx2   xor()  1303 MB/s
[    1.786346] raid6: neonx1   gen()   807 MB/s
[    1.854357] raid6: neonx1   xor()   978 MB/s
[    1.922403] raid6: int64x8  gen()  1291 MB/s
[    1.990424] raid6: int64x8  xor()   844 MB/s
[    2.058500] raid6: int64x4  gen()  1085 MB/s
[    2.126505] raid6: int64x4  xor()   814 MB/s
[    2.194624] raid6: int64x2  gen()   753 MB/s
[    2.262615] raid6: int64x2  xor()   657 MB/s
[    2.330722] raid6: int64x1  gen()   500 MB/s
[    2.398679] raid6: int64x1  xor()   500 MB/s
[    2.398715] raid6: using algorithm neonx8 gen() 1714 MB/s
[    2.402668] raid6: .... xor() 1624 MB/s, rmw enabled
[    2.407599] raid6: using neon recovery algorithm
[    2.412480] iommu: Default domain type: Translated 
[    2.417216] SCSI subsystem initialized
[    2.420870] usbcore: registered new interface driver usbfs
[    2.426222] usbcore: registered new interface driver hub
[    2.431495] usbcore: registered new device driver usb
[    2.436530] mc: Linux media interface: v0.10
[    2.440743] videodev: Linux video capture interface: v2.00
[    2.446193] pps_core: LinuxPPS API ver. 1 registered
[    2.451109] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    2.460201] PTP clock support registered
[    2.464094] EDAC MC: Ver: 3.0.0
[    2.467535] zynqmp-ipi-mbox mailbox@ff990400: Registered ZynqMP IPI mbox with TX/RX channels.
[    2.475830] FPGA manager framework
[    2.479155] Advanced Linux Sound Architecture Driver Initialized.
[    2.485345] Bluetooth: Core ver 2.22
[    2.488664] NET: Registered protocol family 31
[    2.493063] Bluetooth: HCI device and connection manager initialized
[    2.499379] Bluetooth: HCI socket layer initialized
[    2.504222] Bluetooth: L2CAP socket layer initialized
[    2.509243] Bluetooth: SCO socket layer initialized
[    2.514482] clocksource: Switched to clocksource arch_sys_counter
[    2.520226] VFS: Disk quotas dquot_6.6.0
[    2.524075] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[    2.534577] NET: Registered protocol family 2
[    2.535484] tcp_listen_portaddr_hash hash table entries: 2048 (order: 3, 32768 bytes, linear)
[    2.543707] TCP established hash table entries: 32768 (order: 6, 262144 bytes, linear)
[    2.551719] TCP bind hash table entries: 32768 (order: 7, 524288 bytes, linear)
[    2.559151] TCP: Hash tables configured (established 32768 bind 32768)
[    2.565352] UDP hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.572015] UDP-Lite hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.579185] NET: Registered protocol family 1
[    2.583618] RPC: Registered named UNIX socket transport module.
[    2.589257] RPC: Registered udp transport module.
[    2.593924] RPC: Registered tcp transport module.
[    2.598596] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    2.605230] PCI: CLS 0 bytes, default 64
[    2.609402] hw perfevents: no interrupt-affinity property for /pmu, guessing.
[    2.616122] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    2.624368] Initialise system trusted keyrings
[    2.628164] workingset: timestamp_bits=46 max_order=20 bucket_order=0
[    2.635179] NFS: Registering the id_resolver key type
[    2.639523] Key type id_resolver registered
[    2.643661] Key type id_legacy registered
[    2.647645] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    2.654314] jffs2: version 2.2. (NAND) Â© 2001-2006 Red Hat, Inc.
[    2.672691] NET: Registered protocol family 38
[    2.672731] Key type asymmetric registered
[    2.675565] Asymmetric key parser 'x509' registered
[    2.680425] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 247)
[    2.687761] io scheduler mq-deadline registered
[    2.692257] io scheduler kyber registered
[    2.720738] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[    2.724264] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    2.731289] brd: module loaded
[    2.735338] loop: module loaded
[    2.735950] mtdoops: mtd device (mtddev=name/number) must be supplied
[    2.741018] libphy: Fixed MDIO Bus: probed
[    2.744947] tun: Universal TUN/TAP device driver, 1.6
[    2.749209] CAN device driver interface
[    2.753649] usbcore: registered new interface driver asix
[    2.758334] usbcore: registered new interface driver ax88179_178a
[    2.764373] usbcore: registered new interface driver cdc_ether
[    2.770167] usbcore: registered new interface driver net1080
[    2.775792] usbcore: registered new interface driver cdc_subset
[    2.781672] usbcore: registered new interface driver zaurus
[    2.787220] usbcore: registered new interface driver cdc_ncm
[    2.792906] uio_pdrv_genirq 80020000.debug_bridge: IRQ index 0 not found
[    2.800262] usbcore: registered new interface driver uas
[    2.804785] usbcore: registered new interface driver usb-storage
[    2.811203] rtc_zynqmp ffa60000.rtc: registered as rtc0
[    2.815948] i2c /dev entries driver
[    2.820636] usbcore: registered new interface driver uvcvideo
[    2.825083] USB Video Class driver (1.1.1)
[    2.829452] Bluetooth: HCI UART driver ver 2.3
[    2.833560] Bluetooth: HCI UART protocol H4 registered
[    2.838661] Bluetooth: HCI UART protocol BCSP registered
[    2.843949] Bluetooth: HCI UART protocol LL registered
[    2.849041] Bluetooth: HCI UART protocol ATH3K registered
[    2.854414] Bluetooth: HCI UART protocol Three-wire (H5) registered
[    2.860660] Bluetooth: HCI UART protocol Intel registered
[    2.866009] Bluetooth: HCI UART protocol QCA registered
[    2.871206] usbcore: registered new interface driver bcm203x
[    2.876827] usbcore: registered new interface driver bpa10x
[    2.882363] usbcore: registered new interface driver bfusb
[    2.887817] usbcore: registered new interface driver btusb
[    2.893275] usbcore: registered new interface driver ath3k
[    2.898832] EDAC MC0: 13 UE BankGroup Number 0 Block Number 0 on mc#0csrow#0channel#0 (csrow:0 channel:0 page:0x0 offset:0x0 grain:1)
[    2.910718] EDAC MC0: Giving out device to module 1 controller synps_ddr_controller: DEV synps_edac (INTERRUPT)
[    2.920779] EDAC DEVICE0: Giving out device to module edac controller cache_err: DEV edac (POLLED)
[    2.929719] EDAC DEVICE1: Giving out device to module zynqmp-ocm-edac controller zynqmp_ocm: DEV ff960000.memory-controller (INTERRUPT)
[    2.942000] sdhci: Secure Digital Host Controller Interface driver
[    2.947826] sdhci: Copyright(c) Pierre Ossman
[    2.952150] sdhci-pltfm: SDHCI platform and OF driver helper
[    2.958110] ledtrig-cpu: registered to indicate activity on CPUs
[    2.963780] zynqmp_firmware_probe Platform Management API v1.1
[    2.969539] zynqmp_firmware_probe Trustzone version v1.0
[    2.997368] alg: No test for xilinx-zynqmp-aes (zynqmp-aes)
[    2.997535] zynqmp_aes zynqmp_aes: AES Successfully Registered
[    2.997535] 
[    3.004791] alg: No test for xilinx-keccak-384 (zynqmp-keccak-384)
[    3.010990] alg: No test for xilinx-zynqmp-rsa (zynqmp-rsa)
[    3.016546] usbcore: registered new interface driver usbhid
[    3.021863] usbhid: USB HID core driver
[    3.027782] fpga_manager fpga0: Xilinx ZynqMP FPGA Manager registered
[    3.032331] usbcore: registered new interface driver snd-usb-audio
[    3.038905] pktgen: Packet Generator for packet performance testing. Version: 2.75
[    3.046231] Initializing XFRM netlink socket
[    3.050047] NET: Registered protocol family 10
[    3.054752] Segment Routing with IPv6
[    3.058109] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[    3.064201] NET: Registered protocol family 17
[    3.068324] NET: Registered protocol family 15
[    3.072736] bridge: filtering via arp/ip/ip6tables is no longer available by default. Update your scripts to load br_netfilter if you need this.
[    3.085617] can: controller area network core (rev 20170425 abi 9)
[    3.091775] NET: Registered protocol family 29
[    3.096166] can: raw protocol (rev 20170425)
[    3.100404] can: broadcast manager protocol (rev 20170425 t)
[    3.106027] can: netlink gateway (rev 20190810) max_hops=1
[    3.111544] Bluetooth: RFCOMM TTY layer initialized
[    3.116326] Bluetooth: RFCOMM socket layer initialized
[    3.121448] Bluetooth: RFCOMM ver 1.11
[    3.125146] Bluetooth: BNEP (Ethernet Emulation) ver 1.3
[    3.130418] Bluetooth: BNEP filters: protocol multicast
[    3.135610] Bluetooth: BNEP socket layer initialized
[    3.140539] Bluetooth: HIDP (Human Interface Emulation) ver 1.2
[    3.146422] Bluetooth: HIDP socket layer initialized
[    3.151457] 9pnet: Installing 9P2000 support
[    3.155608] Key type dns_resolver registered
[    3.160184] registered taskstats version 1
[    3.163897] Loading compiled-in X.509 certificates
[    3.169015] Btrfs loaded, crc32c=crc32c-generic
[    3.180952] ff000000.serial: ttyPS0 at MMIO 0xff000000 (irq = 41, base_baud = 6249999) is a xuartps
[    3.189968] printk: console [ttyPS0] enabled
[    3.189968] printk: console [ttyPS0] enabled
[    3.194262] printk: bootconsole [cdns0] disabled
[    3.194262] printk: bootconsole [cdns0] disabled
[    3.203475] of-fpga-region fpga-full: FPGA Region probed
[    3.213478] GPIO IRQ not connected
[    3.216871] XGpio: gpio@80010000: registered, base is 509
[    3.222851] xilinx-zynqmp-dma fd500000.dma: ZynqMP DMA driver Probe success
[    3.229940] xilinx-zynqmp-dma fd510000.dma: ZynqMP DMA driver Probe success
[    3.237027] xilinx-zynqmp-dma fd520000.dma: ZynqMP DMA driver Probe success
[    3.244116] xilinx-zynqmp-dma fd530000.dma: ZynqMP DMA driver Probe success
[    3.251198] xilinx-zynqmp-dma fd540000.dma: ZynqMP DMA driver Probe success
[    3.258286] xilinx-zynqmp-dma fd550000.dma: ZynqMP DMA driver Probe success
[    3.265377] xilinx-zynqmp-dma fd560000.dma: ZynqMP DMA driver Probe success
[    3.272461] xilinx-zynqmp-dma fd570000.dma: ZynqMP DMA driver Probe success
[    3.279623] xilinx-zynqmp-dma ffa80000.dma: ZynqMP DMA driver Probe success
[    3.286711] xilinx-zynqmp-dma ffa90000.dma: ZynqMP DMA driver Probe success
[    3.293797] xilinx-zynqmp-dma ffaa0000.dma: ZynqMP DMA driver Probe success
[    3.300888] xilinx-zynqmp-dma ffab0000.dma: ZynqMP DMA driver Probe success
[    3.307979] xilinx-zynqmp-dma ffac0000.dma: ZynqMP DMA driver Probe success
[    3.315065] xilinx-zynqmp-dma ffad0000.dma: ZynqMP DMA driver Probe success
[    3.322157] xilinx-zynqmp-dma ffae0000.dma: ZynqMP DMA driver Probe success
[    3.329244] xilinx-zynqmp-dma ffaf0000.dma: ZynqMP DMA driver Probe success
[    3.336439] zynqmp-qspi ff0f0000.spi: rx bus width not found
[    3.342091] zynqmp-qspi ff0f0000.spi: tx bus width not found
[    3.347928] spi_master spi0: cannot find modalias for /amba/spi@ff0f0000/flash@0
[    3.355320] spi_master spi0: Failed to create SPI device for /amba/spi@ff0f0000/flash@0
[    3.363602] macb ff0b0000.ethernet: Not enabling partial store and forward
[    3.370973] libphy: MACB_mii_bus: probed
[    3.394539] zynqmp_pll_disable() clock disable failed for dpll_int, ret = -13
[    3.447718] Micrel KSZ9031 Gigabit PHY ff0b0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0b0000.ethernet-ffffffff:03, irq=POLL)
[    3.463532] macb ff0b0000.ethernet eth0: Cadence GEM rev 0x50070106 at 0xff0b0000 irq 29 (ca:9f:1e:3a:b6:24)
[    3.473615] macb ff0c0000.ethernet: Not enabling partial store and forward
[    3.480884] libphy: MACB_mii_bus: probed
[    3.555659] Micrel KSZ9031 Gigabit PHY ff0c0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0c0000.ethernet-ffffffff:03, irq=POLL)
[    3.571474] macb ff0c0000.ethernet eth1: Cadence GEM rev 0x50070106 at 0xff0c0000 irq 30 (ca:9f:1e:3a:b6:25)
[    3.581541] xilinx-axipmon ffa00000.perf-monitor: Probed Xilinx APM
[    3.588049] xilinx-axipmon fd0b0000.perf-monitor: Probed Xilinx APM
[    3.594506] xilinx-axipmon fd490000.perf-monitor: Probed Xilinx APM
[    3.601043] xilinx-axipmon ffa10000.perf-monitor: Probed Xilinx APM
[    3.607518] dwc3-of-simple ff9d0000.usb0: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.615801] dwc3 fe200000.dwc3: Failed to get clk 'ref': -2
[    3.621774] dwc3-of-simple ff9e0000.usb1: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.630000] dwc3 fe300000.dwc3: Failed to get clk 'ref': -2
[    3.636638] i2c i2c-0: Added multiplexed i2c bus 1
[    3.640928] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.641532] i2c i2c-0: Added multiplexed i2c bus 2
[    3.646908] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 1
[    3.651782] i2c i2c-0: Added multiplexed i2c bus 3
[    3.659414] xhci-hcd xhci-hcd.0.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.664286] i2c i2c-0: Added multiplexed i2c bus 4
[    3.673512] xhci-hcd xhci-hcd.0.auto: irq 46, io mem 0xfe300000
[    3.678452] i2c i2c-0: Added multiplexed i2c bus 5
[    3.684603] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.689067] i2c i2c-0: Added multiplexed i2c bus 6
[    3.694545] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.699339] i2c i2c-0: Added multiplexed i2c bus 7
[    3.707486] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.707490] usb usb1: Product: xHCI Host Controller
[    3.712465] i2c i2c-0: Added multiplexed i2c bus 8
[    3.719482] usb usb1: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.724353] pca954x 0-0070: registered 8 multiplexed busses for I2C switch pca9548
[    3.729124] usb usb1: SerialNumber: xhci-hcd.0.auto
[    3.735747] cdns-i2c ff020000.i2c: 400 kHz mmio ff020000 irq 32
[    3.743532] hub 1-0:1.0: USB hub found
[    3.748498] cpufreq: cpufreq_online: CPU0: Running at unlisted freq: 1333333 KHz
[    3.754073] hub 1-0:1.0: 1 port detected
[    3.757802] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.765355] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.769131] cpufreq: cpufreq_online: CPU0: Unlisted initial frequency changed to: 1199999 KHz
[    3.777786] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 2
[    3.783258] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.791769] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed
[    3.814659] usb usb2: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.822810] usb usb2: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.831066] usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.831190] mmc0: SDHCI controller on ff160000.mmc [ff160000.mmc] using ADMA 64-bit
[    3.838276] usb usb2: Product: xHCI Host Controller
[    3.838281] usb usb2: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.857407] usb usb2: SerialNumber: xhci-hcd.0.auto
[    3.862533] hub 2-0:1.0: USB hub found
[    3.866342] hub 2-0:1.0: 1 port detected
[    3.871023] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 3
[    3.877581] mmc1: SDHCI controller on ff170000.mmc [ff170000.mmc] using ADMA 64-bit
[    3.878774] xhci-hcd xhci-hcd.1.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.895706] rtc_zynqmp ffa60000.rtc: setting system clock to 1970-01-01T00:00:08 UTC (8)
[    3.895710] of_cfs_init
[    3.895731] of_cfs_init: OK
[    3.903831] xhci-hcd xhci-hcd.1.auto: irq 43, io mem 0xfe200000
[    3.915262] usb usb3: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.923531] usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.930747] usb usb3: Product: xHCI Host Controller
[    3.935615] usb usb3: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.942222] usb usb3: SerialNumber: xhci-hcd.1.auto
[    3.947407] hub 3-0:1.0: USB hub found
[    3.951226] hub 3-0:1.0: 1 port detected
[    3.955368] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.960863] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 4
[    3.968520] xhci-hcd xhci-hcd.1.auto: Host supports USB 3.0 SuperSpeed
[    3.975226] usb usb4: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.983468] usb usb4: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.991732] usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.998945] usb usb4: Product: xHCI Host Controller
[    4.003814] usb usb4: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    4.010420] usb usb4: SerialNumber: xhci-hcd.1.auto
[    4.015564] hub 4-0:1.0: USB hub found
[    4.019425] hub 4-0:1.0: 1 port detected
[    4.053350] mmc1: new high speed SDHC card at address aaaa
[    4.059206] mmcblk1: mmc1:aaaa SL16G 14.8 GiB 
[    4.068814]  mmcblk1: p1 p2
[    4.104575] mmc0: new HS200 MMC card at address 0001
[    4.109830] mmcblk0: mmc0:0001 W52516 14.3 GiB 
[    4.114540] mmcblk0boot0: mmc0:0001 W52516 partition 1 4.00 MiB
[    4.120622] mmcblk0boot1: mmc0:0001 W52516 partition 2 4.00 MiB
[    4.126598] mmcblk0rpmb: mmc0:0001 W52516 partition 3 4.00 MiB, chardev (245:0)
[    4.134725]  mmcblk0: p1
[   16.190500] cfg80211: Loading compiled-in X.509 certificates for regulatory database
[   16.314183] cfg80211: Loaded X.509 cert 'sforshee: 00b28ddf47aef9cea7'
[   16.320709] clk: Not disabling unused clocks
[   16.324971] ALSA device list:
[   16.327930]   No soundcards found.
[   16.331588] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2
[   16.340194] cfg80211: failed to load regulatory.db
[   16.464523] random: fast init done
[   16.469989] EXT4-fs (mmcblk1p2): recovery complete
[   16.475825] EXT4-fs (mmcblk1p2): mounted filesystem with ordered data mode. Opts: (null)
[   16.483946] VFS: Mounted root (ext4 filesystem) on device 179:2.
[   16.489993] devtmpfs: mounted
[   16.493108] Freeing unused kernel memory: 704K
[   16.497580] Run /sbin/init as init process
INIT: version 2.88 booting
Starting udev
[   16.852601] udevd[168]: starting version 3.2.8
[   16.862314] random: udevd: uninitialized urandom read (16 bytes read)
[   16.872197] random: udevd: uninitialized urandom read (16 bytes read)
[   16.879253] random: udevd: uninitialized urandom read (16 bytes read)
[   16.910365] udevd[169]: starting eudev-3.2.8
[   17.253744] FAT-fs (mmcblk1p1): Volume was not properly unmounted. Some data may be corrupt. Please run fsck.
[   17.330870] dmaproxy: loading out-of-tree module taints kernel.
[   17.350412] EXT4-fs (mmcblk1p2): re-mounted. Opts: (null)
Tue Nov 30 15:44:35 UTC 2021
INIT: Entering runlevel: 5
Configuring network interfaces... [   17.633003] pps pps0: new PPS source ptp0
[   17.637042] macb ff0b0000.ethernet: gem-ptp-timer ptp clock registered.
done.
Starting haveged: haveged: listening socket at 3
haveged: haveged starting up


Starting Dropbear SSH server: dropbear.
Starting internet superserver: inetd.
Starting syslogd/klogd: done
Starting tcf-agent: [   18.392933] random: crng init done
[   18.396334] random: 6 urandom warning(s) missed due to ratelimiting
OK

PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: [   21.727034] macb ff0b0000.ethernet eth0: link up (1000/Full)
[   21.732711] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
root
Password: 
7[r[999;999H[6n8root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether ca:9f:1e:3a:b6:24 brd ff:ff:ff:ff:ff:ff
    inet 130.87.242.129/22 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::c89f:1eff:fe3a:b624/64 scope link 
       valid_lft forever preferred_lft forever
4: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether ca:9f:1e:3a:b6:25 brd ff:ff:ff:ff:ff:ff
root@plnx_MercuryXU5_EndcapSL:~# ser   xvcserver 


^C
root@plnx_MercuryXU5_EndcapSL:~# xvcserver & 
[1] 623
root@plnx_MercuryXU5_EndcapSL:~# [  799.092841] TCP: request_sock_TCP: Possible SYN flooding on port 2542. Sending cookies.  Check SNMP counters.
connection accepted - fd 3
setting TCP_NODELAY to 1
invalid cmd 'E'

root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# cat /sys/class/uio/uio
uio0/ uio1/ uio2/ uio3/ uio4/ 
root@plnx_MercuryXU5_EndcapSL:~# cat /sys/class/uio/uio0/name 
debug_bridge
root@plnx_MercuryXU5_EndcapSL:~# xvcserver -h
usage: xvcserver [-v]
root@plnx_MercuryXU5_EndcapSL:~# xvcserver -h    -v &
[2] 629
bind: Address already in use
root@plnx_MercuryXU5_EndcapSL:~# xvcserver -v &[K^C
[2]+  Done(1)                 xvcserver -v
root@plnx_MercuryXU5_EndcapSL:~# ^C
root@plnx_MercuryXU5_EndcapSL:~# xvcserver -v &
[2] 630
bind: Address already in use
root@plnx_MercuryXU5_EndcapSL:~# Xilinx Zynq MP First Stage Boot Loader 
Release 2020.1   Nov 30 2021  -  13:31:53
NOTICE:  ATF running on XCZU5EV/silicon v4/RTL5.1 at 0xfffea000
NOTICE:  BL31: v2.2(release):xilinx_rebase_v2.2_2020.1
NOTICE:  BL31: Built : 13:29:52, Nov 30 2021


U-Boot 2020.01 (Nov 30 2021 - 13:30:56 +0000)

Model: Enclustra ME-XU5-5EV-2I-D12E SOM
Board: Xilinx ZynqMP
DRAM:  4 GiB
usb dr_mode not found
usb dr_mode not found
PMUFW:	v1.1
EL Level:	EL2
Chip ID:	zu5ev
NAND:  0 MiB
MMC:   mmc@ff160000: 0, mmc@ff170000: 1
In:    serial@ff000000
Out:   serial@ff000000
Err:   serial@ff000000
Bootmode: SD_MODE1
Reset reason:	EXTERNAL 
Net:   
ZYNQ GEM: ff0b0000, mdio bus ff0b0000, phyaddr 3, interface rgmii-id

Warning: ethernet@ff0b0000 (eth0) using random MAC address - 2a:d3:b5:be:2c:4b
eth0: ethernet@ff0b0000
Hit any key to stop autoboot:  2  1  0 
switch to partitions #0, OK
mmc1 is current device
Scanning mmc 1:1...
Found U-Boot script /boot.scr
3694 bytes read in 18 ms (200.2 KiB/s)
## Executing script at 20000000
[L0MuESL] Before SD card scanning... 
[L0MuESL] SD card scanning now...
[L0MuESL] Loading uEnv.txt in SD1... 
1272 bytes read in 19 ms (64.5 KiB/s)
[L0MuESL] Loading u-boot environment by uenvcmd... 
[L0MuESL] SD card fatload now ...
8159148 bytes read in 605 ms (12.9 MiB/s)
[L0MuESL] SD card bootm command now...
## Loading kernel from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'kernel@1' kernel subimage
     Description:  Linux kernel
     Type:         Kernel Image
     Compression:  gzip compressed
     Data Start:   0x100000e8
     Data Size:    8114710 Bytes = 7.7 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00080000
     Entry Point:  0x00080000
     Hash algo:    sha256
     Hash value:   d8dbc87352877e020871a801ceda165f06fa467dc974d45677a3e9058465f51f
   Verifying Hash Integrity ... sha256+ OK
## Loading fdt from FIT Image at 10000000 ...
   Using 'conf@system-top.dtb' configuration
   Trying 'fdt@system-top.dtb' fdt subimage
     Description:  Flattened Device Tree blob
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x107bd410
     Data Size:    42547 Bytes = 41.5 KiB
     Architecture: AArch64
     Hash algo:    sha256
     Hash value:   c2cb860e94d3969dd7865705c3edff938ff4058f8cd3fe6c0a353a4664c16d1c
   Verifying Hash Integrity ... sha256+ OK
   Booting using the fdt blob at 0x107bd410
   Uncompressing Kernel Image
   Loading Device Tree to 000000000fff2000, end 000000000ffff632 ... OK

Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]
[    0.000000] Linux version 5.4.0-xilinx-v2020.1 (oe-user@oe-host) (gcc version 9.2.0 (GCC)) #1 SMP Tue Nov 30 13:29:56 UTC 2021
[    0.000000] Machine model: Enclustra ME-XU5-5EV-2I-D12E SOM
[    0.000000] earlycon: cdns0 at MMIO 0x00000000ff000000 (options '115200n8')
[    0.000000] printk: bootconsole [cdns0] enabled
[    0.000000] efi: Getting EFI parameters from FDT:
[    0.000000] efi: UEFI not found.
[    0.000000] cma: Reserved 256 MiB at 0x000000006fc00000
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.1 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
[    0.000000] psci: MIGRATE_INFO_TYPE not supported.
[    0.000000] psci: SMC Calling Convention v1.1
[    0.000000] percpu: Embedded 21 pages/cpu s49112 r8192 d28712 u86016
[    0.000000] Detected VIPT I-cache on CPU0
[    0.000000] CPU features: detected: ARM erratum 845719
[    0.000000] Speculative Store Bypass Disable mitigation not required
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 1031940
[    0.000000] Kernel command line: earlycon console=ttyPS0,115200 clk_ignore_unused root=/dev/mmcblk1p2 rootfstype=ext4 rw rootwait earlyprintk uio_pdrv_genirq.of_id=generic-uio cpuidle.off=1 ip=130.87.242.129:130.87.240.1:255.255.252.0:sl-xu5-eth0-01:eth0:off nameserver=130.87.240.2 nameserver=130.87.240.3
[    0.000000] Dentry cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)
[    0.000000] Inode-cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] software IO TLB: mapped [mem 0x6bc00000-0x6fc00000] (64MB)
[    0.000000] Memory: 3767708K/4193280K available (11644K kernel code, 670K rwdata, 3624K rodata, 704K init, 321K bss, 163428K reserved, 262144K cma-reserved)
[    0.000000] rcu: Hierarchical RCU implementation.
[    0.000000] rcu: 	RCU event tracing is enabled.
[    0.000000] rcu: 	RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] GIC: Adjusting CPU interface base to 0x00000000f902f000
[    0.000000] GIC: Using split EOI/Deactivate mode
[    0.000000] random: get_random_bytes called from start_kernel+0x2a8/0x42c with crng_init=0
[    0.000000] arch_timer: cp15 timer(s) running at 33.33MHz (phys).
[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x7b0074340, max_idle_ns: 440795202884 ns
[    0.000003] sched_clock: 56 bits at 33MHz, resolution 30ns, wraps every 2199023255543ns
[    0.008262] Console: colour dummy device 80x25
[    0.012389] Calibrating delay loop (skipped), value calculated using timer frequency.. 66.66 BogoMIPS (lpj=133332)
[    0.022667] pid_max: default: 32768 minimum: 301
[    0.027382] Mount-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.034614] Mountpoint-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    0.043251] ASID allocator initialised with 32768 entries
[    0.047804] rcu: Hierarchical SRCU implementation.
[    0.052693] EFI services will not be available.
[    0.057131] smp: Bringing up secondary CPUs ...
[    0.061815] Detected VIPT I-cache on CPU1
[    0.061844] CPU1: Booted secondary processor 0x0000000001 [0x410fd034]
[    0.062162] Detected VIPT I-cache on CPU2
[    0.062180] CPU2: Booted secondary processor 0x0000000002 [0x410fd034]
[    0.062479] Detected VIPT I-cache on CPU3
[    0.062496] CPU3: Booted secondary processor 0x0000000003 [0x410fd034]
[    0.062539] smp: Brought up 1 node, 4 CPUs
[    0.096970] SMP: Total of 4 processors activated.
[    0.101642] CPU features: detected: 32-bit EL0 Support
[    0.106746] CPU features: detected: CRC32 instructions
[    0.111877] CPU: All CPU(s) started at EL2
[    0.115926] alternatives: patching kernel code
[    0.121330] devtmpfs: initialized
[    0.127776] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[    0.133314] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)
[    0.145615] xor: measuring software checksum speed
[    0.184206]    8regs     :  2639.000 MB/sec
[    0.224230]    32regs    :  3027.000 MB/sec
[    0.264259]    arm64_neon:  2628.000 MB/sec
[    0.264295] xor: using function: 32regs (3027.000 MB/sec)
[    0.268167] pinctrl core: initialized pinctrl subsystem
[    0.273922] NET: Registered protocol family 16
[    0.278755] DMA: preallocated 256 KiB pool for atomic allocations
[    0.283842] audit: initializing netlink subsys (disabled)
[    0.289292] audit: type=2000 audit(0.228:1): state=initialized audit_enabled=0 res=1
[    0.289743] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    0.314333] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages
[    0.315383] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages
[    0.322050] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages
[    0.328707] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages
[    1.301423] DRBG: Continuing without Jitter RNG
[    1.378008] raid6: neonx8   gen()  1714 MB/s
[    1.446037] raid6: neonx8   xor()  1624 MB/s
[    1.514082] raid6: neonx4   gen()  1644 MB/s
[    1.582117] raid6: neonx4   xor()  1577 MB/s
[    1.650177] raid6: neonx2   gen()  1249 MB/s
[    1.718181] raid6: neonx2   xor()  1303 MB/s
[    1.786264] raid6: neonx1   gen()   809 MB/s
[    1.854275] raid6: neonx1   xor()   978 MB/s
[    1.922311] raid6: int64x8  gen()  1291 MB/s
[    1.990363] raid6: int64x8  xor()   844 MB/s
[    2.058411] raid6: int64x4  gen()  1085 MB/s
[    2.126426] raid6: int64x4  xor()   814 MB/s
[    2.194511] raid6: int64x2  gen()   753 MB/s
[    2.262518] raid6: int64x2  xor()   657 MB/s
[    2.330630] raid6: int64x1  gen()   500 MB/s
[    2.398607] raid6: int64x1  xor()   500 MB/s
[    2.398643] raid6: using algorithm neonx8 gen() 1714 MB/s
[    2.402599] raid6: .... xor() 1624 MB/s, rmw enabled
[    2.407529] raid6: using neon recovery algorithm
[    2.412418] iommu: Default domain type: Translated 
[    2.417146] SCSI subsystem initialized
[    2.420798] usbcore: registered new interface driver usbfs
[    2.426153] usbcore: registered new interface driver hub
[    2.431426] usbcore: registered new device driver usb
[    2.436460] mc: Linux media interface: v0.10
[    2.440674] videodev: Linux video capture interface: v2.00
[    2.446123] pps_core: LinuxPPS API ver. 1 registered
[    2.451039] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    2.460132] PTP clock support registered
[    2.464026] EDAC MC: Ver: 3.0.0
[    2.467469] zynqmp-ipi-mbox mailbox@ff990400: Registered ZynqMP IPI mbox with TX/RX channels.
[    2.475760] FPGA manager framework
[    2.479088] Advanced Linux Sound Architecture Driver Initialized.
[    2.485273] Bluetooth: Core ver 2.22
[    2.488596] NET: Registered protocol family 31
[    2.492994] Bluetooth: HCI device and connection manager initialized
[    2.499310] Bluetooth: HCI socket layer initialized
[    2.504153] Bluetooth: L2CAP socket layer initialized
[    2.509175] Bluetooth: SCO socket layer initialized
[    2.514416] clocksource: Switched to clocksource arch_sys_counter
[    2.520157] VFS: Disk quotas dquot_6.6.0
[    2.523999] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[    2.534480] NET: Registered protocol family 2
[    2.535421] tcp_listen_portaddr_hash hash table entries: 2048 (order: 3, 32768 bytes, linear)
[    2.543637] TCP established hash table entries: 32768 (order: 6, 262144 bytes, linear)
[    2.551648] TCP bind hash table entries: 32768 (order: 7, 524288 bytes, linear)
[    2.559081] TCP: Hash tables configured (established 32768 bind 32768)
[    2.565283] UDP hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.571946] UDP-Lite hash table entries: 2048 (order: 4, 65536 bytes, linear)
[    2.579117] NET: Registered protocol family 1
[    2.583545] RPC: Registered named UNIX socket transport module.
[    2.589188] RPC: Registered udp transport module.
[    2.593854] RPC: Registered tcp transport module.
[    2.598524] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    2.605164] PCI: CLS 0 bytes, default 64
[    2.609329] hw perfevents: no interrupt-affinity property for /pmu, guessing.
[    2.616051] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    2.624305] Initialise system trusted keyrings
[    2.628102] workingset: timestamp_bits=46 max_order=20 bucket_order=0
[    2.635098] NFS: Registering the id_resolver key type
[    2.639453] Key type id_resolver registered
[    2.643591] Key type id_legacy registered
[    2.647576] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    2.654245] jffs2: version 2.2. (NAND) Â© 2001-2006 Red Hat, Inc.
[    2.672199] NET: Registered protocol family 38
[    2.672239] Key type asymmetric registered
[    2.675072] Asymmetric key parser 'x509' registered
[    2.679934] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 247)
[    2.687269] io scheduler mq-deadline registered
[    2.691764] io scheduler kyber registered
[    2.719415] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[    2.722941] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    2.729968] brd: module loaded
[    2.734010] loop: module loaded
[    2.734640] mtdoops: mtd device (mtddev=name/number) must be supplied
[    2.739688] libphy: Fixed MDIO Bus: probed
[    2.743626] tun: Universal TUN/TAP device driver, 1.6
[    2.747881] CAN device driver interface
[    2.752322] usbcore: registered new interface driver asix
[    2.757018] usbcore: registered new interface driver ax88179_178a
[    2.763051] usbcore: registered new interface driver cdc_ether
[    2.768844] usbcore: registered new interface driver net1080
[    2.774469] usbcore: registered new interface driver cdc_subset
[    2.780349] usbcore: registered new interface driver zaurus
[    2.785893] usbcore: registered new interface driver cdc_ncm
[    2.791583] uio_pdrv_genirq 80020000.debug_bridge: IRQ index 0 not found
[    2.798951] usbcore: registered new interface driver uas
[    2.803463] usbcore: registered new interface driver usb-storage
[    2.809878] rtc_zynqmp ffa60000.rtc: registered as rtc0
[    2.814624] i2c /dev entries driver
[    2.819313] usbcore: registered new interface driver uvcvideo
[    2.823759] USB Video Class driver (1.1.1)
[    2.828123] Bluetooth: HCI UART driver ver 2.3
[    2.832237] Bluetooth: HCI UART protocol H4 registered
[    2.837337] Bluetooth: HCI UART protocol BCSP registered
[    2.842626] Bluetooth: HCI UART protocol LL registered
[    2.847716] Bluetooth: HCI UART protocol ATH3K registered
[    2.853090] Bluetooth: HCI UART protocol Three-wire (H5) registered
[    2.859336] Bluetooth: HCI UART protocol Intel registered
[    2.864684] Bluetooth: HCI UART protocol QCA registered
[    2.869882] usbcore: registered new interface driver bcm203x
[    2.875504] usbcore: registered new interface driver bpa10x
[    2.881038] usbcore: registered new interface driver bfusb
[    2.886490] usbcore: registered new interface driver btusb
[    2.891952] usbcore: registered new interface driver ath3k
[    2.897509] EDAC MC0: 13 UE BankGroup Number 0 Block Number 0 on mc#0csrow#0channel#0 (csrow:0 channel:0 page:0x0 offset:0x0 grain:1)
[    2.909391] EDAC MC0: Giving out device to module 1 controller synps_ddr_controller: DEV synps_edac (INTERRUPT)
[    2.919459] EDAC DEVICE0: Giving out device to module edac controller cache_err: DEV edac (POLLED)
[    2.928396] EDAC DEVICE1: Giving out device to module zynqmp-ocm-edac controller zynqmp_ocm: DEV ff960000.memory-controller (INTERRUPT)
[    2.940680] sdhci: Secure Digital Host Controller Interface driver
[    2.946503] sdhci: Copyright(c) Pierre Ossman
[    2.950825] sdhci-pltfm: SDHCI platform and OF driver helper
[    2.956758] ledtrig-cpu: registered to indicate activity on CPUs
[    2.962460] zynqmp_firmware_probe Platform Management API v1.1
[    2.968215] zynqmp_firmware_probe Trustzone version v1.0
[    2.996099] alg: No test for xilinx-zynqmp-aes (zynqmp-aes)
[    2.996272] zynqmp_aes zynqmp_aes: AES Successfully Registered
[    2.996272] 
[    3.003526] alg: No test for xilinx-keccak-384 (zynqmp-keccak-384)
[    3.009734] alg: No test for xilinx-zynqmp-rsa (zynqmp-rsa)
[    3.015292] usbcore: registered new interface driver usbhid
[    3.020600] usbhid: USB HID core driver
[    3.026518] fpga_manager fpga0: Xilinx ZynqMP FPGA Manager registered
[    3.031065] usbcore: registered new interface driver snd-usb-audio
[    3.037638] pktgen: Packet Generator for packet performance testing. Version: 2.75
[    3.044958] Initializing XFRM netlink socket
[    3.048782] NET: Registered protocol family 10
[    3.053486] Segment Routing with IPv6
[    3.056860] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[    3.062945] NET: Registered protocol family 17
[    3.067060] NET: Registered protocol family 15
[    3.071474] bridge: filtering via arp/ip/ip6tables is no longer available by default. Update your scripts to load br_netfilter if you need this.
[    3.084350] can: controller area network core (rev 20170425 abi 9)
[    3.090512] NET: Registered protocol family 29
[    3.094903] can: raw protocol (rev 20170425)
[    3.099141] can: broadcast manager protocol (rev 20170425 t)
[    3.104764] can: netlink gateway (rev 20190810) max_hops=1
[    3.110278] Bluetooth: RFCOMM TTY layer initialized
[    3.115064] Bluetooth: RFCOMM socket layer initialized
[    3.120170] Bluetooth: RFCOMM ver 1.11
[    3.123883] Bluetooth: BNEP (Ethernet Emulation) ver 1.3
[    3.129156] Bluetooth: BNEP filters: protocol multicast
[    3.134346] Bluetooth: BNEP socket layer initialized
[    3.139276] Bluetooth: HIDP (Human Interface Emulation) ver 1.2
[    3.145162] Bluetooth: HIDP socket layer initialized
[    3.150187] 9pnet: Installing 9P2000 support
[    3.154346] Key type dns_resolver registered
[    3.158914] registered taskstats version 1
[    3.162635] Loading compiled-in X.509 certificates
[    3.167755] Btrfs loaded, crc32c=crc32c-generic
[    3.179714] ff000000.serial: ttyPS0 at MMIO 0xff000000 (irq = 41, base_baud = 6249999) is a xuartps
[    3.188731] printk: console [ttyPS0] enabled
[    3.188731] printk: console [ttyPS0] enabled
[    3.193025] printk: bootconsole [cdns0] disabled
[    3.193025] printk: bootconsole [cdns0] disabled
[    3.202184] of-fpga-region fpga-full: FPGA Region probed
[    3.212238] GPIO IRQ not connected
[    3.215634] XGpio: gpio@80010000: registered, base is 509
[    3.221602] xilinx-zynqmp-dma fd500000.dma: ZynqMP DMA driver Probe success
[    3.228695] xilinx-zynqmp-dma fd510000.dma: ZynqMP DMA driver Probe success
[    3.235782] xilinx-zynqmp-dma fd520000.dma: ZynqMP DMA driver Probe success
[    3.242876] xilinx-zynqmp-dma fd530000.dma: ZynqMP DMA driver Probe success
[    3.249971] xilinx-zynqmp-dma fd540000.dma: ZynqMP DMA driver Probe success
[    3.257058] xilinx-zynqmp-dma fd550000.dma: ZynqMP DMA driver Probe success
[    3.264148] xilinx-zynqmp-dma fd560000.dma: ZynqMP DMA driver Probe success
[    3.271237] xilinx-zynqmp-dma fd570000.dma: ZynqMP DMA driver Probe success
[    3.278394] xilinx-zynqmp-dma ffa80000.dma: ZynqMP DMA driver Probe success
[    3.285486] xilinx-zynqmp-dma ffa90000.dma: ZynqMP DMA driver Probe success
[    3.292577] xilinx-zynqmp-dma ffaa0000.dma: ZynqMP DMA driver Probe success
[    3.299668] xilinx-zynqmp-dma ffab0000.dma: ZynqMP DMA driver Probe success
[    3.306751] xilinx-zynqmp-dma ffac0000.dma: ZynqMP DMA driver Probe success
[    3.313834] xilinx-zynqmp-dma ffad0000.dma: ZynqMP DMA driver Probe success
[    3.320923] xilinx-zynqmp-dma ffae0000.dma: ZynqMP DMA driver Probe success
[    3.328008] xilinx-zynqmp-dma ffaf0000.dma: ZynqMP DMA driver Probe success
[    3.335207] zynqmp-qspi ff0f0000.spi: rx bus width not found
[    3.340863] zynqmp-qspi ff0f0000.spi: tx bus width not found
[    3.346665] spi_master spi0: cannot find modalias for /amba/spi@ff0f0000/flash@0
[    3.354058] spi_master spi0: Failed to create SPI device for /amba/spi@ff0f0000/flash@0
[    3.362340] macb ff0b0000.ethernet: Not enabling partial store and forward
[    3.369686] libphy: MACB_mii_bus: probed
[    3.396296] zynqmp_pll_disable() clock disable failed for dpll_int, ret = -13
[    3.443585] Micrel KSZ9031 Gigabit PHY ff0b0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0b0000.ethernet-ffffffff:03, irq=POLL)
[    3.459404] macb ff0b0000.ethernet eth0: Cadence GEM rev 0x50070106 at 0xff0b0000 irq 29 (ca:9f:1e:3a:b6:24)
[    3.469486] macb ff0c0000.ethernet: Not enabling partial store and forward
[    3.476761] libphy: MACB_mii_bus: probed
[    3.551581] Micrel KSZ9031 Gigabit PHY ff0c0000.ethernet-ffffffff:03: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=ff0c0000.ethernet-ffffffff:03, irq=POLL)
[    3.567399] macb ff0c0000.ethernet eth1: Cadence GEM rev 0x50070106 at 0xff0c0000 irq 30 (ca:9f:1e:3a:b6:25)
[    3.577474] xilinx-axipmon ffa00000.perf-monitor: Probed Xilinx APM
[    3.583971] xilinx-axipmon fd0b0000.perf-monitor: Probed Xilinx APM
[    3.590525] xilinx-axipmon fd490000.perf-monitor: Probed Xilinx APM
[    3.596993] xilinx-axipmon ffa10000.perf-monitor: Probed Xilinx APM
[    3.603467] dwc3-of-simple ff9d0000.usb0: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.611749] dwc3 fe200000.dwc3: Failed to get clk 'ref': -2
[    3.617720] dwc3-of-simple ff9e0000.usb1: dwc3_simple_set_phydata: Can't find usb3-phy
[    3.625942] dwc3 fe300000.dwc3: Failed to get clk 'ref': -2
[    3.632561] i2c i2c-0: Added multiplexed i2c bus 1
[    3.637670] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.643157] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 1
[    3.650893] xhci-hcd xhci-hcd.0.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.660299] xhci-hcd xhci-hcd.0.auto: irq 43, io mem 0xfe200000
[    3.666370] i2c i2c-0: Added multiplexed i2c bus 2
[    3.671457] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.676989] i2c i2c-0: Added multiplexed i2c bus 3
[    3.681965] i2c i2c-0: Added multiplexed i2c bus 4
[    3.686938] i2c i2c-0: Added multiplexed i2c bus 5
[    3.691829] i2c i2c-0: Added multiplexed i2c bus 6
[    3.696708] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.704968] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.712187] usb usb1: Product: xHCI Host Controller
[    3.717055] usb usb1: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.723660] usb usb1: SerialNumber: xhci-hcd.0.auto
[    3.728757] i2c i2c-0: Added multiplexed i2c bus 7
[    3.733685] i2c i2c-0: Added multiplexed i2c bus 8
[    3.738477] pca954x 0-0070: registered 8 multiplexed busses for I2C switch pca9548
[    3.746061] cdns-i2c ff020000.i2c: 400 kHz mmio ff020000 irq 32
[    3.752335] cpufreq: cpufreq_online: CPU0: Running at unlisted freq: 1333333 KHz
[    3.759737] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.768469] cpufreq: cpufreq_online: CPU0: Unlisted initial frequency changed to: 1199999 KHz
[    3.776996] cpu cpu0: dev_pm_opp_set_rate: failed to find current OPP for freq 1333333320 (-34)
[    3.786727] hub 1-0:1.0: USB hub found
[    3.790499] hub 1-0:1.0: 1 port detected
[    3.794583] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    3.800071] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 2
[    3.807731] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed
[    3.814299] usb usb2: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.822452] usb usb2: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.830706] usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.837917] usb usb2: Product: xHCI Host Controller
[    3.842787] usb usb2: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.849391] usb usb2: SerialNumber: xhci-hcd.0.auto
[    3.854635] hub 2-0:1.0: USB hub found
[    3.858386] hub 2-0:1.0: 1 port detected
[    3.862490] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 3
[    3.870226] xhci-hcd xhci-hcd.1.auto: hcc params 0x0238f625 hci version 0x100 quirks 0x0000000202010010
[    3.879630] xhci-hcd xhci-hcd.1.auto: irq 46, io mem 0xfe300000
[    3.885770] usb usb3: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 5.04
[    3.894030] usb usb3: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.901251] usb usb3: Product: xHCI Host Controller
[    3.906135] usb usb3: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.912741] usb usb3: SerialNumber: xhci-hcd.1.auto
[    3.917697] mmc0: SDHCI controller on ff160000.mmc [ff160000.mmc] using ADMA 64-bit
[    3.926641] hub 3-0:1.0: USB hub found
[    3.930458] hub 3-0:1.0: 1 port detected
[    3.934618] xhci-hcd xhci-hcd.1.auto: xHCI Host Controller
[    3.940109] xhci-hcd xhci-hcd.1.auto: new USB bus registered, assigned bus number 4
[    3.947763] xhci-hcd xhci-hcd.1.auto: Host supports USB 3.0 SuperSpeed
[    3.954373] usb usb4: We don't know the algorithms for LPM for this host, disabling LPM.
[    3.962583] usb usb4: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 5.04
[    3.970840] usb usb4: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    3.978057] usb usb4: Product: xHCI Host Controller
[    3.982926] usb usb4: Manufacturer: Linux 5.4.0-xilinx-v2020.1 xhci-hcd
[    3.989531] usb usb4: SerialNumber: xhci-hcd.1.auto
[    3.994522] mmc1: SDHCI controller on ff170000.mmc [ff170000.mmc] using ADMA 64-bit
[    4.004470] rtc_zynqmp ffa60000.rtc: setting system clock to 2021-11-30T16:09:21 UTC (1638288561)
[    4.013336] of_cfs_init
[    4.015787] of_cfs_init: OK
[    4.018957] hub 4-0:1.0: USB hub found
[    4.022828] hub 4-0:1.0: 1 port detected
[    4.062814] mmc1: new high speed SDHC card at address aaaa
[    4.068665] mmcblk1: mmc1:aaaa SL16G 14.8 GiB 
[    4.078239]  mmcblk1: p1 p2
[    4.103117] mmc0: new HS200 MMC card at address 0001
[    4.108387] mmcblk0: mmc0:0001 W52516 14.3 GiB 
[    4.113082] mmcblk0boot0: mmc0:0001 W52516 partition 1 4.00 MiB
[    4.119160] mmcblk0boot1: mmc0:0001 W52516 partition 2 4.00 MiB
[    4.125137] mmcblk0rpmb: mmc0:0001 W52516 partition 3 4.00 MiB, chardev (245:0)
[    4.134385]  mmcblk0: p1
[   16.318431] cfg80211: Loading compiled-in X.509 certificates for regulatory database
[   16.442140] cfg80211: Loaded X.509 cert 'sforshee: 00b28ddf47aef9cea7'
[   16.448665] clk: Not disabling unused clocks
[   16.452929] ALSA device list:
[   16.455888]   No soundcards found.
[   16.459554] platform regulatory.0: Direct firmware load for regulatory.db failed with error -2
[   16.468159] cfg80211: failed to load regulatory.db
[   16.550223] EXT4-fs (mmcblk1p2): recovery complete
[   16.556049] EXT4-fs (mmcblk1p2): mounted filesystem with ordered data mode. Opts: (null)
[   16.564165] VFS: Mounted root (ext4 filesystem) on device 179:2.
[   16.573584] devtmpfs: mounted
[   16.576702] Freeing unused kernel memory: 704K
[   16.581171] Run /sbin/init as init process
[   16.618350] random: fast init done
INIT: version 2.88 booting
Starting udev
[   16.941599] udevd[167]: starting version 3.2.8
[   16.951356] random: udevd: uninitialized urandom read (16 bytes read)
[   16.958388] random: udevd: uninitialized urandom read (16 bytes read)
[   16.965439] random: udevd: uninitialized urandom read (16 bytes read)
[   16.999714] udevd[168]: starting eudev-3.2.8
[   17.366356] FAT-fs (mmcblk1p1): Volume was not properly unmounted. Some data may be corrupt. Please run fsck.
[   17.438613] dmaproxy: loading out-of-tree module taints kernel.
[   17.457980] EXT4-fs (mmcblk1p2): re-mounted. Opts: (null)
INIT: Entering runlevel: 5
Configuring network interfaces... [   17.727844] pps pps0: new PPS source ptp0
[   17.731865] macb ff0b0000.ethernet: gem-ptp-timer ptp clock registered.
done.
Starting haveged: haveged: listening socket at 3
haveged: haveged starting up


Starting Dropbear SSH server: dropbear.
Starting internet superserver: inetd.
Starting syslogd/klogd: done
Starting tcf-agent: [   18.489939] random: crng init done
[   18.493340] random: 7 urandom warning(s) missed due to ratelimiting
OK

PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: [   21.822969] macb ff0b0000.ethernet eth0: link up (1000/Full)
[   21.828645] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready

PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: 
PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: 
PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: 
PetaLinux 2020.1 plnx_MercuryXU5_EndcapSL /dev/ttyPS0

plnx_MercuryXU5_EndcapSL login: root
Password: 
7[r[999;999H[6n8root@plnx_MercuryXU5_EndcapSL:~# xvcserver -v & 
[1] 607
root@plnx_MercuryXU5_EndcapSL:~# [   70.605007] TCP: request_sock_TCP: Possible SYN flooding on port 2542. Sending cookies.  Check SNMP counters.
connection accepted - fd 3
setting TCP_NODELAY to 1
invalid cmd 'E'
connection closed - fd 3
^C
root@plnx_MercuryXU5_EndcapSL:~# ^C
root@plnx_MercuryXU5_EndcapSL:~# ^C
root@plnx_MercuryXU5_EndcapSL:~# ^C
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# 
root@plnx_MercuryXU5_EndcapSL:~# mkdir xvcserver
root@plnx_MercuryXU5_EndcapSL:~# cd xvcserver/
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# 
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# 
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# vi xvcserver.c 
[?1049h[H[J[1;1H/* This work, "xvcServer.c", is a derivative of "xvcd.c"[2;2H* (https://github.com/tmbinc/xvcd) by tmbinc, used under CC0 1.0 Universal[3;2H* (http://creativecommons.org/publicdomain/zero/1.0/). "xvcServer.c" is[4;2H* licensed under CC0 1.0 Universal[5;2H* (http://creativecommons.org/publicdomain/zero/1.0/) by Avnet and is used by[6;2H* Xilinx for XAPP1251.[7;2H*[8;2H*  Description : XAPP1251 Xilinx Virtual Cable Server for Linux[9;2H*/[11;1H#include <fcntl.h>[12;1H#include <netinet/in.h>[13;1H#include <netinet/tcp.h>[14;1H#include <pthread.h>[15;1H#include <stdint.h>[16;1H#include <stdio.h>[17;1H#include <stdlib.h>[18;1H#include <string.h>[19;1H#include <sys/mman.h>[20;1H#include <sys/socket.h>[21;1H#include <sys/types.h>[22;1H#include <time.h>[23;1H#include <unistd.h>[25;1H#define MAP_SIZE 0x10000[1;1H[26;1H[K- xvcserver.c 1/304 0%[1;1H[2;1H[26;1H[K- xvcserver.c 2/304 0%[2;1H[3;1H[26;1H[K- xvcserver.c 3/304 0%[3;1H[4;1H[26;1H[K- xvcserver.c 4/304 1%[4;1H[5;1H[26;1H[K- xvcserver.c 5/304 1%[5;1H[6;1H[26;1H[K- xvcserver.c 6/304 1%[6;1H[7;1H[26;1H[K- xvcserver.c 7/304 2%[7;1H[8;1H[26;1H[K- xvcserver.c 8/304 2%[8;1H[9;1H[26;1H[K- xvcserver.c 9/304 2%[9;1H[10;1H[26;1H[K- xvcserver.c 10/304 3%[10;1H[11;1H[26;1H[K- xvcserver.c 11/304 3%[11;1H[12;1H[26;1H[K- xvcserver.c 12/304 3%[12;1H[13;1H[26;1H[K- xvcserver.c 13/304 4%[13;1H[14;1H[26;1H[K- xvcserver.c 14/304 4%[14;1H[15;1H[26;1H[K- xvcserver.c 15/304 4%[15;1H[16;1H[26;1H[K- xvcserver.c 16/304 5%[16;1H[17;1H[26;1H[K- xvcserver.c 17/304 5%[17;1H[18;1H[26;1H[K- xvcserver.c 18/304 5%[18;1H[19;1H[26;1H[K- xvcserver.c 19/304 6%[19;1H[20;1H[26;1H[K- xvcserver.c 20/304 6%[20;1H[21;1H[26;1H[K- xvcserver.c 21/304 6%[21;1H[22;1H[26;1H[K- xvcserver.c 22/304 7%[22;1H[23;1H[26;1H[K- xvcserver.c 23/304 7%[23;1H[24;1H[26;1H[K- xvcserver.c 24/304 7%[24;1H[25;1H[26;1H[K- xvcserver.c 25/304 8%[25;1H[1;1H * (https://github.com/tmbinc/xvcd) by tmbinc, used under CC0 1.0 Universal[2;9H://creativecommons.org/publicdomain/zero/1.0/). "xvcServer.c" is   [3;4Hlicensed under CC0 1.0 Universal                                     [4;4H(http://creativecommons.org/publicdomain/zero/1.0/) by Avnet and is used by[5;4HXilinx for XAPP1251.                                                       [6;4H                    [7;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[8;3H/                                                             [9;2H  [10;1H#include <fcntl.h>[11;11Hnetinet/in.h>[12;19Htcp.h>[13;11Hpthread.h>    [14;11Hstdint.h> [15;15Ho.h> [16;14Hlib.h>[17;13Hring[18;12Hys/mman.h>[19;15Hsocket.h>[20;15Htypes.h> [21;11Htime.h>     [22;11Hunistd.h>[23;1H                   [24;1H#define MAP_SIZE 0x10000[25;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[25;1H[26;1H[K- xvcserver.c 26/304 8%[25;1H[1;9H://creativecommons.org/publicdomain/zero/1.0/). "xvcServer.c" is   [2;4Hlicensed under CC0 1.0 Universal                                     [3;4H(http://creativecommons.org/publicdomain/zero/1.0/) by Avnet and is used by[4;4HXilinx for XAPP1251.                                                       [5;4H                    [6;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[7;3H/                                                             [8;2H  [9;1H#include <fcntl.h>[10;11Hnetinet/in.h>[11;19Htcp.h>[12;11Hpthread.h>    [13;11Hstdint.h> [14;15Ho.h> [15;14Hlib.h>[16;13Hring[17;12Hys/mman.h>[18;15Hsocket.h>[19;15Htypes.h> [20;11Htime.h>     [21;11Hunistd.h>[22;1H                   [23;1H#define MAP_SIZE 0x10000[24;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[25;1H                                                             [25;1H[26;1H[K- xvcserver.c 27/304 8%[25;1H[1;4Hlicensed under CC0 1.0 Universal                                     [2;4H(http://creativecommons.org/publicdomain/zero/1.0/) by Avnet and is used by[3;4HXilinx for XAPP1251.                                                       [4;4H                    [5;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[6;3H/                                                             [7;2H  [8;1H#include <fcntl.h>[9;11Hnetinet/in.h>[10;19Htcp.h>[11;11Hpthread.h>    [12;11Hstdint.h> [13;15Ho.h> [14;14Hlib.h>[15;13Hring[16;12Hys/mman.h>[17;15Hsocket.h>[18;15Htypes.h> [19;11Htime.h>     [20;11Hunistd.h>[21;1H                   [22;1H#define MAP_SIZE 0x10000[23;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[24;1H                                                             [25;1Htypedef struct {[25;1H[26;1H[K- xvcserver.c 28/304 9%[25;1H[1;4H(http://creativecommons.org/publicdomain/zero/1.0/) by Avnet and is used by[2;4HXilinx for XAPP1251.                                                       [3;4H                    [4;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[5;3H/                                                             [6;2H  [7;1H#include <fcntl.h>[8;11Hnetinet/in.h>[9;19Htcp.h>[10;11Hpthread.h>    [11;11Hstdint.h> [12;15Ho.h> [13;14Hlib.h>[14;13Hring[15;12Hys/mman.h>[16;15Hsocket.h>[17;15Htypes.h> [18;11Htime.h>     [19;11Hunistd.h>[20;1H                   [21;1H#define MAP_SIZE 0x10000[22;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[23;1H                                                             [24;1Htypedef struct {[25;1H    uint32_t length_offset;[25;1H[26;1H[K- xvcserver.c 29/304 9%[25;1H[1;4HXilinx for XAPP1251.                                                       [2;4H                    [3;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[4;3H/                                                             [5;2H  [6;1H#include <fcntl.h>[7;11Hnetinet/in.h>[8;19Htcp.h>[9;11Hpthread.h>    [10;11Hstdint.h> [11;15Ho.h> [12;14Hlib.h>[13;13Hring[14;12Hys/mman.h>[15;15Hsocket.h>[16;15Htypes.h> [17;11Htime.h>     [18;11Hunistd.h>[19;1H                   [20;1H#define MAP_SIZE 0x10000[21;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[22;1H                                                             [23;1Htypedef struct {[24;1H    uint32_t length_offset;[25;14Htms_offset;   [25;1H[26;1H[K- xvcserver.c 30/304 9%[25;1H[1;4H                    [2;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[3;3H/                                                             [4;2H  [5;1H#include <fcntl.h>[6;11Hnetinet/in.h>[7;19Htcp.h>[8;11Hpthread.h>    [9;11Hstdint.h> [10;15Ho.h> [11;14Hlib.h>[12;13Hring[13;12Hys/mman.h>[14;15Hsocket.h>[15;15Htypes.h> [16;11Htime.h>     [17;11Hunistd.h>[18;1H                   [19;1H#define MAP_SIZE 0x10000[20;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[21;1H                                                             [22;1Htypedef struct {[23;1H    uint32_t length_offset;[24;14Htms_offset;   [25;15Hdi[25;1H[26;1H[K- xvcserver.c 31/304 10%[25;1H[1;5HDescription : XAPP1251 Xilinx Virtual Cable Server for Linux[2;3H/                                                             [3;2H  [4;1H#include <fcntl.h>[5;11Hnetinet/in.h>[6;19Htcp.h>[7;11Hpthread.h>    [8;11Hstdint.h> [9;15Ho.h> [10;14Hlib.h>[11;13Hring[12;12Hys/mman.h>[13;15Hsocket.h>[14;15Htypes.h> [15;11Htime.h>     [16;11Hunistd.h>[17;1H                   [18;1H#define MAP_SIZE 0x10000[19;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[20;1H                                                             [21;1Htypedef struct {[22;1H    uint32_t length_offset;[23;14Htms_offset;   [24;15Hdi[25;16Ho[25;1H[26;1H[K- xvcserver.c 32/304 10%[25;1H[1;3H/                                                             [2;2H  [3;1H#include <fcntl.h>[4;11Hnetinet/in.h>[5;19Htcp.h>[6;11Hpthread.h>    [7;11Hstdint.h> [8;15Ho.h> [9;14Hlib.h>[10;13Hring[11;12Hys/mman.h>[12;15Hsocket.h>[13;15Htypes.h> [14;11Htime.h>     [15;11Hunistd.h>[16;1H                   [17;1H#define MAP_SIZE 0x10000[18;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[19;1H                                                             [20;1Htypedef struct {[21;1H    uint32_t length_offset;[22;14Htms_offset;   [23;15Hdi[24;16Ho[25;14Hctrl_offset;[25;1H[26;1H[K- xvcserver.c 33/304 10%[25;1H[1;2H  [2;1H#include <fcntl.h>[3;11Hnetinet/in.h>[4;19Htcp.h>[5;11Hpthread.h>    [6;11Hstdint.h> [7;15Ho.h> [8;14Hlib.h>[9;13Hring[10;12Hys/mman.h>[11;15Hsocket.h>[12;15Htypes.h> [13;11Htime.h>     [14;11Hunistd.h>[15;1H                   [16;1H#define MAP_SIZE 0x10000[17;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[18;1H                                                             [19;1Htypedef struct {[20;1H    uint32_t length_offset;[21;14Htms_offset;   [22;15Hdi[23;16Ho[24;14Hctrl_offset;[25;1H} jtag_t;                [25;1H[26;1H[K- xvcserver.c 34/304 11%[25;1H[26;1H[K- xvcserver.c 35/304 11%[25;1H[26;1H[K- xvcserver.c 36/304 11%[25;1H[26;1H[K- xvcserver.c 37/304 12%[25;1H[26;1H[K- xvcserver.c 38/304 12%[25;1H[26;1H[K- xvcserver.c 39/304 12%[25;1H[26;1H[K- xvcserver.c 40/304 13%[25;1H[26;1H[K- xvcserver.c 41/304 13%[25;1H[26;1H[K- xvcserver.c 42/304 13%[25;1H[26;1H[K- xvcserver.c 43/304 14%[25;1H[26;1H[K- xvcserver.c 44/304 14%[25;1H[1;1H#include <sys/types.h>[2;11Htime.h> [3;11Hunistd.h>    [4;1H                        [5;2Hdefine MAP_SIZE 0x10000[6;2Hdefine dsb(scope) asm volatile("dsb " #scope : : : "memory")[7;1H                  [8;1Htypedef struct {   [9;1H    uint32_t length_offset;[10;1H    uint32_t tms_offset;[11;1H    uint32_t tdi_offset;[12;1H    uint32_t tdo_offset;[13;1H    uint32_t ctrl_offset;[14;1H} jtag_t;          [16;1Hstatic int verbose = 0; [17;1H                                                             [18;1Hstatic int sread(int fd, void *target, int len) {[19;1H    unsigned char *t = target;[20;5Hwhile (len) {          [21;5H    int r = read(fd, t, len);[22;5H    if (r <= 0) return r;[23;5H    t += r;         [24;5H    len -= r;        [25;1H    }    [25;1H[26;1H[K- xvcserver.c 45/304 14%[25;1H[1;11Htime.h>     [2;11Hunistd.h>[3;1H                   [4;1H#define MAP_SIZE 0x10000[5;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[6;1H                                                             [7;1Htypedef struct {[8;1H    uint32_t length_offset;[9;14Htms_offset;   [10;15Hdi[11;16Ho[12;14Hctrl_offset;[13;1H} jtag_t;                [14;1H         [15;1Hstatic int verbose = 0;[16;1H                       [17;1Hstatic int sread(int fd, void *target, int len) {[18;1H    unsigned char *t = target;                   [19;5Hwhile (len) {             [20;5H    int r = read(fd, t, len);[21;10Hf (r <= 0) return r;    [22;9Ht += r;              [23;9Hlen -= r;[24;5H}            [25;5Hreturn 1;[25;1H[26;1H[K- xvcserver.c 46/304 15%[25;1H[1;11Hunistd.h>[2;1H                   [3;1H#define MAP_SIZE 0x10000[4;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[5;1H                                                             [6;1Htypedef struct {[7;1H    uint32_t length_offset;[8;14Htms_offset;   [9;15Hdi[10;16Ho[11;14Hctrl_offset;[12;1H} jtag_t;                [13;1H         [14;1Hstatic int verbose = 0;[15;1H                       [16;1Hstatic int sread(int fd, void *target, int len) {[17;1H    unsigned char *t = target;                   [18;5Hwhile (len) {             [19;5H    int r = read(fd, t, len);[20;10Hf (r <= 0) return r;    [21;9Ht += r;              [22;9Hlen -= r;[23;5H}            [24;5Hreturn 1;[25;1H}            [25;1H[26;1H[K- xvcserver.c 47/304 15%[25;1H[24;1H[26;1H[K- xvcserver.c 46/304 15%[24;1H[23;1H[26;1H[K- xvcserver.c 45/304 14%[23;1H[22;1H[26;1H[K- xvcserver.c 44/304 14%[22;1H[23;1H[26;1H[K- xvcserver.c 45/304 14%[23;1H[24;1H[26;1H[K- xvcserver.c 46/304 15%[24;1H[25;1H[26;1H[K- xvcserver.c 47/304 15%[25;1H[1;1H                   [2;1H#define MAP_SIZE 0x10000[3;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[4;1H                                                             [5;1Htypedef struct {[6;1H    uint32_t length_offset;[7;14Htms_offset;   [8;15Hdi[9;16Ho[10;14Hctrl_offset;[11;1H} jtag_t;                [12;1H         [13;1Hstatic int verbose = 0;[14;1H                       [15;1Hstatic int sread(int fd, void *target, int len) {[16;1H    unsigned char *t = target;                   [17;5Hwhile (len) {             [18;5H    int r = read(fd, t, len);[19;10Hf (r <= 0) return r;    [20;9Ht += r;              [21;9Hlen -= r;[22;5H}            [23;5Hreturn 1;[24;1H}            [25;1H [25;1H[26;1H[K- xvcserver.c 48/304 15%[25;1H[1;1H#define MAP_SIZE 0x10000[2;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[3;1H                                                             [4;1Htypedef struct {[5;1H    uint32_t length_offset;[6;14Htms_offset;   [7;15Hdi[8;16Ho[9;14Hctrl_offset;[10;1H} jtag_t;                [11;1H         [12;1Hstatic int verbose = 0;[13;1H                       [14;1Hstatic int sread(int fd, void *target, int len) {[15;1H    unsigned char *t = target;                   [16;5Hwhile (len) {             [17;5H    int r = read(fd, t, len);[18;10Hf (r <= 0) return r;    [19;9Ht += r;              [20;9Hlen -= r;[21;5H}            [22;5Hreturn 1;[23;1H}            [24;1H [25;1Hint handle_data(int fd, volatile jtag_t *ptr) {[25;1H[26;1H[K- xvcserver.c 49/304 16%[25;1H[1;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[2;1H                                                             [3;1Htypedef struct {[4;1H    uint32_t length_offset;[5;14Htms_offset;   [6;15Hdi[7;16Ho[8;14Hctrl_offset;[9;1H} jtag_t;                [10;1H         [11;1Hstatic int verbose = 0;[12;1H                       [13;1Hstatic int sread(int fd, void *target, int len) {[14;1H    unsigned char *t = target;                   [15;5Hwhile (len) {             [16;5H    int r = read(fd, t, len);[17;10Hf (r <= 0) return r;    [18;9Ht += r;              [19;9Hlen -= r;[20;5H}            [21;5Hreturn 1;[22;1H}            [23;1H [24;1Hint handle_data(int fd, volatile jtag_t *ptr) {[25;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[25;1H[26;1H[K- xvcserver.c 50/304 16%[25;1H[1;1H                                                             [2;1Htypedef struct {[3;1H    uint32_t length_offset;[4;14Htms_offset;   [5;15Hdi[6;16Ho[7;14Hctrl_offset;[8;1H} jtag_t;                [9;1H         [10;1Hstatic int verbose = 0;[11;1H                       [12;1Hstatic int sread(int fd, void *target, int len) {[13;1H    unsigned char *t = target;                   [14;5Hwhile (len) {             [15;5H    int r = read(fd, t, len);[16;10Hf (r <= 0) return r;    [17;9Ht += r;              [18;9Hlen -= r;[19;5H}            [20;5Hreturn 1;[21;1H}            [22;1H [23;1Hint handle_data(int fd, volatile jtag_t *ptr) {[24;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[25;5H                                               [25;1H[26;1H[K- xvcserver.c 51/304 16%[25;1H[1;1Htypedef struct {[2;1H    uint32_t length_offset;[3;14Htms_offset;   [4;15Hdi[5;16Ho[6;14Hctrl_offset;[7;1H} jtag_t;                [8;1H         [9;1Hstatic int verbose = 0;[10;1H                       [11;1Hstatic int sread(int fd, void *target, int len) {[12;1H    unsigned char *t = target;                   [13;5Hwhile (len) {             [14;5H    int r = read(fd, t, len);[15;10Hf (r <= 0) return r;    [16;9Ht += r;              [17;9Hlen -= r;[18;5H}            [19;5Hreturn 1;[20;1H}            [21;1H [22;1Hint handle_data(int fd, volatile jtag_t *ptr) {[23;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[24;5H                                               [25;5Hdo {[25;1H[26;1H[K- xvcserver.c 52/304 17%[25;1H[1;1H    uint32_t length_offset;[2;14Htms_offset;   [3;15Hdi[4;16Ho[5;14Hctrl_offset;[6;1H} jtag_t;                [7;1H         [8;1Hstatic int verbose = 0;[9;1H                       [10;1Hstatic int sread(int fd, void *target, int len) {[11;1H    unsigned char *t = target;                   [12;5Hwhile (len) {             [13;5H    int r = read(fd, t, len);[14;10Hf (r <= 0) return r;    [15;9Ht += r;              [16;9Hlen -= r;[17;5H}            [18;5Hreturn 1;[19;1H}            [20;1H [21;1Hint handle_data(int fd, volatile jtag_t *ptr) {[22;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[23;5H                                               [24;5Hdo {[25;5H    char          cmd[16];[25;1H[26;1H[K- xvcserver.c 53/304 17%[25;1H[1;14Htms_offset;   [2;15Hdi[3;16Ho[4;14Hctrl_offset;[5;1H} jtag_t;                [6;1H         [7;1Hstatic int verbose = 0;[8;1H                       [9;1Hstatic int sread(int fd, void *target, int len) {[10;1H    unsigned char *t = target;                   [11;5Hwhile (len) {             [12;5H    int r = read(fd, t, len);[13;10Hf (r <= 0) return r;    [14;9Ht += r;              [15;9Hlen -= r;[16;5H}            [17;5Hreturn 1;[18;1H}            [19;1H [20;1Hint handle_data(int fd, volatile jtag_t *ptr) {[21;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[22;5H                                               [23;5Hdo {[24;5H    char          cmd[16];[25;9Hunsigned char buffer[8192], result[1024];[25;1H[26;1H[K- xvcserver.c 54/304 17%[25;1H[1;15Hdi[2;16Ho[3;14Hctrl_offset;[4;1H} jtag_t;                [5;1H         [6;1Hstatic int verbose = 0;[7;1H                       [8;1Hstatic int sread(int fd, void *target, int len) {[9;1H    unsigned char *t = target;                   [10;5Hwhile (len) {             [11;5H    int r = read(fd, t, len);[12;10Hf (r <= 0) return r;    [13;9Ht += r;              [14;9Hlen -= r;[15;5H}            [16;5Hreturn 1;[17;1H}            [18;1H [19;1Hint handle_data(int fd, volatile jtag_t *ptr) {[20;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[21;5H                                               [22;5Hdo {[23;5H    char          cmd[16];[24;9Hunsigned char buffer[8192], result[1024];[25;9Hmemset(cmd, 0, 16);                      [25;1H[26;1H[K- xvcserver.c 55/304 18%[25;1H[1;16Ho[2;14Hctrl_offset;[3;1H} jtag_t;                [4;1H         [5;1Hstatic int verbose = 0;[6;1H                       [7;1Hstatic int sread(int fd, void *target, int len) {[8;1H    unsigned char *t = target;                   [9;5Hwhile (len) {             [10;5H    int r = read(fd, t, len);[11;10Hf (r <= 0) return r;    [12;9Ht += r;              [13;9Hlen -= r;[14;5H}            [15;5Hreturn 1;[16;1H}            [17;1H [18;1Hint handle_data(int fd, volatile jtag_t *ptr) {[19;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[20;5H                                               [21;5Hdo {[22;5H    char          cmd[16];[23;9Hunsigned char buffer[8192], result[1024];[24;9Hmemset(cmd, 0, 16);                      [25;9H                   [25;1H[26;1H[K- xvcserver.c 56/304 18%[25;1H[1;14Hctrl_offset;[2;1H} jtag_t;                [3;1H         [4;1Hstatic int verbose = 0;[5;1H                       [6;1Hstatic int sread(int fd, void *target, int len) {[7;1H    unsigned char *t = target;                   [8;5Hwhile (len) {             [9;5H    int r = read(fd, t, len);[10;10Hf (r <= 0) return r;    [11;9Ht += r;              [12;9Hlen -= r;[13;5H}            [14;5Hreturn 1;[15;1H}            [16;1H [17;1Hint handle_data(int fd, volatile jtag_t *ptr) {[18;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[19;5H                                               [20;5Hdo {[21;5H    char          cmd[16];[22;9Hunsigned char buffer[8192], result[1024];[23;9Hmemset(cmd, 0, 16);                      [24;9H                   [25;9Hif (sread(fd, cmd, 2) != 1) return 1;[25;1H[26;1H[K- xvcserver.c 57/304 18%[25;1H[1;1H} jtag_t;                [2;1H         [3;1Hstatic int verbose = 0;[4;1H                       [5;1Hstatic int sread(int fd, void *target, int len) {[6;1H    unsigned char *t = target;                   [7;5Hwhile (len) {             [8;5H    int r = read(fd, t, len);[9;10Hf (r <= 0) return r;    [10;9Ht += r;              [11;9Hlen -= r;[12;5H}            [13;5Hreturn 1;[14;1H}            [15;1H [16;1Hint handle_data(int fd, volatile jtag_t *ptr) {[17;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[18;5H                                               [19;5Hdo {[20;5H    char          cmd[16];[21;9Hunsigned char buffer[8192], result[1024];[22;9Hmemset(cmd, 0, 16);                      [23;9H                   [24;9Hif (sread(fd, cmd, 2) != 1) return 1;[25;9H                                     [25;1H[26;1H[K- xvcserver.c 58/304 19%[25;1H[1;1H         [2;1Hstatic int verbose = 0;[3;1H                       [4;1Hstatic int sread(int fd, void *target, int len) {[5;1H    unsigned char *t = target;                   [6;5Hwhile (len) {             [7;5H    int r = read(fd, t, len);[8;10Hf (r <= 0) return r;    [9;9Ht += r;              [10;9Hlen -= r;[11;5H}            [12;5Hreturn 1;[13;1H}            [14;1H [15;1Hint handle_data(int fd, volatile jtag_t *ptr) {[16;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[17;5H                                               [18;5Hdo {[19;5H    char          cmd[16];[20;9Hunsigned char buffer[8192], result[1024];[21;9Hmemset(cmd, 0, 16);                      [22;9H                   [23;9Hif (sread(fd, cmd, 2) != 1) return 1;[24;9H                                     [25;9Hif (memcmp(cmd, "ge", 2) == 0) {[25;1H[26;1H[K- xvcserver.c 59/304 19%[25;1H[1;1Hstatic int verbose = 0;[2;1H                       [3;1Hstatic int sread(int fd, void *target, int len) {[4;1H    unsigned char *t = target;                   [5;5Hwhile (len) {             [6;5H    int r = read(fd, t, len);[7;10Hf (r <= 0) return r;    [8;9Ht += r;              [9;9Hlen -= r;[10;5H}            [11;5Hreturn 1;[12;1H}            [13;1H [14;1Hint handle_data(int fd, volatile jtag_t *ptr) {[15;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[16;5H                                               [17;5Hdo {[18;5H    char          cmd[16];[19;9Hunsigned char buffer[8192], result[1024];[20;9Hmemset(cmd, 0, 16);                      [21;9H                   [22;9Hif (sread(fd, cmd, 2) != 1) return 1;[23;9H                                     [24;9Hif (memcmp(cmd, "ge", 2) == 0) {[25;9H    if (sread(fd, cmd, 6) != 1) return 1;[25;1H[26;1H[K- xvcserver.c 60/304 19%[25;1H[1;1H                       [2;1Hstatic int sread(int fd, void *target, int len) {[3;1H    unsigned char *t = target;                   [4;5Hwhile (len) {             [5;5H    int r = read(fd, t, len);[6;10Hf (r <= 0) return r;    [7;9Ht += r;              [8;9Hlen -= r;[9;5H}            [10;5Hreturn 1;[11;1H}            [12;1H [13;1Hint handle_data(int fd, volatile jtag_t *ptr) {[14;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[15;5H                                               [16;5Hdo {[17;5H    char          cmd[16];[18;9Hunsigned char buffer[8192], result[1024];[19;9Hmemset(cmd, 0, 16);                      [20;9H                   [21;9Hif (sread(fd, cmd, 2) != 1) return 1;[22;9H                                     [23;9Hif (memcmp(cmd, "ge", 2) == 0) {[24;9H    if (sread(fd, cmd, 6) != 1) return 1;[25;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[25;1H[26;1H[K- xvcserver.c 61/304 20%[25;1H[1;1Hstatic int sread(int fd, void *target, int len) {[2;1H    unsigned char *t = target;                   [3;5Hwhile (len) {             [4;5H    int r = read(fd, t, len);[5;10Hf (r <= 0) return r;    [6;9Ht += r;              [7;9Hlen -= r;[8;5H}            [9;5Hreturn 1;[10;1H}            [11;1H [12;1Hint handle_data(int fd, volatile jtag_t *ptr) {[13;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[14;5H                                               [15;5Hdo {[16;5H    char          cmd[16];[17;9Hunsigned char buffer[8192], result[1024];[18;9Hmemset(cmd, 0, 16);                      [19;9H                   [20;9Hif (sread(fd, cmd, 2) != 1) return 1;[21;9H                                     [22;9Hif (memcmp(cmd, "ge", 2) == 0) {[23;9H    if (sread(fd, cmd, 6) != 1) return 1;[24;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[25;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[25;1H[26;1H[K- xvcserver.c 62/304 20%[25;1H[1;1H    unsigned char *t = target;                   [2;5Hwhile (len) {             [3;5H    int r = read(fd, t, len);[4;10Hf (r <= 0) return r;    [5;9Ht += r;              [6;9Hlen -= r;[7;5H}            [8;5Hreturn 1;[9;1H}            [10;1H [11;1Hint handle_data(int fd, volatile jtag_t *ptr) {[12;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[13;5H                                               [14;5Hdo {[15;5H    char          cmd[16];[16;9Hunsigned char buffer[8192], result[1024];[17;9Hmemset(cmd, 0, 16);                      [18;9H                   [19;9Hif (sread(fd, cmd, 2) != 1) return 1;[20;9H                                     [21;9Hif (memcmp(cmd, "ge", 2) == 0) {[22;9H    if (sread(fd, cmd, 6) != 1) return 1;[23;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[24;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[25;13H    perror("write");                                        [25;1H[26;1H[K- xvcserver.c 63/304 20%[25;1H[26;1H[K- xvcserver.c 64/304 21%[25;1H[26;1H[K- xvcserver.c 65/304 21%[25;1H[26;1H[K- xvcserver.c 66/304 21%[25;1H[26;1H[K- xvcserver.c 67/304 22%[25;1H[26;1H[K- xvcserver.c 68/304 22%[25;1H[26;1H[K- xvcserver.c 69/304 22%[25;1H[26;1H[K- xvcserver.c 70/304 23%[25;1H[26;1H[K- xvcserver.c 71/304 23%[25;1H[26;1H[K- xvcserver.c 72/304 23%[25;1H[1;1Hint handle_data(int fd, volatile jtag_t *ptr) {[2;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[3;9H                         [4;5Hdo {                     [5;9Hchar          cmd[16];[6;9Hunsigned char buffer[8192], result[1024];[7;5H    memset(cmd, 0, 16);[8;5H         [9;1H        if (sread(fd, cmd, 2) != 1) return 1;[11;1H        if (memcmp(cmd, "ge", 2) == 0) {       [12;5H        if (sread(fd, cmd, 6) != 1) return 1;  [13;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[14;5H        if (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[15;9H        perror("write");[16;9H        return 1;                        [17;9H    }              [18;13Hif (verbose) {[19;9H        printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[20;17Hprintf("\t Replied with %s\n", xvcInfo);[21;9H    }                           [22;13Hbreak;                               [23;9H} else if (memcmp(cmd, "se", 2) == 0) {      [24;17Hsread(fd, cmd, 9) != 1) return 1;                       [25;13Hmemcpy(result, cmd + 5, 4);[25;1H[26;1H[K- xvcserver.c 73/304 24%[25;1H[1;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[2;5H                                               [3;5Hdo {[4;5H    char          cmd[16];[5;9Hunsigned char buffer[8192], result[1024];[6;9Hmemset(cmd, 0, 16);                      [7;9H                   [8;9Hif (sread(fd, cmd, 2) != 1) return 1;[9;9H                                     [10;9Hif (memcmp(cmd, "ge", 2) == 0) {[11;9H    if (sread(fd, cmd, 6) != 1) return 1;[12;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[13;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[14;13H    perror("write");                                        [15;17Hreturn 1;       [16;13H}            [17;13Hif (verbose) {[18;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[19;25H\t Replied with %s\n", xvcInfo);                      [20;13H}                                           [21;13Hbreak;[22;9H} else if (memcmp(cmd, "se", 2) == 0) {[23;9H    if (sread(fd, cmd, 9) != 1) return 1;[24;13Hmemcpy(result, cmd + 5, 4);          [25;13Hif (write(fd, result, 4) != 4) {[25;1H[26;1H[K- xvcserver.c 74/304 24%[25;1H[1;5H                                               [2;5Hdo {[3;5H    char          cmd[16];[4;9Hunsigned char buffer[8192], result[1024];[5;9Hmemset(cmd, 0, 16);                      [6;9H                   [7;9Hif (sread(fd, cmd, 2) != 1) return 1;[8;9H                                     [9;9Hif (memcmp(cmd, "ge", 2) == 0) {[10;9H    if (sread(fd, cmd, 6) != 1) return 1;[11;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[12;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[13;13H    perror("write");                                        [14;17Hreturn 1;       [15;13H}            [16;13Hif (verbose) {[17;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[18;25H\t Replied with %s\n", xvcInfo);                      [19;13H}                                           [20;13Hbreak;[21;9H} else if (memcmp(cmd, "se", 2) == 0) {[22;9H    if (sread(fd, cmd, 9) != 1) return 1;[23;13Hmemcpy(result, cmd + 5, 4);          [24;13Hif (write(fd, result, 4) != 4) {[25;13H    perror("write");            [25;1H[26;1H[K- xvcserver.c 75/304 24%[25;1H[1;5Hdo {[2;5H    char          cmd[16];[3;9Hunsigned char buffer[8192], result[1024];[4;9Hmemset(cmd, 0, 16);                      [5;9H                   [6;9Hif (sread(fd, cmd, 2) != 1) return 1;[7;9H                                     [8;9Hif (memcmp(cmd, "ge", 2) == 0) {[9;9H    if (sread(fd, cmd, 6) != 1) return 1;[10;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[11;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[12;13H    perror("write");                                        [13;17Hreturn 1;       [14;13H}            [15;13Hif (verbose) {[16;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[17;25H\t Replied with %s\n", xvcInfo);                      [18;13H}                                           [19;13Hbreak;[20;9H} else if (memcmp(cmd, "se", 2) == 0) {[21;9H    if (sread(fd, cmd, 9) != 1) return 1;[22;13Hmemcpy(result, cmd + 5, 4);          [23;13Hif (write(fd, result, 4) != 4) {[24;13H    perror("write");            [25;17Hreturn 1;       [25;1H[26;1H[K- xvcserver.c 76/304 25%[25;1H[1;5H    char          cmd[16];[2;9Hunsigned char buffer[8192], result[1024];[3;9Hmemset(cmd, 0, 16);                      [4;9H                   [5;9Hif (sread(fd, cmd, 2) != 1) return 1;[6;9H                                     [7;9Hif (memcmp(cmd, "ge", 2) == 0) {[8;9H    if (sread(fd, cmd, 6) != 1) return 1;[9;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[10;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[11;13H    perror("write");                                        [12;17Hreturn 1;       [13;13H}            [14;13Hif (verbose) {[15;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[16;25H\t Replied with %s\n", xvcInfo);                      [17;13H}                                           [18;13Hbreak;[19;9H} else if (memcmp(cmd, "se", 2) == 0) {[20;9H    if (sread(fd, cmd, 9) != 1) return 1;[21;13Hmemcpy(result, cmd + 5, 4);          [22;13Hif (write(fd, result, 4) != 4) {[23;13H    perror("write");            [24;17Hreturn 1;       [25;13H}            [25;1H[26;1H[K- xvcserver.c 77/304 25%[25;1H[1;9Hunsigned char buffer[8192], result[1024];[2;9Hmemset(cmd, 0, 16);                      [3;9H                   [4;9Hif (sread(fd, cmd, 2) != 1) return 1;[5;9H                                     [6;9Hif (memcmp(cmd, "ge", 2) == 0) {[7;9H    if (sread(fd, cmd, 6) != 1) return 1;[8;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[9;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[10;13H    perror("write");                                        [11;17Hreturn 1;       [12;13H}            [13;13Hif (verbose) {[14;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[15;25H\t Replied with %s\n", xvcInfo);                      [16;13H}                                           [17;13Hbreak;[18;9H} else if (memcmp(cmd, "se", 2) == 0) {[19;9H    if (sread(fd, cmd, 9) != 1) return 1;[20;13Hmemcpy(result, cmd + 5, 4);          [21;13Hif (write(fd, result, 4) != 4) {[22;13H    perror("write");            [23;17Hreturn 1;       [24;13H}            [25;13Hif (verbose) {[25;1H[26;1H[K- xvcserver.c 78/304 25%[25;1H[1;9Hmemset(cmd, 0, 16);                      [2;9H                   [3;9Hif (sread(fd, cmd, 2) != 1) return 1;[4;9H                                     [5;9Hif (memcmp(cmd, "ge", 2) == 0) {[6;9H    if (sread(fd, cmd, 6) != 1) return 1;[7;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[8;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[9;13H    perror("write");                                        [10;17Hreturn 1;       [11;13H}            [12;13Hif (verbose) {[13;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[14;25H\t Replied with %s\n", xvcInfo);                      [15;13H}                                           [16;13Hbreak;[17;9H} else if (memcmp(cmd, "se", 2) == 0) {[18;9H    if (sread(fd, cmd, 9) != 1) return 1;[19;13Hmemcpy(result, cmd + 5, 4);          [20;13Hif (write(fd, result, 4) != 4) {[21;13H    perror("write");            [22;17Hreturn 1;       [23;13H}            [24;13Hif (verbose) {[25;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[25;1H[26;1H[K- xvcserver.c 79/304 25%[25;1H[1;9H                   [2;9Hif (sread(fd, cmd, 2) != 1) return 1;[3;9H                                     [4;9Hif (memcmp(cmd, "ge", 2) == 0) {[5;9H    if (sread(fd, cmd, 6) != 1) return 1;[6;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[7;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[8;13H    perror("write");                                        [9;17Hreturn 1;       [10;13H}            [11;13Hif (verbose) {[12;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[13;25H\t Replied with %s\n", xvcInfo);                      [14;13H}                                           [15;13Hbreak;[16;9H} else if (memcmp(cmd, "se", 2) == 0) {[17;9H    if (sread(fd, cmd, 9) != 1) return 1;[18;13Hmemcpy(result, cmd + 5, 4);          [19;13Hif (write(fd, result, 4) != 4) {[20;13H    perror("write");            [21;17Hreturn 1;       [22;13H}            [23;13Hif (verbose) {[24;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[25;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [25;1H[26;1H[K- xvcserver.c 80/304 26%[25;1H[1;9Hif (sread(fd, cmd, 2) != 1) return 1;[2;9H                                     [3;9Hif (memcmp(cmd, "ge", 2) == 0) {[4;9H    if (sread(fd, cmd, 6) != 1) return 1;[5;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[6;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[7;13H    perror("write");                                        [8;17Hreturn 1;       [9;13H}            [10;13Hif (verbose) {[11;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[12;25H\t Replied with %s\n", xvcInfo);                      [13;13H}                                           [14;13Hbreak;[15;9H} else if (memcmp(cmd, "se", 2) == 0) {[16;9H    if (sread(fd, cmd, 9) != 1) return 1;[17;13Hmemcpy(result, cmd + 5, 4);          [18;13Hif (write(fd, result, 4) != 4) {[19;13H    perror("write");            [20;17Hreturn 1;       [21;13H}            [22;13Hif (verbose) {[23;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[24;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [25;13H}                                                    [25;1H[26;1H[K- xvcserver.c 81/304 26%[25;1H[1;9H                                     [2;9Hif (memcmp(cmd, "ge", 2) == 0) {[3;9H    if (sread(fd, cmd, 6) != 1) return 1;[4;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[5;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[6;13H    perror("write");                                        [7;17Hreturn 1;       [8;13H}            [9;13Hif (verbose) {[10;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[11;25H\t Replied with %s\n", xvcInfo);                      [12;13H}                                           [13;13Hbreak;[14;9H} else if (memcmp(cmd, "se", 2) == 0) {[15;9H    if (sread(fd, cmd, 9) != 1) return 1;[16;13Hmemcpy(result, cmd + 5, 4);          [17;13Hif (write(fd, result, 4) != 4) {[18;13H    perror("write");            [19;17Hreturn 1;       [20;13H}            [21;13Hif (verbose) {[22;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[23;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [24;13H}                                                    [25;13Hbreak;[25;1H[26;1H[K- xvcserver.c 82/304 26%[25;1H[1;9Hif (memcmp(cmd, "ge", 2) == 0) {[2;9H    if (sread(fd, cmd, 6) != 1) return 1;[3;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[4;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[5;13H    perror("write");                                        [6;17Hreturn 1;       [7;13H}            [8;13Hif (verbose) {[9;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[10;25H\t Replied with %s\n", xvcInfo);                      [11;13H}                                           [12;13Hbreak;[13;9H} else if (memcmp(cmd, "se", 2) == 0) {[14;9H    if (sread(fd, cmd, 9) != 1) return 1;[15;13Hmemcpy(result, cmd + 5, 4);          [16;13Hif (write(fd, result, 4) != 4) {[17;13H    perror("write");            [18;17Hreturn 1;       [19;13H}            [20;13Hif (verbose) {[21;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[22;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [23;13H}                                                    [24;13Hbreak;[25;9H} else if (memcmp(cmd, "sh", 2) == 0) {[25;1H[26;1H[K- xvcserver.c 83/304 27%[25;1H[1;9H    if (sread(fd, cmd, 6) != 1) return 1;[2;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[3;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[4;13H    perror("write");                                        [5;17Hreturn 1;       [6;13H}            [7;13Hif (verbose) {[8;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[9;25H\t Replied with %s\n", xvcInfo);                      [10;13H}                                           [11;13Hbreak;[12;9H} else if (memcmp(cmd, "se", 2) == 0) {[13;9H    if (sread(fd, cmd, 9) != 1) return 1;[14;13Hmemcpy(result, cmd + 5, 4);          [15;13Hif (write(fd, result, 4) != 4) {[16;13H    perror("write");            [17;17Hreturn 1;       [18;13H}            [19;13Hif (verbose) {[20;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[21;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [22;13H}                                                    [23;13Hbreak;[24;9H} else if (memcmp(cmd, "sh", 2) == 0) {[25;9H    if (sread(fd, cmd, 4) != 1) return 1;[25;1H[26;1H[K- xvcserver.c 84/304 27%[25;1H[1;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[2;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[3;13H    perror("write");                                        [4;17Hreturn 1;       [5;13H}            [6;13Hif (verbose) {[7;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[8;25H\t Replied with %s\n", xvcInfo);                      [9;13H}                                           [10;13Hbreak;[11;9H} else if (memcmp(cmd, "se", 2) == 0) {[12;9H    if (sread(fd, cmd, 9) != 1) return 1;[13;13Hmemcpy(result, cmd + 5, 4);          [14;13Hif (write(fd, result, 4) != 4) {[15;13H    perror("write");            [16;17Hreturn 1;       [17;13H}            [18;13Hif (verbose) {[19;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[20;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [21;13H}                                                    [22;13Hbreak;[23;9H} else if (memcmp(cmd, "sh", 2) == 0) {[24;9H    if (sread(fd, cmd, 4) != 1) return 1;[25;17Hverbose) {                       [25;1H[26;1H[K- xvcserver.c 85/304 27%[25;1H[1;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[2;13H    perror("write");                                        [3;17Hreturn 1;       [4;13H}            [5;13Hif (verbose) {[6;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[7;25H\t Replied with %s\n", xvcInfo);                      [8;13H}                                           [9;13Hbreak;[10;9H} else if (memcmp(cmd, "se", 2) == 0) {[11;9H    if (sread(fd, cmd, 9) != 1) return 1;[12;13Hmemcpy(result, cmd + 5, 4);          [13;13Hif (write(fd, result, 4) != 4) {[14;13H    perror("write");            [15;17Hreturn 1;       [16;13H}            [17;13Hif (verbose) {[18;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[19;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [20;13H}                                                    [21;13Hbreak;[22;9H} else if (memcmp(cmd, "sh", 2) == 0) {[23;9H    if (sread(fd, cmd, 4) != 1) return 1;[24;17Hverbose) {                       [25;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[25;1H[26;1H[K- xvcserver.c 86/304 28%[25;1H[1;13H    perror("write");                                        [2;17Hreturn 1;       [3;13H}            [4;13Hif (verbose) {[5;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[6;25H\t Replied with %s\n", xvcInfo);                      [7;13H}                                           [8;13Hbreak;[9;9H} else if (memcmp(cmd, "se", 2) == 0) {[10;9H    if (sread(fd, cmd, 9) != 1) return 1;[11;13Hmemcpy(result, cmd + 5, 4);          [12;13Hif (write(fd, result, 4) != 4) {[13;13H    perror("write");            [14;17Hreturn 1;       [15;13H}            [16;13Hif (verbose) {[17;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[18;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [19;13H}                                                    [20;13Hbreak;[21;9H} else if (memcmp(cmd, "sh", 2) == 0) {[22;9H    if (sread(fd, cmd, 4) != 1) return 1;[23;17Hverbose) {                       [24;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[25;13H}                                                               [25;1H[26;1H[K- xvcserver.c 87/304 28%[25;1H[1;17Hreturn 1;       [2;13H}            [3;13Hif (verbose) {[4;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[5;25H\t Replied with %s\n", xvcInfo);                      [6;13H}                                           [7;13Hbreak;[8;9H} else if (memcmp(cmd, "se", 2) == 0) {[9;9H    if (sread(fd, cmd, 9) != 1) return 1;[10;13Hmemcpy(result, cmd + 5, 4);          [11;13Hif (write(fd, result, 4) != 4) {[12;13H    perror("write");            [13;17Hreturn 1;       [14;13H}            [15;13Hif (verbose) {[16;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[17;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [18;13H}                                                    [19;13Hbreak;[20;9H} else if (memcmp(cmd, "sh", 2) == 0) {[21;9H    if (sread(fd, cmd, 4) != 1) return 1;[22;17Hverbose) {                       [23;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[24;13H}                                                               [25;9H} else {[25;1H[26;1H[K- xvcserver.c 88/304 28%[25;1H[1;13H}            [2;13Hif (verbose) {[3;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[4;25H\t Replied with %s\n", xvcInfo);                      [5;13H}                                           [6;13Hbreak;[7;9H} else if (memcmp(cmd, "se", 2) == 0) {[8;9H    if (sread(fd, cmd, 9) != 1) return 1;[9;13Hmemcpy(result, cmd + 5, 4);          [10;13Hif (write(fd, result, 4) != 4) {[11;13H    perror("write");            [12;17Hreturn 1;       [13;13H}            [14;13Hif (verbose) {[15;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[16;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [17;13H}                                                    [18;13Hbreak;[19;9H} else if (memcmp(cmd, "sh", 2) == 0) {[20;9H    if (sread(fd, cmd, 4) != 1) return 1;[21;17Hverbose) {                       [22;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[23;13H}                                                               [24;9H} else {[25;9H    fprintf(stderr, "invalid cmd '%s'\n", cmd);[25;1H[26;1H[K- xvcserver.c 89/304 29%[25;1H[26;1H[K- xvcserver.c 90/304 29%[25;1H[26;1H[K- xvcserver.c 91/304 29%[25;1H[26;1H[K- xvcserver.c 92/304 30%[25;1H[26;1H[K- xvcserver.c 93/304 30%[25;1H[26;1H[K- xvcserver.c 94/304 30%[25;1H[26;1H[K- xvcserver.c 95/304 31%[25;1H[26;1H[K- xvcserver.c 96/304 31%[25;1H[26;1H[K- xvcserver.c 97/304 31%[25;1H[26;1H[K- xvcserver.c 98/304 32%[25;1H[1;13H    perror("write");[2;13H    return 1; [3;13H}                                                                 [4;13Hif (verbose) {                              [5;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[6;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[7;9H    }                                  [8;13Hbreak;                               [9;9H} else if (memcmp(cmd, "sh", 2) == 0) {[10;17Hsread(fd, cmd, 4) != 1) return 1;[11;13Hif (verbose) {      [12;17Hprintf("%u : Received command: 'shift'\n", (int)time(NULL));[14;9H} else {          [15;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);                      [16;13Hreturn 1;                                            [17;9H}    [18;13H      [19;9Hint len;                               [20;9Hif (sread(fd, &len, 4) != 1) {           [21;13Hfprintf(stderr, "reading length failed\n");[22;13Hreturn 1;                                                       [23;9H}    [24;9H        [25;9Hint nr_bytes = (len + 7) / 8;                  [25;1H[26;1H[K- xvcserver.c 99/304 32%[25;1H[1;17Hreturn 1;       [2;13H}            [3;13Hif (verbose) {[4;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[5;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [6;13H}                                                    [7;13Hbreak;[8;9H} else if (memcmp(cmd, "sh", 2) == 0) {[9;9H    if (sread(fd, cmd, 4) != 1) return 1;[10;17Hverbose) {                       [11;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[12;13H}                                                               [13;9H} else {[14;9H    fprintf(stderr, "invalid cmd '%s'\n", cmd);[15;13Hreturn 1;                                  [16;9H}            [17;9H [18;9Hint len;[19;10Hf (sread(fd, &len, 4) != 1) {[20;9H    fprintf(stderr, "reading length failed\n");[21;13Hreturn 1;                                  [22;9H}            [23;9H [24;9Hint nr_bytes = (len + 7) / 8;[25;10Hf (nr_bytes * 2 > sizeof(buffer)) {[25;1H[26;1H[K- xvcserver.c 100/304 32%[25;1H[1;13H}            [2;13Hif (verbose) {[3;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[4;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [5;13H}                                                    [6;13Hbreak;[7;9H} else if (memcmp(cmd, "sh", 2) == 0) {[8;9H    if (sread(fd, cmd, 4) != 1) return 1;[9;17Hverbose) {                       [10;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[11;13H}                                                               [12;9H} else {[13;9H    fprintf(stderr, "invalid cmd '%s'\n", cmd);[14;13Hreturn 1;                                  [15;9H}            [16;9H [17;9Hint len;[18;10Hf (sread(fd, &len, 4) != 1) {[19;9H    fprintf(stderr, "reading length failed\n");[20;13Hreturn 1;                                  [21;9H}            [22;9H [23;9Hint nr_bytes = (len + 7) / 8;[24;10Hf (nr_bytes * 2 > sizeof(buffer)) {[25;9H    fprintf(stderr, "buffer size exceeded\n");[25;1H[26;1H[K- xvcserver.c 101/304 33%[25;1H[1;13Hif (verbose) {[2;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[3;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [4;13H}                                                    [5;13Hbreak;[6;9H} else if (memcmp(cmd, "sh", 2) == 0) {[7;9H    if (sread(fd, cmd, 4) != 1) return 1;[8;17Hverbose) {                       [9;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[10;13H}                                                               [11;9H} else {[12;9H    fprintf(stderr, "invalid cmd '%s'\n", cmd);[13;13Hreturn 1;                                  [14;9H}            [15;9H [16;9Hint len;[17;10Hf (sread(fd, &len, 4) != 1) {[18;9H    fprintf(stderr, "reading length failed\n");[19;13Hreturn 1;                                  [20;9H}            [21;9H [22;9Hint nr_bytes = (len + 7) / 8;[23;10Hf (nr_bytes * 2 > sizeof(buffer)) {[24;9H    fprintf(stderr, "buffer size exceeded\n");[25;13Hreturn 1;                                 [25;1H[26;1H[K- xvcserver.c 102/304 33%[25;1H[26;1H[K- xvcserver.c 103/304 33%[25;1H[26;1H[K- xvcserver.c 104/304 34%[25;1H[26;1H[K- xvcserver.c 105/304 34%[25;1H[26;1H[K- xvcserver.c 106/304 34%[25;1H[26;1H[K- xvcserver.c 107/304 35%[25;1H[26;1H[K- xvcserver.c 108/304 35%[25;1H[26;1H[K- xvcserver.c 109/304 35%[25;1H[26;1H[K- xvcserver.c 110/304 36%[25;1H[26;1H[K- xvcserver.c 111/304 36%[25;1H[26;1H[K- xvcserver.c 112/304 36%[25;1H[1;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[2;13Hreturn 1;                                                        [3;9H}                                                        [4;13H [5;9Hint len;  [6;9Hif (sread(fd, &len, 4) != 1) {         [7;13Hfprintf(stderr, "reading length failed\n");[8;13Hreturn 1;     [9;9H}                                                                   [10;13H [11;9Hint nr_bytes = (len + 7) / 8;[12;9Hif (nr_bytes * 2 > sizeof(buffer)) {           [13;13Hfprintf(stderr, "buffer size exceeded\n");[14;9H    return 1;[15;9H}[16;9H        [17;23Hbuffer, nr_bytes * 2) != 1) {[18;38Hdata failed\n");  [21;9Hmemset(result, 0, nr_bytes);[22;9H                             [23;13Hverbose) {                      [24;13Hprintf("\tNumber of Bits  : %d\n", len);  [25;13Hprintf("\tNumber of Bytes : %d \n", nr_bytes);[25;1H[26;1H[K- xvcserver.c 113/304 37%[25;1H[1;13Hreturn 1;                                  [2;9H}            [3;9H [4;9Hint len;[5;10Hf (sread(fd, &len, 4) != 1) {[6;9H    fprintf(stderr, "reading length failed\n");[7;13Hreturn 1;                                  [8;9H}            [9;9H [10;9Hint nr_bytes = (len + 7) / 8;[11;10Hf (nr_bytes * 2 > sizeof(buffer)) {[12;9H    fprintf(stderr, "buffer size exceeded\n");[13;13Hreturn 1;                                 [14;9H}            [15;9H [16;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[17;9H    fprintf(stderr, "reading data failed\n");[18;13Hreturn 1;                                [19;9H}            [20;9Hmemset(result, 0, nr_bytes);[21;9H                            [22;9Hif (verbose) {[23;9H    printf("\tNumber of Bits  : %d\n", len);[24;34Hytes : %d \n", nr_bytes);[25;22Hn");                                 [25;1H[26;1H[K- xvcserver.c 114/304 37%[25;1H[1;9H}            [2;9H [3;9Hint len;[4;10Hf (sread(fd, &len, 4) != 1) {[5;9H    fprintf(stderr, "reading length failed\n");[6;13Hreturn 1;                                  [7;9H}            [8;9H [9;9Hint nr_bytes = (len + 7) / 8;[10;10Hf (nr_bytes * 2 > sizeof(buffer)) {[11;9H    fprintf(stderr, "buffer size exceeded\n");[12;13Hreturn 1;                                 [13;9H}            [14;9H [15;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[16;9H    fprintf(stderr, "reading data failed\n");[17;13Hreturn 1;                                [18;9H}            [19;9Hmemset(result, 0, nr_bytes);[20;9H                            [21;9Hif (verbose) {[22;9H    printf("\tNumber of Bits  : %d\n", len);[23;34Hytes : %d \n", nr_bytes);[24;22Hn");                                 [25;9H}                [25;1H[26;1H[K- xvcserver.c 115/304 37%[25;1H[1;9H [2;9Hint len;[3;10Hf (sread(fd, &len, 4) != 1) {[4;9H    fprintf(stderr, "reading length failed\n");[5;13Hreturn 1;                                  [6;9H}            [7;9H [8;9Hint nr_bytes = (len + 7) / 8;[9;10Hf (nr_bytes * 2 > sizeof(buffer)) {[10;9H    fprintf(stderr, "buffer size exceeded\n");[11;13Hreturn 1;                                 [12;9H}            [13;9H [14;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[15;9H    fprintf(stderr, "reading data failed\n");[16;13Hreturn 1;                                [17;9H}            [18;9Hmemset(result, 0, nr_bytes);[19;9H                            [20;9Hif (verbose) {[21;9H    printf("\tNumber of Bits  : %d\n", len);[22;34Hytes : %d \n", nr_bytes);[23;22Hn");                                 [24;9H}                [25;9H [25;1H[26;1H[K- xvcserver.c 116/304 38%[25;1H[1;9Hint len;[2;10Hf (sread(fd, &len, 4) != 1) {[3;9H    fprintf(stderr, "reading length failed\n");[4;13Hreturn 1;                                  [5;9H}            [6;9H [7;9Hint nr_bytes = (len + 7) / 8;[8;10Hf (nr_bytes * 2 > sizeof(buffer)) {[9;9H    fprintf(stderr, "buffer size exceeded\n");[10;13Hreturn 1;                                 [11;9H}            [12;9H [13;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[14;9H    fprintf(stderr, "reading data failed\n");[15;13Hreturn 1;                                [16;9H}            [17;9Hmemset(result, 0, nr_bytes);[18;9H                            [19;9Hif (verbose) {[20;9H    printf("\tNumber of Bits  : %d\n", len);[21;34Hytes : %d \n", nr_bytes);[22;22Hn");                                 [23;9H}                [24;9H [25;9Hint bytesLeft = nr_bytes;[25;1H[26;1H[K- xvcserver.c 117/304 38%[25;1H[1;10Hf (sread(fd, &len, 4) != 1) {[2;9H    fprintf(stderr, "reading length failed\n");[3;13Hreturn 1;                                  [4;9H}            [5;9H [6;9Hint nr_bytes = (len + 7) / 8;[7;10Hf (nr_bytes * 2 > sizeof(buffer)) {[8;9H    fprintf(stderr, "buffer size exceeded\n");[9;13Hreturn 1;                                 [10;9H}            [11;9H [12;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[13;9H    fprintf(stderr, "reading data failed\n");[14;13Hreturn 1;                                [15;9H}            [16;9Hmemset(result, 0, nr_bytes);[17;9H                            [18;9Hif (verbose) {[19;9H    printf("\tNumber of Bits  : %d\n", len);[20;34Hytes : %d \n", nr_bytes);[21;22Hn");                                 [22;9H}                [23;9H [24;9Hint bytesLeft = nr_bytes;[25;14HitsLeft  = len;     [25;1H[26;1H[K- xvcserver.c 118/304 38%[25;1H[26;1H[K- xvcserver.c 119/304 39%[25;1H[1;9H    return 1;                 [2;9H}                                              [3;13H         [4;9Hint nr_bytes = (len + 7) / 8;[5;9Hif (nr_bytes * 2 > sizeof(buffer)) {[6;9H    fprintf(stderr, "buffer size exceeded\n");[7;9H    return 1;                       [8;9H}                                             [9;13H         [10;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[11;13Hfprintf(stderr, "reading data failed\n");[12;9H    return 1;                              [13;9H}                                            [14;9Hmemset(result, 0, nr_bytes);[15;9H [16;9Hif (verbose) {              [17;13Hprintf("\tNumber of Bits  : %d\n", len);[18;9H    printf("\tNumber of Bytes : %d \n", nr_bytes);[19;22Hn");                           [20;9H}                                                 [21;13H             [22;9Hint bytesLeft = nr_bytes;[23;9Hint bitsLeft  = len;[24;17HIndex = 0;       [25;13Htdi, tms, tdo;  [25;1H[26;1H[K- xvcserver.c 120/304 39%[25;1H[1;9H}            [2;9H [3;9Hint nr_bytes = (len + 7) / 8;[4;10Hf (nr_bytes * 2 > sizeof(buffer)) {[5;9H    fprintf(stderr, "buffer size exceeded\n");[6;13Hreturn 1;                                 [7;9H}            [8;9H [9;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[10;9H    fprintf(stderr, "reading data failed\n");[11;13Hreturn 1;                                [12;9H}            [13;9Hmemset(result, 0, nr_bytes);[14;9H                            [15;9Hif (verbose) {[16;9H    printf("\tNumber of Bits  : %d\n", len);[17;34Hytes : %d \n", nr_bytes);[18;22Hn");                                 [19;9H}                [20;9H [21;9Hint bytesLeft = nr_bytes;[22;14HitsLeft  = len;     [23;14HyteIndex = 0;  [24;13Htdi, tms, tdo[25;9H                  [25;1H[26;1H[K- xvcserver.c 121/304 39%[25;1H[1;9H [2;9Hint nr_bytes = (len + 7) / 8;[3;10Hf (nr_bytes * 2 > sizeof(buffer)) {[4;9H    fprintf(stderr, "buffer size exceeded\n");[5;13Hreturn 1;                                 [6;9H}            [7;9H [8;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[9;9H    fprintf(stderr, "reading data failed\n");[10;13Hreturn 1;                                [11;9H}            [12;9Hmemset(result, 0, nr_bytes);[13;9H                            [14;9Hif (verbose) {[15;9H    printf("\tNumber of Bits  : %d\n", len);[16;34Hytes : %d \n", nr_bytes);[17;22Hn");                                 [18;9H}                [19;9H [20;9Hint bytesLeft = nr_bytes;[21;14HitsLeft  = len;     [22;14HyteIndex = 0;  [23;13Htdi, tms, tdo[24;9H                  [25;9Hwhile (bytesLeft > 0) {[25;1H[26;1H[K- xvcserver.c 122/304 40%[25;1H[1;9Hint nr_bytes = (len + 7) / 8;[2;10Hf (nr_bytes * 2 > sizeof(buffer)) {[3;9H    fprintf(stderr, "buffer size exceeded\n");[4;13Hreturn 1;                                 [5;9H}            [6;9H [7;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[8;9H    fprintf(stderr, "reading data failed\n");[9;13Hreturn 1;                                [10;9H}            [11;9Hmemset(result, 0, nr_bytes);[12;9H                            [13;9Hif (verbose) {[14;9H    printf("\tNumber of Bits  : %d\n", len);[15;34Hytes : %d \n", nr_bytes);[16;22Hn");                                 [17;9H}                [18;9H [19;9Hint bytesLeft = nr_bytes;[20;14HitsLeft  = len;     [21;14HyteIndex = 0;  [22;13Htdi, tms, tdo[23;9H                  [24;9Hwhile (bytesLeft > 0) {[25;9H    tms = 0;           [25;1H[26;1H[K- xvcserver.c 123/304 40%[25;1H[1;10Hf (nr_bytes * 2 > sizeof(buffer)) {[2;9H    fprintf(stderr, "buffer size exceeded\n");[3;13Hreturn 1;                                 [4;9H}            [5;9H [6;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[7;9H    fprintf(stderr, "reading data failed\n");[8;13Hreturn 1;                                [9;9H}            [10;9Hmemset(result, 0, nr_bytes);[11;9H                            [12;9Hif (verbose) {[13;9H    printf("\tNumber of Bits  : %d\n", len);[14;34Hytes : %d \n", nr_bytes);[15;22Hn");                                 [16;9H}                [17;9H [18;9Hint bytesLeft = nr_bytes;[19;14HitsLeft  = len;     [20;14HyteIndex = 0;  [21;13Htdi, tms, tdo[22;9H                  [23;9Hwhile (bytesLeft > 0) {[24;9H    tms = 0;           [25;14Hdi[25;1H[26;1H[K- xvcserver.c 124/304 40%[25;1H[1;9H    fprintf(stderr, "buffer size exceeded\n");[2;13Hreturn 1;                                 [3;9H}            [4;9H [5;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[6;9H    fprintf(stderr, "reading data failed\n");[7;13Hreturn 1;                                [8;9H}            [9;9Hmemset(result, 0, nr_bytes);[10;9H                            [11;9Hif (verbose) {[12;9H    printf("\tNumber of Bits  : %d\n", len);[13;34Hytes : %d \n", nr_bytes);[14;22Hn");                                 [15;9H}                [16;9H [17;9Hint bytesLeft = nr_bytes;[18;14HitsLeft  = len;     [19;14HyteIndex = 0;  [20;13Htdi, tms, tdo[21;9H                  [22;9Hwhile (bytesLeft > 0) {[23;9H    tms = 0;           [24;14Hdi[25;15Ho[25;1H[26;1H[K- xvcserver.c 125/304 41%[25;1H[1;13Hreturn 1;                                 [2;9H}            [3;9H [4;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[5;9H    fprintf(stderr, "reading data failed\n");[6;13Hreturn 1;                                [7;9H}            [8;9Hmemset(result, 0, nr_bytes);[9;9H                            [10;9Hif (verbose) {[11;9H    printf("\tNumber of Bits  : %d\n", len);[12;34Hytes : %d \n", nr_bytes);[13;22Hn");                                 [14;9H}                [15;9H [16;9Hint bytesLeft = nr_bytes;[17;14HitsLeft  = len;     [18;14HyteIndex = 0;  [19;13Htdi, tms, tdo[20;9H                  [21;9Hwhile (bytesLeft > 0) {[22;9H    tms = 0;           [23;14Hdi[24;15Ho[25;13Hif (bytesLeft >= 4) {[25;1H[26;1H[K- xvcserver.c 126/304 41%[25;1H[1;9H}            [2;9H [3;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[4;9H    fprintf(stderr, "reading data failed\n");[5;13Hreturn 1;                                [6;9H}            [7;9Hmemset(result, 0, nr_bytes);[8;9H                            [9;9Hif (verbose) {[10;9H    printf("\tNumber of Bits  : %d\n", len);[11;34Hytes : %d \n", nr_bytes);[12;22Hn");                                 [13;9H}                [14;9H [15;9Hint bytesLeft = nr_bytes;[16;14HitsLeft  = len;     [17;14HyteIndex = 0;  [18;13Htdi, tms, tdo[19;9H                  [20;9Hwhile (bytesLeft > 0) {[21;9H    tms = 0;           [22;14Hdi[23;15Ho[24;13Hif (bytesLeft >= 4) {[25;13H    memcpy(&tms, &buffer[byteIndex], 4);[25;1H[26;1H[K- xvcserver.c 127/304 41%[25;1H[1;9H [2;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[3;9H    fprintf(stderr, "reading data failed\n");[4;13Hreturn 1;                                [5;9H}            [6;9Hmemset(result, 0, nr_bytes);[7;9H                            [8;9Hif (verbose) {[9;9H    printf("\tNumber of Bits  : %d\n", len);[10;34Hytes : %d \n", nr_bytes);[11;22Hn");                                 [12;9H}                [13;9H [14;9Hint bytesLeft = nr_bytes;[15;14HitsLeft  = len;     [16;14HyteIndex = 0;  [17;13Htdi, tms, tdo[18;9H                  [19;9Hwhile (bytesLeft > 0) {[20;9H    tms = 0;           [21;14Hdi[22;15Ho[23;13Hif (bytesLeft >= 4) {[24;13H    memcpy(&tms, &buffer[byteIndex], 4);[25;26Hdi, &buffer[byteIndex + nr_bytes], 4);[25;1H[26;1H[K- xvcserver.c 128/304 42%[25;1H[1;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[2;9H    fprintf(stderr, "reading data failed\n");[3;13Hreturn 1;                                [4;9H}            [5;9Hmemset(result, 0, nr_bytes);[6;9H                            [7;9Hif (verbose) {[8;9H    printf("\tNumber of Bits  : %d\n", len);[9;34Hytes : %d \n", nr_bytes);[10;22Hn");                                 [11;9H}                [12;9H [13;9Hint bytesLeft = nr_bytes;[14;14HitsLeft  = len;     [15;14HyteIndex = 0;  [16;13Htdi, tms, tdo[17;9H                  [18;9Hwhile (bytesLeft > 0) {[19;9H    tms = 0;           [20;14Hdi[21;15Ho[22;13Hif (bytesLeft >= 4) {[23;13H    memcpy(&tms, &buffer[byteIndex], 4);[24;26Hdi, &buffer[byteIndex + nr_bytes], 4);[25;17H                                               [25;1H[26;1H[K- xvcserver.c 129/304 42%[25;1H[1;9H    fprintf(stderr, "reading data failed\n");[2;13Hreturn 1;                                [3;9H}            [4;9Hmemset(result, 0, nr_bytes);[5;9H                            [6;9Hif (verbose) {[7;9H    printf("\tNumber of Bits  : %d\n", len);[8;34Hytes : %d \n", nr_bytes);[9;22Hn");                                 [10;9H}                [11;9H [12;9Hint bytesLeft = nr_bytes;[13;14HitsLeft  = len;     [14;14HyteIndex = 0;  [15;13Htdi, tms, tdo[16;9H                  [17;9Hwhile (bytesLeft > 0) {[18;9H    tms = 0;           [19;14Hdi[20;15Ho[21;13Hif (bytesLeft >= 4) {[22;13H    memcpy(&tms, &buffer[byteIndex], 4);[23;26Hdi, &buffer[byteIndex + nr_bytes], 4);[24;17H                                               [25;17Hptr->length_offset = 32;[25;1H[26;1H[K- xvcserver.c 130/304 42%[25;1H[26;1H[K- xvcserver.c 131/304 43%[25;1H[26;1H[K- xvcserver.c 132/304 43%[25;1H[26;1H[K- xvcserver.c 133/304 43%[25;1H[26;1H[K- xvcserver.c 134/304 44%[25;1H[26;1H[K- xvcserver.c 135/304 44%[25;1H[26;1H[K- xvcserver.c 136/304 44%[25;1H[26;1H[K- xvcserver.c 137/304 45%[25;1H[26;1H[K- xvcserver.c 138/304 45%[25;1H[26;1H[K- xvcserver.c 139/304 45%[25;1H[1;13H                                         [2;9Hint bytesLeft = nr_bytes;[3;9Hint bitsLeft  = len;[4;9Hint byteIndex = 0;          [5;9Hint tdi, tms, tdo;[6;9H              [7;9Hwhile (bytesLeft > 0) {                     [8;13Htms = 0;                                      [9;13Htdi = 0;     [10;9H    tdo = 0;[11;13Hif (bytesLeft >= 4) {[12;9H        memcpy(&tms, &buffer[byteIndex], 4);[13;9H        memcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[14;9H                  [15;9H        ptr->length_offset = 32;[16;17Hdsb(st);[17;9H        ptr->tms_offset = tms;[18;13H    dsb(st);[19;13H    ptr->tdi_offset = tdi;[20;13H    dsb(st);[21;13H    ptr->ctrl_offset = 0x01;[22;17H                                    [23;17H/* Switch this to interrupt in next revision */[24;17Hwhile (ptr->ctrl_offset) {}[25;17H                        [25;1H[26;1H[K- xvcserver.c 140/304 46%[25;1H[1;9Hint bytesLeft = nr_bytes;[2;14HitsLeft  = len;     [3;14HyteIndex = 0;  [4;13Htdi, tms, tdo[5;9H                  [6;9Hwhile (bytesLeft > 0) {[7;9H    tms = 0;           [8;14Hdi[9;15Ho[10;13Hif (bytesLeft >= 4) {[11;13H    memcpy(&tms, &buffer[byteIndex], 4);[12;26Hdi, &buffer[byteIndex + nr_bytes], 4);[13;17H                                               [14;17Hptr->length_offset = 32;[15;17Hdsb(st);                [16;17Hptr->tms_offset = tms;[17;17Hdsb(st);              [18;17Hptr->tdi_offset = tdi;[19;17Hdsb(st);              [20;17Hptr->ctrl_offset = 0x01;[21;17H                        [22;17H/* Switch this to interrupt in next revision */[23;17Hwhile (ptr->ctrl_offset) {}                    [24;17H                           [25;17Htdo = ptr->tdo_offset;[25;1H[26;1H[K- xvcserver.c 141/304 46%[25;1H[1;14HitsLeft  = len;     [2;14HyteIndex = 0;  [3;13Htdi, tms, tdo[4;9H                  [5;9Hwhile (bytesLeft > 0) {[6;9H    tms = 0;           [7;14Hdi[8;15Ho[9;13Hif (bytesLeft >= 4) {[10;13H    memcpy(&tms, &buffer[byteIndex], 4);[11;26Hdi, &buffer[byteIndex + nr_bytes], 4);[12;17H                                               [13;17Hptr->length_offset = 32;[14;17Hdsb(st);                [15;17Hptr->tms_offset = tms;[16;17Hdsb(st);              [17;17Hptr->tdi_offset = tdi;[18;17Hdsb(st);              [19;17Hptr->ctrl_offset = 0x01;[20;17H                        [21;17H/* Switch this to interrupt in next revision */[22;17Hwhile (ptr->ctrl_offset) {}                    [23;17H                           [24;17Htdo = ptr->tdo_offset;[25;17Hmemcpy(&result[byteIndex], &tdo, 4);[25;1H[26;1H[K- xvcserver.c 142/304 46%[25;1H[1;14HyteIndex = 0;  [2;13Htdi, tms, tdo[3;9H                  [4;9Hwhile (bytesLeft > 0) {[5;9H    tms = 0;           [6;14Hdi[7;15Ho[8;13Hif (bytesLeft >= 4) {[9;13H    memcpy(&tms, &buffer[byteIndex], 4);[10;26Hdi, &buffer[byteIndex + nr_bytes], 4);[11;17H                                               [12;17Hptr->length_offset = 32;[13;17Hdsb(st);                [14;17Hptr->tms_offset = tms;[15;17Hdsb(st);              [16;17Hptr->tdi_offset = tdi;[17;17Hdsb(st);              [18;17Hptr->ctrl_offset = 0x01;[19;17H                        [20;17H/* Switch this to interrupt in next revision */[21;17Hwhile (ptr->ctrl_offset) {}                    [22;17H                           [23;17Htdo = ptr->tdo_offset;[24;17Hmemcpy(&result[byteIndex], &tdo, 4);[25;17H                                    [25;1H[26;1H[K- xvcserver.c 143/304 47%[25;1H[1;13Htdi, tms, tdo[2;9H                  [3;9Hwhile (bytesLeft > 0) {[4;9H    tms = 0;           [5;14Hdi[6;15Ho[7;13Hif (bytesLeft >= 4) {[8;13H    memcpy(&tms, &buffer[byteIndex], 4);[9;26Hdi, &buffer[byteIndex + nr_bytes], 4);[10;17H                                               [11;17Hptr->length_offset = 32;[12;17Hdsb(st);                [13;17Hptr->tms_offset = tms;[14;17Hdsb(st);              [15;17Hptr->tdi_offset = tdi;[16;17Hdsb(st);              [17;17Hptr->ctrl_offset = 0x01;[18;17H                        [19;17H/* Switch this to interrupt in next revision */[20;17Hwhile (ptr->ctrl_offset) {}                    [21;17H                           [22;17Htdo = ptr->tdo_offset;[23;17Hmemcpy(&result[byteIndex], &tdo, 4);[24;17H                                    [25;17HbytesLeft -= 4;[25;1H[26;1H[K- xvcserver.c 144/304 47%[25;1H[26;1H[K- xvcserver.c 145/304 47%[25;1H[26;1H[K- xvcserver.c 146/304 48%[25;1H[26;1H[K- xvcserver.c 147/304 48%[25;1H[26;1H[K- xvcserver.c 148/304 48%[25;1H[26;1H[K- xvcserver.c 149/304 49%[25;1H[1;9H    if (bytesLeft >= 4) {[2;17Hmemcpy(&tms, &buffer[byteIndex], 4);[3;9H        memcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[4;13H        [5;13H    ptr->length_offset = 32;[6;13H    dsb(st);[7;13H    ptr->tms_offset = tms;[8;17Hdsb(st);                            [9;17Hptr->tdi_offset = tdi;                         [10;17Hdsb(st);[11;22Hctrl_offset = 0x01[12;17H        [13;17H/* Switch this to interrupt in next revision */[14;17Hwhile (ptr->ctrl_offset) {}[15;17H                      [16;17Htdo = ptr->tdo_offset;[17;17Hmemcpy(&result[byteIndex], &tdo, 4);[19;17HbytesLeft -= 4;                                [20;17HbitsLeft -= 32;            [21;17HbyteIndex += 4;[22;17H                      [23;17Hif (verbose) {                      [24;21Hprintf("LEN : 0x%08x\n", 32);[25;17H    printf("TMS : 0x%08x\n", tms);[25;1H[26;1H[K- xvcserver.c 150/304 49%[25;1H[1;13H    memcpy(&tms, &buffer[byteIndex], 4);[2;26Hdi, &buffer[byteIndex + nr_bytes], 4);[3;17H                                               [4;17Hptr->length_offset = 32;[5;17Hdsb(st);                [6;17Hptr->tms_offset = tms;[7;17Hdsb(st);              [8;17Hptr->tdi_offset = tdi;[9;17Hdsb(st);              [10;17Hptr->ctrl_offset = 0x01;[11;17H                        [12;17H/* Switch this to interrupt in next revision */[13;17Hwhile (ptr->ctrl_offset) {}                    [14;17H                           [15;17Htdo = ptr->tdo_offset;[16;17Hmemcpy(&result[byteIndex], &tdo, 4);[17;17H                                    [18;17HbytesLeft -= 4;[19;18HitsLeft -= 32[20;18HyteIndex += 4[21;17H               [22;17Hif (verbose) {[23;17H    printf("LEN : 0x%08x\n", 32);[24;29HTMS : 0x%08x\n", tms);[25;30HDI : 0x%08x\n", tdi[25;1H[26;1H[K- xvcserver.c 151/304 49%[25;1H[1;26Hdi, &buffer[byteIndex + nr_bytes], 4);[2;17H                                               [3;17Hptr->length_offset = 32;[4;17Hdsb(st);                [5;17Hptr->tms_offset = tms;[6;17Hdsb(st);              [7;17Hptr->tdi_offset = tdi;[8;17Hdsb(st);              [9;17Hptr->ctrl_offset = 0x01;[10;17H                        [11;17H/* Switch this to interrupt in next revision */[12;17Hwhile (ptr->ctrl_offset) {}                    [13;17H                           [14;17Htdo = ptr->tdo_offset;[15;17Hmemcpy(&result[byteIndex], &tdo, 4);[16;17H                                    [17;17HbytesLeft -= 4;[18;18HitsLeft -= 32[19;18HyteIndex += 4[20;17H               [21;17Hif (verbose) {[22;17H    printf("LEN : 0x%08x\n", 32);[23;29HTMS : 0x%08x\n", tms);[24;30HDI : 0x%08x\n", tdi[25;31HO : 0x%08x\n", tdo[25;1H[26;1H[K- xvcserver.c 152/304 50%[25;1H[1;17H                                               [2;17Hptr->length_offset = 32;[3;17Hdsb(st);                [4;17Hptr->tms_offset = tms;[5;17Hdsb(st);              [6;17Hptr->tdi_offset = tdi;[7;17Hdsb(st);              [8;17Hptr->ctrl_offset = 0x01;[9;17H                        [10;17H/* Switch this to interrupt in next revision */[11;17Hwhile (ptr->ctrl_offset) {}                    [12;17H                           [13;17Htdo = ptr->tdo_offset;[14;17Hmemcpy(&result[byteIndex], &tdo, 4);[15;17H                                    [16;17HbytesLeft -= 4;[17;18HitsLeft -= 32[18;18HyteIndex += 4[19;17H               [20;17Hif (verbose) {[21;17H    printf("LEN : 0x%08x\n", 32);[22;29HTMS : 0x%08x\n", tms);[23;30HDI : 0x%08x\n", tdi[24;31HO : 0x%08x\n", tdo[25;17H}                                 [25;1H[26;1H[K- xvcserver.c 153/304 50%[25;1H[1;17Hptr->length_offset = 32;[2;17Hdsb(st);                [3;17Hptr->tms_offset = tms;[4;17Hdsb(st);              [5;17Hptr->tdi_offset = tdi;[6;17Hdsb(st);              [7;17Hptr->ctrl_offset = 0x01;[8;17H                        [9;17H/* Switch this to interrupt in next revision */[10;17Hwhile (ptr->ctrl_offset) {}                    [11;17H                           [12;17Htdo = ptr->tdo_offset;[13;17Hmemcpy(&result[byteIndex], &tdo, 4);[14;17H                                    [15;17HbytesLeft -= 4;[16;18HitsLeft -= 32[17;18HyteIndex += 4[18;17H               [19;17Hif (verbose) {[20;17H    printf("LEN : 0x%08x\n", 32);[21;29HTMS : 0x%08x\n", tms);[22;30HDI : 0x%08x\n", tdi[23;31HO : 0x%08x\n", tdo[24;17H}                                 [25;17H [25;1H[26;1H[K- xvcserver.c 154/304 50%[25;1H[1;17Hdsb(st);                [2;17Hptr->tms_offset = tms;[3;17Hdsb(st);              [4;17Hptr->tdi_offset = tdi;[5;17Hdsb(st);              [6;17Hptr->ctrl_offset = 0x01;[7;17H                        [8;17H/* Switch this to interrupt in next revision */[9;17Hwhile (ptr->ctrl_offset) {}                    [10;17H                           [11;17Htdo = ptr->tdo_offset;[12;17Hmemcpy(&result[byteIndex], &tdo, 4);[13;17H                                    [14;17HbytesLeft -= 4;[15;18HitsLeft -= 32[16;18HyteIndex += 4[17;17H               [18;17Hif (verbose) {[19;17H    printf("LEN : 0x%08x\n", 32);[20;29HTMS : 0x%08x\n", tms);[21;30HDI : 0x%08x\n", tdi[22;31HO : 0x%08x\n", tdo[23;17H}                                 [24;17H [25;13H} else {[25;1H[26;1H[K- xvcserver.c 155/304 50%[25;1H[1;17Hptr->tms_offset = tms;[2;17Hdsb(st);              [3;17Hptr->tdi_offset = tdi;[4;17Hdsb(st);              [5;17Hptr->ctrl_offset = 0x01;[6;17H                        [7;17H/* Switch this to interrupt in next revision */[8;17Hwhile (ptr->ctrl_offset) {}                    [9;17H                           [10;17Htdo = ptr->tdo_offset;[11;17Hmemcpy(&result[byteIndex], &tdo, 4);[12;17H                                    [13;17HbytesLeft -= 4;[14;18HitsLeft -= 32[15;18HyteIndex += 4[16;17H               [17;17Hif (verbose) {[18;17H    printf("LEN : 0x%08x\n", 32);[19;29HTMS : 0x%08x\n", tms);[20;30HDI : 0x%08x\n", tdi[21;31HO : 0x%08x\n", tdo[22;17H}                                 [23;17H [24;13H} else {[25;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[25;1H[26;1H[K- xvcserver.c 156/304 51%[25;1H[1;17Hdsb(st);              [2;17Hptr->tdi_offset = tdi;[3;17Hdsb(st);              [4;17Hptr->ctrl_offset = 0x01;[5;17H                        [6;17H/* Switch this to interrupt in next revision */[7;17Hwhile (ptr->ctrl_offset) {}                    [8;17H                           [9;17Htdo = ptr->tdo_offset;[10;17Hmemcpy(&result[byteIndex], &tdo, 4);[11;17H                                    [12;17HbytesLeft -= 4;[13;18HitsLeft -= 32[14;18HyteIndex += 4[15;17H               [16;17Hif (verbose) {[17;17H    printf("LEN : 0x%08x\n", 32);[18;29HTMS : 0x%08x\n", tms);[19;30HDI : 0x%08x\n", tdi[20;31HO : 0x%08x\n", tdo[21;17H}                                 [22;17H [23;13H} else {[24;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[25;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[25;1H[26;1H[K- xvcserver.c 157/304 51%[25;1H[1;17Hptr->tdi_offset = tdi;[2;17Hdsb(st);              [3;17Hptr->ctrl_offset = 0x01;[4;17H                        [5;17H/* Switch this to interrupt in next revision */[6;17Hwhile (ptr->ctrl_offset) {}                    [7;17H                           [8;17Htdo = ptr->tdo_offset;[9;17Hmemcpy(&result[byteIndex], &tdo, 4);[10;17H                                    [11;17HbytesLeft -= 4;[12;18HitsLeft -= 32[13;18HyteIndex += 4[14;17H               [15;17Hif (verbose) {[16;17H    printf("LEN : 0x%08x\n", 32);[17;29HTMS : 0x%08x\n", tms);[18;30HDI : 0x%08x\n", tdi[19;31HO : 0x%08x\n", tdo[20;17H}                                 [21;17H [22;13H} else {[23;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[24;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[25;17H                                                       [25;1H[26;1H[K- xvcserver.c 158/304 51%[25;1H[1;17Hdsb(st);              [2;17Hptr->ctrl_offset = 0x01;[3;17H                        [4;17H/* Switch this to interrupt in next revision */[5;17Hwhile (ptr->ctrl_offset) {}                    [6;17H                           [7;17Htdo = ptr->tdo_offset;[8;17Hmemcpy(&result[byteIndex], &tdo, 4);[9;17H                                    [10;17HbytesLeft -= 4;[11;18HitsLeft -= 32[12;18HyteIndex += 4[13;17H               [14;17Hif (verbose) {[15;17H    printf("LEN : 0x%08x\n", 32);[16;29HTMS : 0x%08x\n", tms);[17;30HDI : 0x%08x\n", tdi[18;31HO : 0x%08x\n", tdo[19;17H}                                 [20;17H [21;13H} else {[22;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[23;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[24;17H                                                       [25;17Hptr->length_offset = bitsLeft;[25;1H[26;1H[K- xvcserver.c 159/304 52%[25;1H[1;17Hptr->ctrl_offset = 0x01;[2;17H                        [3;17H/* Switch this to interrupt in next revision */[4;17Hwhile (ptr->ctrl_offset) {}                    [5;17H                           [6;17Htdo = ptr->tdo_offset;[7;17Hmemcpy(&result[byteIndex], &tdo, 4);[8;17H                                    [9;17HbytesLeft -= 4;[10;18HitsLeft -= 32[11;18HyteIndex += 4[12;17H               [13;17Hif (verbose) {[14;17H    printf("LEN : 0x%08x\n", 32);[15;29HTMS : 0x%08x\n", tms);[16;30HDI : 0x%08x\n", tdi[17;31HO : 0x%08x\n", tdo[18;17H}                                 [19;17H [20;13H} else {[21;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[22;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[23;17H                                                       [24;17Hptr->length_offset = bitsLeft;[25;17Hdsb(st);                      [25;1H[26;1H[K- xvcserver.c 160/304 52%[25;1H[1;17H                        [2;17H/* Switch this to interrupt in next revision */[3;17Hwhile (ptr->ctrl_offset) {}                    [4;17H                           [5;17Htdo = ptr->tdo_offset;[6;17Hmemcpy(&result[byteIndex], &tdo, 4);[7;17H                                    [8;17HbytesLeft -= 4;[9;18HitsLeft -= 32[10;18HyteIndex += 4[11;17H               [12;17Hif (verbose) {[13;17H    printf("LEN : 0x%08x\n", 32);[14;29HTMS : 0x%08x\n", tms);[15;30HDI : 0x%08x\n", tdi[16;31HO : 0x%08x\n", tdo[17;17H}                                 [18;17H [19;13H} else {[20;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[21;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[22;17H                                                       [23;17Hptr->length_offset = bitsLeft;[24;17Hdsb(st);                      [25;17Hptr->tms_offset = tms;[25;1H[26;1H[K- xvcserver.c 161/304 52%[25;1H[1;17H/* Switch this to interrupt in next revision */[2;17Hwhile (ptr->ctrl_offset) {}                    [3;17H                           [4;17Htdo = ptr->tdo_offset;[5;17Hmemcpy(&result[byteIndex], &tdo, 4);[6;17H                                    [7;17HbytesLeft -= 4;[8;18HitsLeft -= 32[9;18HyteIndex += 4[10;17H               [11;17Hif (verbose) {[12;17H    printf("LEN : 0x%08x\n", 32);[13;29HTMS : 0x%08x\n", tms);[14;30HDI : 0x%08x\n", tdi[15;31HO : 0x%08x\n", tdo[16;17H}                                 [17;17H [18;13H} else {[19;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[20;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[21;17H                                                       [22;17Hptr->length_offset = bitsLeft;[23;17Hdsb(st);                      [24;17Hptr->tms_offset = tms;[25;17Hdsb(st);              [25;1H[26;1H[K- xvcserver.c 162/304 53%[25;1H[1;17Hwhile (ptr->ctrl_offset) {}                    [2;17H                           [3;17Htdo = ptr->tdo_offset;[4;17Hmemcpy(&result[byteIndex], &tdo, 4);[5;17H                                    [6;17HbytesLeft -= 4;[7;18HitsLeft -= 32[8;18HyteIndex += 4[9;17H               [10;17Hif (verbose) {[11;17H    printf("LEN : 0x%08x\n", 32);[12;29HTMS : 0x%08x\n", tms);[13;30HDI : 0x%08x\n", tdi[14;31HO : 0x%08x\n", tdo[15;17H}                                 [16;17H [17;13H} else {[18;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[19;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[20;17H                                                       [21;17Hptr->length_offset = bitsLeft;[22;17Hdsb(st);                      [23;17Hptr->tms_offset = tms;[24;17Hdsb(st);              [25;17Hptr->tdi_offset = tdi;[25;1H[26;1H[K- xvcserver.c 163/304 53%[25;1H[1;17H                           [2;17Htdo = ptr->tdo_offset;[3;17Hmemcpy(&result[byteIndex], &tdo, 4);[4;17H                                    [5;17HbytesLeft -= 4;[6;18HitsLeft -= 32[7;18HyteIndex += 4[8;17H               [9;17Hif (verbose) {[10;17H    printf("LEN : 0x%08x\n", 32);[11;29HTMS : 0x%08x\n", tms);[12;30HDI : 0x%08x\n", tdi[13;31HO : 0x%08x\n", tdo[14;17H}                                 [15;17H [16;13H} else {[17;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[18;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[19;17H                                                       [20;17Hptr->length_offset = bitsLeft;[21;17Hdsb(st);                      [22;17Hptr->tms_offset = tms;[23;17Hdsb(st);              [24;17Hptr->tdi_offset = tdi;[25;17Hdsb(st);              [25;1H[26;1H[K- xvcserver.c 164/304 53%[25;1H[1;17Htdo = ptr->tdo_offset;[2;17Hmemcpy(&result[byteIndex], &tdo, 4);[3;17H                                    [4;17HbytesLeft -= 4;[5;18HitsLeft -= 32[6;18HyteIndex += 4[7;17H               [8;17Hif (verbose) {[9;17H    printf("LEN : 0x%08x\n", 32);[10;29HTMS : 0x%08x\n", tms);[11;30HDI : 0x%08x\n", tdi[12;31HO : 0x%08x\n", tdo[13;17H}                                 [14;17H [15;13H} else {[16;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[17;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[18;17H                                                       [19;17Hptr->length_offset = bitsLeft;[20;17Hdsb(st);                      [21;17Hptr->tms_offset = tms;[22;17Hdsb(st);              [23;17Hptr->tdi_offset = tdi;[24;17Hdsb(st);              [25;17Hptr->ctrl_offset = 0x01;[25;1H[26;1H[K- xvcserver.c 165/304 54%[25;1H[1;17Hmemcpy(&result[byteIndex], &tdo, 4);[2;17H                                    [3;17HbytesLeft -= 4;[4;18HitsLeft -= 32[5;18HyteIndex += 4[6;17H               [7;17Hif (verbose) {[8;17H    printf("LEN : 0x%08x\n", 32);[9;29HTMS : 0x%08x\n", tms);[10;30HDI : 0x%08x\n", tdi[11;31HO : 0x%08x\n", tdo[12;17H}                                 [13;17H [14;13H} else {[15;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[16;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[17;17H                                                       [18;17Hptr->length_offset = bitsLeft;[19;17Hdsb(st);                      [20;17Hptr->tms_offset = tms;[21;17Hdsb(st);              [22;17Hptr->tdi_offset = tdi;[23;17Hdsb(st);              [24;17Hptr->ctrl_offset = 0x01;[25;17H/* Switch this to interrupt in next revision */[25;1H[26;1H[K- xvcserver.c 166/304 54%[25;1H[1;17H                                    [2;17HbytesLeft -= 4;[3;18HitsLeft -= 32[4;18HyteIndex += 4[5;17H               [6;17Hif (verbose) {[7;17H    printf("LEN : 0x%08x\n", 32);[8;29HTMS : 0x%08x\n", tms);[9;30HDI : 0x%08x\n", tdi[10;31HO : 0x%08x\n", tdo[11;17H}                                 [12;17H [13;13H} else {[14;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[15;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[16;17H                                                       [17;17Hptr->length_offset = bitsLeft;[18;17Hdsb(st);                      [19;17Hptr->tms_offset = tms;[20;17Hdsb(st);              [21;17Hptr->tdi_offset = tdi;[22;17Hdsb(st);              [23;17Hptr->ctrl_offset = 0x01;[24;17H/* Switch this to interrupt in next revision */[25;17Hwhile (ptr->ctrl_offset) {}                    [25;1H[26;1H[K- xvcserver.c 167/304 54%[25;1H[1;17HbytesLeft -= 4;[2;18HitsLeft -= 32[3;18HyteIndex += 4[4;17H               [5;17Hif (verbose) {[6;17H    printf("LEN : 0x%08x\n", 32);[7;29HTMS : 0x%08x\n", tms);[8;30HDI : 0x%08x\n", tdi[9;31HO : 0x%08x\n", tdo[10;17H}                                 [11;17H [12;13H} else {[13;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[14;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[15;17H                                                       [16;17Hptr->length_offset = bitsLeft;[17;17Hdsb(st);                      [18;17Hptr->tms_offset = tms;[19;17Hdsb(st);              [20;17Hptr->tdi_offset = tdi;[21;17Hdsb(st);              [22;17Hptr->ctrl_offset = 0x01;[23;17H/* Switch this to interrupt in next revision */[24;17Hwhile (ptr->ctrl_offset) {}                    [25;17H                           [25;1H[26;1H[K- xvcserver.c 168/304 55%[25;1H[1;18HitsLeft -= 32[2;18HyteIndex += 4[3;17H               [4;17Hif (verbose) {[5;17H    printf("LEN : 0x%08x\n", 32);[6;29HTMS : 0x%08x\n", tms);[7;30HDI : 0x%08x\n", tdi[8;31HO : 0x%08x\n", tdo[9;17H}                                 [10;17H [11;13H} else {[12;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[13;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[14;17H                                                       [15;17Hptr->length_offset = bitsLeft;[16;17Hdsb(st);                      [17;17Hptr->tms_offset = tms;[18;17Hdsb(st);              [19;17Hptr->tdi_offset = tdi;[20;17Hdsb(st);              [21;17Hptr->ctrl_offset = 0x01;[22;17H/* Switch this to interrupt in next revision */[23;17Hwhile (ptr->ctrl_offset) {}                    [24;17H                           [25;17Htdo = ptr->tdo_offset;[25;1H[26;1H[K- xvcserver.c 169/304 55%[25;1H[1;18HyteIndex += 4[2;17H               [3;17Hif (verbose) {[4;17H    printf("LEN : 0x%08x\n", 32);[5;29HTMS : 0x%08x\n", tms);[6;30HDI : 0x%08x\n", tdi[7;31HO : 0x%08x\n", tdo[8;17H}                                 [9;17H [10;13H} else {[11;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[12;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[13;17H                                                       [14;17Hptr->length_offset = bitsLeft;[15;17Hdsb(st);                      [16;17Hptr->tms_offset = tms;[17;17Hdsb(st);              [18;17Hptr->tdi_offset = tdi;[19;17Hdsb(st);              [20;17Hptr->ctrl_offset = 0x01;[21;17H/* Switch this to interrupt in next revision */[22;17Hwhile (ptr->ctrl_offset) {}                    [23;17H                           [24;17Htdo = ptr->tdo_offset;[25;17H                      [25;1H[26;1H[K- xvcserver.c 170/304 55%[25;1H[1;17H               [2;17Hif (verbose) {[3;17H    printf("LEN : 0x%08x\n", 32);[4;29HTMS : 0x%08x\n", tms);[5;30HDI : 0x%08x\n", tdi[6;31HO : 0x%08x\n", tdo[7;17H}                                 [8;17H [9;13H} else {[10;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[11;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[12;17H                                                       [13;17Hptr->length_offset = bitsLeft;[14;17Hdsb(st);                      [15;17Hptr->tms_offset = tms;[16;17Hdsb(st);              [17;17Hptr->tdi_offset = tdi;[18;17Hdsb(st);              [19;17Hptr->ctrl_offset = 0x01;[20;17H/* Switch this to interrupt in next revision */[21;17Hwhile (ptr->ctrl_offset) {}                    [22;17H                           [23;17Htdo = ptr->tdo_offset;[24;17H                      [25;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[25;1H[26;1H[K- xvcserver.c 171/304 56%[25;1H[1;17Hif (verbose) {[2;17H    printf("LEN : 0x%08x\n", 32);[3;29HTMS : 0x%08x\n", tms);[4;30HDI : 0x%08x\n", tdi[5;31HO : 0x%08x\n", tdo[6;17H}                                 [7;17H [8;13H} else {[9;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[10;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[11;17H                                                       [12;17Hptr->length_offset = bitsLeft;[13;17Hdsb(st);                      [14;17Hptr->tms_offset = tms;[15;17Hdsb(st);              [16;17Hptr->tdi_offset = tdi;[17;17Hdsb(st);              [18;17Hptr->ctrl_offset = 0x01;[19;17H/* Switch this to interrupt in next revision */[20;17Hwhile (ptr->ctrl_offset) {}                    [21;17H                           [22;17Htdo = ptr->tdo_offset;[23;17H                      [24;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[25;17H                                            [25;1H[26;1H[K- xvcserver.c 172/304 56%[25;1H[1;17H    printf("LEN : 0x%08x\n", 32);[2;29HTMS : 0x%08x\n", tms);[3;30HDI : 0x%08x\n", tdi[4;31HO : 0x%08x\n", tdo[5;17H}                                 [6;17H [7;13H} else {[8;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[9;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[10;17H                                                       [11;17Hptr->length_offset = bitsLeft;[12;17Hdsb(st);                      [13;17Hptr->tms_offset = tms;[14;17Hdsb(st);              [15;17Hptr->tdi_offset = tdi;[16;17Hdsb(st);              [17;17Hptr->ctrl_offset = 0x01;[18;17H/* Switch this to interrupt in next revision */[19;17Hwhile (ptr->ctrl_offset) {}                    [20;17H                           [21;17Htdo = ptr->tdo_offset;[22;17H                      [23;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[24;17H                                            [25;17Hif (verbose) {[25;1H[26;1H[K- xvcserver.c 173/304 56%[25;1H[1;29HTMS : 0x%08x\n", tms);[2;30HDI : 0x%08x\n", tdi[3;31HO : 0x%08x\n", tdo[4;17H}                                 [5;17H [6;13H} else {[7;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[8;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[9;17H                                                       [10;17Hptr->length_offset = bitsLeft;[11;17Hdsb(st);                      [12;17Hptr->tms_offset = tms;[13;17Hdsb(st);              [14;17Hptr->tdi_offset = tdi;[15;17Hdsb(st);              [16;17Hptr->ctrl_offset = 0x01;[17;17H/* Switch this to interrupt in next revision */[18;17Hwhile (ptr->ctrl_offset) {}                    [19;17H                           [20;17Htdo = ptr->tdo_offset;[21;17H                      [22;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[23;17H                                            [24;17Hif (verbose) {[25;17H    printf("LEN : 0x%08x\n", bitsLeft);[25;1H[26;1H[K- xvcserver.c 174/304 57%[25;1H[1;30HDI : 0x%08x\n", tdi[2;31HO : 0x%08x\n", tdo[3;17H}                                 [4;17H [5;13H} else {[6;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[7;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[8;17H                                                       [9;17Hptr->length_offset = bitsLeft;[10;17Hdsb(st);                      [11;17Hptr->tms_offset = tms;[12;17Hdsb(st);              [13;17Hptr->tdi_offset = tdi;[14;17Hdsb(st);              [15;17Hptr->ctrl_offset = 0x01;[16;17H/* Switch this to interrupt in next revision */[17;17Hwhile (ptr->ctrl_offset) {}                    [18;17H                           [19;17Htdo = ptr->tdo_offset;[20;17H                      [21;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[22;17H                                            [23;17Hif (verbose) {[24;17H    printf("LEN : 0x%08x\n", bitsLeft);[25;29HTMS : 0x%08x\n", tms);     [25;1H[26;1H[K- xvcserver.c 175/304 57%[25;1H[1;31HO : 0x%08x\n", tdo[2;17H}                                 [3;17H [4;13H} else {[5;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[6;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[7;17H                                                       [8;17Hptr->length_offset = bitsLeft;[9;17Hdsb(st);                      [10;17Hptr->tms_offset = tms;[11;17Hdsb(st);              [12;17Hptr->tdi_offset = tdi;[13;17Hdsb(st);              [14;17Hptr->ctrl_offset = 0x01;[15;17H/* Switch this to interrupt in next revision */[16;17Hwhile (ptr->ctrl_offset) {}                    [17;17H                           [18;17Htdo = ptr->tdo_offset;[19;17H                      [20;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[21;17H                                            [22;17Hif (verbose) {[23;17H    printf("LEN : 0x%08x\n", bitsLeft);[24;29HTMS : 0x%08x\n", tms);     [25;30HDI : 0x%08x\n", tdi[25;1H[26;1H[K- xvcserver.c 176/304 57%[25;1H[1;17H}                                 [2;17H [3;13H} else {[4;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[5;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[6;17H                                                       [7;17Hptr->length_offset = bitsLeft;[8;17Hdsb(st);                      [9;17Hptr->tms_offset = tms;[10;17Hdsb(st);              [11;17Hptr->tdi_offset = tdi;[12;17Hdsb(st);              [13;17Hptr->ctrl_offset = 0x01;[14;17H/* Switch this to interrupt in next revision */[15;17Hwhile (ptr->ctrl_offset) {}                    [16;17H                           [17;17Htdo = ptr->tdo_offset;[18;17H                      [19;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[20;17H                                            [21;17Hif (verbose) {[22;17H    printf("LEN : 0x%08x\n", bitsLeft);[23;29HTMS : 0x%08x\n", tms);     [24;30HDI : 0x%08x\n", tdi[25;31HO : 0x%08x\n", tdo[25;1H[26;1H[K- xvcserver.c 177/304 58%[25;1H[1;17H [2;13H} else {[3;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[4;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[5;17H                                                       [6;17Hptr->length_offset = bitsLeft;[7;17Hdsb(st);                      [8;17Hptr->tms_offset = tms;[9;17Hdsb(st);              [10;17Hptr->tdi_offset = tdi;[11;17Hdsb(st);              [12;17Hptr->ctrl_offset = 0x01;[13;17H/* Switch this to interrupt in next revision */[14;17Hwhile (ptr->ctrl_offset) {}                    [15;17H                           [16;17Htdo = ptr->tdo_offset;[17;17H                      [18;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[19;17H                                            [20;17Hif (verbose) {[21;17H    printf("LEN : 0x%08x\n", bitsLeft);[22;29HTMS : 0x%08x\n", tms);     [23;30HDI : 0x%08x\n", tdi[24;31HO : 0x%08x\n", tdo[25;17H}                                 [25;1H[26;1H[K- xvcserver.c 178/304 58%[25;1H[1;13H} else {[2;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[3;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[4;17H                                                       [5;17Hptr->length_offset = bitsLeft;[6;17Hdsb(st);                      [7;17Hptr->tms_offset = tms;[8;17Hdsb(st);              [9;17Hptr->tdi_offset = tdi;[10;17Hdsb(st);              [11;17Hptr->ctrl_offset = 0x01;[12;17H/* Switch this to interrupt in next revision */[13;17Hwhile (ptr->ctrl_offset) {}                    [14;17H                           [15;17Htdo = ptr->tdo_offset;[16;17H                      [17;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[18;17H                                            [19;17Hif (verbose) {[20;17H    printf("LEN : 0x%08x\n", bitsLeft);[21;29HTMS : 0x%08x\n", tms);     [22;30HDI : 0x%08x\n", tdi[23;31HO : 0x%08x\n", tdo[24;17H}                                 [25;17Hbreak;[25;1H[26;1H[K- xvcserver.c 179/304 58%[25;1H[1;13H    memcpy(&tms, &buffer[byteIndex], bytesLeft);[2;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[3;17H                                                       [4;17Hptr->length_offset = bitsLeft;[5;17Hdsb(st);                      [6;17Hptr->tms_offset = tms;[7;17Hdsb(st);              [8;17Hptr->tdi_offset = tdi;[9;17Hdsb(st);              [10;17Hptr->ctrl_offset = 0x01;[11;17H/* Switch this to interrupt in next revision */[12;17Hwhile (ptr->ctrl_offset) {}                    [13;17H                           [14;17Htdo = ptr->tdo_offset;[15;17H                      [16;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[17;17H                                            [18;17Hif (verbose) {[19;17H    printf("LEN : 0x%08x\n", bitsLeft);[20;29HTMS : 0x%08x\n", tms);     [21;30HDI : 0x%08x\n", tdi[22;31HO : 0x%08x\n", tdo[23;17H}                                 [24;17Hbreak;[25;13H}         [25;1H[26;1H[K- xvcserver.c 180/304 59%[25;1H[1;26Hdi, &buffer[byteIndex + nr_bytes], bytesLeft);[2;17H                                                       [3;17Hptr->length_offset = bitsLeft;[4;17Hdsb(st);                      [5;17Hptr->tms_offset = tms;[6;17Hdsb(st);              [7;17Hptr->tdi_offset = tdi;[8;17Hdsb(st);              [9;17Hptr->ctrl_offset = 0x01;[10;17H/* Switch this to interrupt in next revision */[11;17Hwhile (ptr->ctrl_offset) {}                    [12;17H                           [13;17Htdo = ptr->tdo_offset;[14;17H                      [15;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[16;17H                                            [17;17Hif (verbose) {[18;17H    printf("LEN : 0x%08x\n", bitsLeft);[19;29HTMS : 0x%08x\n", tms);     [20;30HDI : 0x%08x\n", tdi[21;31HO : 0x%08x\n", tdo[22;17H}                                 [23;17Hbreak;[24;13H}         [25;9H}    [25;1H[26;1H[K- xvcserver.c 181/304 59%[25;1H[1;17H                                                       [2;17Hptr->length_offset = bitsLeft;[3;17Hdsb(st);                      [4;17Hptr->tms_offset = tms;[5;17Hdsb(st);              [6;17Hptr->tdi_offset = tdi;[7;17Hdsb(st);              [8;17Hptr->ctrl_offset = 0x01;[9;17H/* Switch this to interrupt in next revision */[10;17Hwhile (ptr->ctrl_offset) {}                    [11;17H                           [12;17Htdo = ptr->tdo_offset;[13;17H                      [14;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[15;17H                                            [16;17Hif (verbose) {[17;17H    printf("LEN : 0x%08x\n", bitsLeft);[18;29HTMS : 0x%08x\n", tms);     [19;30HDI : 0x%08x\n", tdi[20;31HO : 0x%08x\n", tdo[21;17H}                                 [22;17Hbreak;[23;13H}         [24;9H}    [25;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[25;1H[26;1H[K- xvcserver.c 182/304 59%[25;1H[1;17Hptr->length_offset = bitsLeft;[2;17Hdsb(st);                      [3;17Hptr->tms_offset = tms;[4;17Hdsb(st);              [5;17Hptr->tdi_offset = tdi;[6;17Hdsb(st);              [7;17Hptr->ctrl_offset = 0x01;[8;17H/* Switch this to interrupt in next revision */[9;17Hwhile (ptr->ctrl_offset) {}                    [10;17H                           [11;17Htdo = ptr->tdo_offset;[12;17H                      [13;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[14;17H                                            [15;17Hif (verbose) {[16;17H    printf("LEN : 0x%08x\n", bitsLeft);[17;29HTMS : 0x%08x\n", tms);     [18;30HDI : 0x%08x\n", tdi[19;31HO : 0x%08x\n", tdo[20;17H}                                 [21;17Hbreak;[22;13H}         [23;9H}    [24;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[25;9H    perror("write");                          [25;1H[26;1H[K- xvcserver.c 183/304 60%[25;1H[1;17Hdsb(st);                      [2;17Hptr->tms_offset = tms;[3;17Hdsb(st);              [4;17Hptr->tdi_offset = tdi;[5;17Hdsb(st);              [6;17Hptr->ctrl_offset = 0x01;[7;17H/* Switch this to interrupt in next revision */[8;17Hwhile (ptr->ctrl_offset) {}                    [9;17H                           [10;17Htdo = ptr->tdo_offset;[11;17H                      [12;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[13;17H                                            [14;17Hif (verbose) {[15;17H    printf("LEN : 0x%08x\n", bitsLeft);[16;29HTMS : 0x%08x\n", tms);     [17;30HDI : 0x%08x\n", tdi[18;31HO : 0x%08x\n", tdo[19;17H}                                 [20;17Hbreak;[21;13H}         [22;9H}    [23;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[24;9H    perror("write");                          [25;13Hreturn 1;       [25;1H[26;1H[K- xvcserver.c 184/304 60%[25;1H[1;17Hptr->tms_offset = tms;[2;17Hdsb(st);              [3;17Hptr->tdi_offset = tdi;[4;17Hdsb(st);              [5;17Hptr->ctrl_offset = 0x01;[6;17H/* Switch this to interrupt in next revision */[7;17Hwhile (ptr->ctrl_offset) {}                    [8;17H                           [9;17Htdo = ptr->tdo_offset;[10;17H                      [11;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[12;17H                                            [13;17Hif (verbose) {[14;17H    printf("LEN : 0x%08x\n", bitsLeft);[15;29HTMS : 0x%08x\n", tms);     [16;30HDI : 0x%08x\n", tdi[17;31HO : 0x%08x\n", tdo[18;17H}                                 [19;17Hbreak;[20;13H}         [21;9H}    [22;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[23;9H    perror("write");                          [24;13Hreturn 1;       [25;9H}            [25;1H[26;1H[K- xvcserver.c 185/304 60%[25;1H[1;17Hdsb(st);              [2;17Hptr->tdi_offset = tdi;[3;17Hdsb(st);              [4;17Hptr->ctrl_offset = 0x01;[5;17H/* Switch this to interrupt in next revision */[6;17Hwhile (ptr->ctrl_offset) {}                    [7;17H                           [8;17Htdo = ptr->tdo_offset;[9;17H                      [10;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[11;17H                                            [12;17Hif (verbose) {[13;17H    printf("LEN : 0x%08x\n", bitsLeft);[14;29HTMS : 0x%08x\n", tms);     [15;30HDI : 0x%08x\n", tdi[16;31HO : 0x%08x\n", tdo[17;17H}                                 [18;17Hbreak;[19;13H}         [20;9H}    [21;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[22;9H    perror("write");                          [23;13Hreturn 1;       [24;9H}            [25;9H [25;1H[26;1H[K- xvcserver.c 186/304 61%[25;1H[1;17Hptr->tdi_offset = tdi;[2;17Hdsb(st);              [3;17Hptr->ctrl_offset = 0x01;[4;17H/* Switch this to interrupt in next revision */[5;17Hwhile (ptr->ctrl_offset) {}                    [6;17H                           [7;17Htdo = ptr->tdo_offset;[8;17H                      [9;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[10;17H                                            [11;17Hif (verbose) {[12;17H    printf("LEN : 0x%08x\n", bitsLeft);[13;29HTMS : 0x%08x\n", tms);     [14;30HDI : 0x%08x\n", tdi[15;31HO : 0x%08x\n", tdo[16;17H}                                 [17;17Hbreak;[18;13H}         [19;9H}    [20;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[21;9H    perror("write");                          [22;13Hreturn 1;       [23;9H}            [24;9H [25;5H} while (1);[25;1H[26;1H[K- xvcserver.c 187/304 61%[25;1H[1;17Hdsb(st);              [2;17Hptr->ctrl_offset = 0x01;[3;17H/* Switch this to interrupt in next revision */[4;17Hwhile (ptr->ctrl_offset) {}                    [5;17H                           [6;17Htdo = ptr->tdo_offset;[7;17H                      [8;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[9;17H                                            [10;17Hif (verbose) {[11;17H    printf("LEN : 0x%08x\n", bitsLeft);[12;29HTMS : 0x%08x\n", tms);     [13;30HDI : 0x%08x\n", tdi[14;31HO : 0x%08x\n", tdo[15;17H}                                 [16;17Hbreak;[17;13H}         [18;9H}    [19;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[20;9H    perror("write");                          [21;13Hreturn 1;       [22;9H}            [23;9H [24;5H} while (1);[25;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[25;1H[26;1H[K- xvcserver.c 188/304 61%[25;1H[1;17Hptr->ctrl_offset = 0x01;[2;17H/* Switch this to interrupt in next revision */[3;17Hwhile (ptr->ctrl_offset) {}                    [4;17H                           [5;17Htdo = ptr->tdo_offset;[6;17H                      [7;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[8;17H                                            [9;17Hif (verbose) {[10;17H    printf("LEN : 0x%08x\n", bitsLeft);[11;29HTMS : 0x%08x\n", tms);     [12;30HDI : 0x%08x\n", tdi[13;31HO : 0x%08x\n", tdo[14;17H}                                 [15;17Hbreak;[16;13H}         [17;9H}    [18;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[19;9H    perror("write");                          [20;13Hreturn 1;       [21;9H}            [22;9H [23;5H} while (1);[24;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[25;5Hreturn 0;                                                                [25;1H[26;1H[K- xvcserver.c 189/304 62%[25;1H[1;17H/* Switch this to interrupt in next revision */[2;17Hwhile (ptr->ctrl_offset) {}                    [3;17H                           [4;17Htdo = ptr->tdo_offset;[5;17H                      [6;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[7;17H                                            [8;17Hif (verbose) {[9;17H    printf("LEN : 0x%08x\n", bitsLeft);[10;29HTMS : 0x%08x\n", tms);     [11;30HDI : 0x%08x\n", tdi[12;31HO : 0x%08x\n", tdo[13;17H}                                 [14;17Hbreak;[15;13H}         [16;9H}    [17;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[18;9H    perror("write");                          [19;13Hreturn 1;       [20;9H}            [21;9H [22;5H} while (1);[23;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[24;5Hreturn 0;                                                                [25;1H}            [25;1H[26;1H[K- xvcserver.c 190/304 62%[25;1H[1;17Hwhile (ptr->ctrl_offset) {}                    [2;17H                           [3;17Htdo = ptr->tdo_offset;[4;17H                      [5;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[6;17H                                            [7;17Hif (verbose) {[8;17H    printf("LEN : 0x%08x\n", bitsLeft);[9;29HTMS : 0x%08x\n", tms);     [10;30HDI : 0x%08x\n", tdi[11;31HO : 0x%08x\n", tdo[12;17H}                                 [13;17Hbreak;[14;13H}         [15;9H}    [16;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[17;9H    perror("write");                          [18;13Hreturn 1;       [19;9H}            [20;9H [21;5H} while (1);[22;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[23;5Hreturn 0;                                                                [24;1H}            [25;1H [25;1H[26;1H[K- xvcserver.c 191/304 62%[25;1H[1;17H                           [2;17Htdo = ptr->tdo_offset;[3;17H                      [4;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[5;17H                                            [6;17Hif (verbose) {[7;17H    printf("LEN : 0x%08x\n", bitsLeft);[8;29HTMS : 0x%08x\n", tms);     [9;30HDI : 0x%08x\n", tdi[10;31HO : 0x%08x\n", tdo[11;17H}                                 [12;17Hbreak;[13;13H}         [14;9H}    [15;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[16;9H    perror("write");                          [17;13Hreturn 1;       [18;9H}            [19;9H [20;5H} while (1);[21;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[22;5Hreturn 0;                                                                [23;1H}            [24;1H [25;1Hint main(int argc, char **argv) {[25;1H[26;1H[K- xvcserver.c 192/304 63%[25;1H[1;17Htdo = ptr->tdo_offset;[2;17H                      [3;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[4;17H                                            [5;17Hif (verbose) {[6;17H    printf("LEN : 0x%08x\n", bitsLeft);[7;29HTMS : 0x%08x\n", tms);     [8;30HDI : 0x%08x\n", tdi[9;31HO : 0x%08x\n", tdo[10;17H}                                 [11;17Hbreak;[12;13H}         [13;9H}    [14;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[15;9H    perror("write");                          [16;13Hreturn 1;       [17;9H}            [18;9H [19;5H} while (1);[20;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[21;5Hreturn 0;                                                                [22;1H}            [23;1H [24;1Hint main(int argc, char **argv) {[25;1H    int i;                       [25;1H[26;1H[K- xvcserver.c 193/304 63%[25;1H[1;17H                      [2;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[3;17H                                            [4;17Hif (verbose) {[5;17H    printf("LEN : 0x%08x\n", bitsLeft);[6;29HTMS : 0x%08x\n", tms);     [7;30HDI : 0x%08x\n", tdi[8;31HO : 0x%08x\n", tdo[9;17H}                                 [10;17Hbreak;[11;13H}         [12;9H}    [13;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[14;9H    perror("write");                          [15;13Hreturn 1;       [16;9H}            [17;9H [18;5H} while (1);[19;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[20;5Hreturn 0;                                                                [21;1H}            [22;1H [23;1Hint main(int argc, char **argv) {[24;1H    int i;                       [25;9Hs[25;1H[26;1H[K- xvcserver.c 194/304 63%[25;1H[1;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[2;17H                                            [3;17Hif (verbose) {[4;17H    printf("LEN : 0x%08x\n", bitsLeft);[5;29HTMS : 0x%08x\n", tms);     [6;30HDI : 0x%08x\n", tdi[7;31HO : 0x%08x\n", tdo[8;17H}                                 [9;17Hbreak;[10;13H}         [11;9H}    [12;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[13;9H    perror("write");                          [14;13Hreturn 1;       [15;9H}            [16;9H [17;5H} while (1);[18;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[19;5Hreturn 0;                                                                [20;1H}            [21;1H [22;1Hint main(int argc, char **argv) {[23;1H    int i;                       [24;9Hs[25;9Hc[25;1H[26;1H[K- xvcserver.c 195/304 64%[25;1H[1;17H                                            [2;17Hif (verbose) {[3;17H    printf("LEN : 0x%08x\n", bitsLeft);[4;29HTMS : 0x%08x\n", tms);     [5;30HDI : 0x%08x\n", tdi[6;31HO : 0x%08x\n", tdo[7;17H}                                 [8;17Hbreak;[9;13H}         [10;9H}    [11;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[12;9H    perror("write");                          [13;13Hreturn 1;       [14;9H}            [15;9H [16;5H} while (1);[17;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[18;5Hreturn 0;                                                                [19;1H}            [20;1H [21;1Hint main(int argc, char **argv) {[22;1H    int i;                       [23;9Hs[24;9Hc[25;9Hfd_uio;[25;1H[26;1H[K- xvcserver.c 196/304 64%[25;1H[1;17Hif (verbose) {[2;17H    printf("LEN : 0x%08x\n", bitsLeft);[3;29HTMS : 0x%08x\n", tms);     [4;30HDI : 0x%08x\n", tdi[5;31HO : 0x%08x\n", tdo[6;17H}                                 [7;17Hbreak;[8;13H}         [9;9H}    [10;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[11;9H    perror("write");                          [12;13Hreturn 1;       [13;9H}            [14;9H [15;5H} while (1);[16;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[17;5Hreturn 0;                                                                [18;1H}            [19;1H [20;1Hint main(int argc, char **argv) {[21;1H    int i;                       [22;9Hs[23;9Hc[24;9Hfd_uio;[25;5H           [25;1H[26;1H[K- xvcserver.c 197/304 64%[25;1H[1;17H    printf("LEN : 0x%08x\n", bitsLeft);[2;29HTMS : 0x%08x\n", tms);     [3;30HDI : 0x%08x\n", tdi[4;31HO : 0x%08x\n", tdo[5;17H}                                 [6;17Hbreak;[7;13H}         [8;9H}    [9;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[10;9H    perror("write");                          [11;13Hreturn 1;       [12;9H}            [13;9H [14;5H} while (1);[15;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[16;5Hreturn 0;                                                                [17;1H}            [18;1H [19;1Hint main(int argc, char **argv) {[20;1H    int i;                       [21;9Hs[22;9Hc[23;9Hfd_uio;[24;5H           [25;5Hstruct sockaddr_in address;[25;1H[26;1H[K- xvcserver.c 198/304 65%[25;1H[1;29HTMS : 0x%08x\n", tms);     [2;30HDI : 0x%08x\n", tdi[3;31HO : 0x%08x\n", tdo[4;17H}                                 [5;17Hbreak;[6;13H}         [7;9H}    [8;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[9;9H    perror("write");                          [10;13Hreturn 1;       [11;9H}            [12;9H [13;5H} while (1);[14;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[15;5Hreturn 0;                                                                [16;1H}            [17;1H [18;1Hint main(int argc, char **argv) {[19;1H    int i;                       [20;9Hs[21;9Hc[22;9Hfd_uio;[23;5H           [24;5Hstruct sockaddr_in address;[25;5H                           [25;1H[26;1H[K- xvcserver.c 199/304 65%[25;1H[1;30HDI : 0x%08x\n", tdi[2;31HO : 0x%08x\n", tdo[3;17H}                                 [4;17Hbreak;[5;13H}         [6;9H}    [7;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[8;9H    perror("write");                          [9;13Hreturn 1;       [10;9H}            [11;9H [12;5H} while (1);[13;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[14;5Hreturn 0;                                                                [15;1H}            [16;1H [17;1Hint main(int argc, char **argv) {[18;1H    int i;                       [19;9Hs[20;9Hc[21;9Hfd_uio;[22;5H           [23;5Hstruct sockaddr_in address;[24;5H                           [25;5Hopterr = 0;[25;1H[26;1H[K- xvcserver.c 200/304 65%[25;1H[1;31HO : 0x%08x\n", tdo[2;17H}                                 [3;17Hbreak;[4;13H}         [5;9H}    [6;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[7;9H    perror("write");                          [8;13Hreturn 1;       [9;9H}            [10;9H [11;5H} while (1);[12;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[13;5Hreturn 0;                                                                [14;1H}            [15;1H [16;1Hint main(int argc, char **argv) {[17;1H    int i;                       [18;9Hs[19;9Hc[20;9Hfd_uio;[21;5H           [22;5Hstruct sockaddr_in address;[23;5H                           [24;5Hopterr = 0;[25;5H           [25;1H[26;1H[K- xvcserver.c 201/304 66%[25;1H[1;17H}                                 [2;17Hbreak;[3;13H}         [4;9H}    [5;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[6;9H    perror("write");                          [7;13Hreturn 1;       [8;9H}            [9;9H [10;5H} while (1);[11;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[12;5Hreturn 0;                                                                [13;1H}            [14;1H [15;1Hint main(int argc, char **argv) {[16;1H    int i;                       [17;9Hs[18;9Hc[19;9Hfd_uio;[20;5H           [21;5Hstruct sockaddr_in address;[22;5H                           [23;5Hopterr = 0;[24;5H           [25;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[25;1H[26;1H[K- xvcserver.c 202/304 66%[25;1H[1;17Hbreak;[2;13H}         [3;9H}    [4;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[5;9H    perror("write");                          [6;13Hreturn 1;       [7;9H}            [8;9H [9;5H} while (1);[10;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[11;5Hreturn 0;                                                                [12;1H}            [13;1H [14;1Hint main(int argc, char **argv) {[15;1H    int i;                       [16;9Hs[17;9Hc[18;9Hfd_uio;[19;5H           [20;5Hstruct sockaddr_in address;[21;5H                           [22;5Hopterr = 0;[23;5H           [24;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[25;5H        case 'v': verbose = 1; break;                   [25;1H[26;1H[K- xvcserver.c 203/304 66%[25;1H[1;13H}         [2;9H}    [3;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[4;9H    perror("write");                          [5;13Hreturn 1;       [6;9H}            [7;9H [8;5H} while (1);[9;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[10;5Hreturn 0;                                                                [11;1H}            [12;1H [13;1Hint main(int argc, char **argv) {[14;1H    int i;                       [15;9Hs[16;9Hc[17;9Hfd_uio;[18;5H           [19;5Hstruct sockaddr_in address;[20;5H                           [21;5Hopterr = 0;[22;5H           [23;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[24;5H        case 'v': verbose = 1; break;                   [25;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[25;1H[26;1H[K- xvcserver.c 204/304 67%[25;1H[1;9H}    [2;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[3;9H    perror("write");                          [4;13Hreturn 1;       [5;9H}            [6;9H [7;5H} while (1);[8;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[9;5Hreturn 0;                                                                [10;1H}            [11;1H [12;1Hint main(int argc, char **argv) {[13;1H    int i;                       [14;9Hs[15;9Hc[16;9Hfd_uio;[17;5H           [18;5Hstruct sockaddr_in address;[19;5H                           [20;5Hopterr = 0;[21;5H           [22;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[23;5H        case 'v': verbose = 1; break;                   [24;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[25;9H}                                                                  [25;1H[26;1H[K- xvcserver.c 205/304 67%[25;1H[1;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[2;9H    perror("write");                          [3;13Hreturn 1;       [4;9H}            [5;9H [6;5H} while (1);[7;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[8;5Hreturn 0;                                                                [9;1H}            [10;1H [11;1Hint main(int argc, char **argv) {[12;1H    int i;                       [13;9Hs[14;9Hc[15;9Hfd_uio;[16;5H           [17;5Hstruct sockaddr_in address;[18;5H                           [19;5Hopterr = 0;[20;5H           [21;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[22;5H        case 'v': verbose = 1; break;                   [23;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[24;9H}                                                                  [25;9H [25;1H[26;1H[K- xvcserver.c 206/304 67%[25;1H[1;9H    perror("write");                          [2;13Hreturn 1;       [3;9H}            [4;9H [5;5H} while (1);[6;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[7;5Hreturn 0;                                                                [8;1H}            [9;1H [10;1Hint main(int argc, char **argv) {[11;1H    int i;                       [12;9Hs[13;9Hc[14;9Hfd_uio;[15;5H           [16;5Hstruct sockaddr_in address;[17;5H                           [18;5Hopterr = 0;[19;5H           [20;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[21;5H        case 'v': verbose = 1; break;                   [22;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[23;9H}                                                                  [24;9H [25;5H// https://support.xilinx.com/s/article/974879?language=en_US[25;1H[26;1H[K- xvcserver.c 207/304 68%[25;1H[1;13Hreturn 1;       [2;9H}            [3;9H [4;5H} while (1);[5;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[6;5Hreturn 0;                                                                [7;1H}            [8;1H [9;1Hint main(int argc, char **argv) {[10;1H    int i;                       [11;9Hs[12;9Hc[13;9Hfd_uio;[14;5H           [15;5Hstruct sockaddr_in address;[16;5H                           [17;5Hopterr = 0;[18;5H           [19;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[20;5H        case 'v': verbose = 1; break;                   [21;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[22;9H}                                                                  [23;9H [24;5H// https://support.xilinx.com/s/article/974879?language=en_US[25;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[25;1H[26;1H[K- xvcserver.c 208/304 68%[25;1H[1;9H}            [2;9H [3;5H} while (1);[4;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[5;5Hreturn 0;                                                                [6;1H}            [7;1H [8;1Hint main(int argc, char **argv) {[9;1H    int i;                       [10;9Hs[11;9Hc[12;9Hfd_uio;[13;5H           [14;5Hstruct sockaddr_in address;[15;5H                           [16;5Hopterr = 0;[17;5H           [18;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[19;5H        case 'v': verbose = 1; break;                   [20;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[21;9H}                                                                  [22;9H [23;5H// https://support.xilinx.com/s/article/974879?language=en_US[24;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[25;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [25;1H[26;1H[K- xvcserver.c 209/304 68%[25;1H[1;9H [2;5H} while (1);[3;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[4;5Hreturn 0;                                                                [5;1H}            [6;1H [7;1Hint main(int argc, char **argv) {[8;1H    int i;                       [9;9Hs[10;9Hc[11;9Hfd_uio;[12;5H           [13;5Hstruct sockaddr_in address;[14;5H                           [15;5Hopterr = 0;[16;5H           [17;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[18;5H        case 'v': verbose = 1; break;                   [19;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[20;9H}                                                                  [21;9H [22;5H// https://support.xilinx.com/s/article/974879?language=en_US[23;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[24;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [25;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[25;1H[26;1H[K- xvcserver.c 210/304 69%[25;1H[1;5H} while (1);[2;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[3;5Hreturn 0;                                                                [4;1H}            [5;1H [6;1Hint main(int argc, char **argv) {[7;1H    int i;                       [8;9Hs[9;9Hc[10;9Hfd_uio;[11;5H           [12;5Hstruct sockaddr_in address;[13;5H                           [14;5Hopterr = 0;[15;5H           [16;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[17;5H        case 'v': verbose = 1; break;                   [18;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[19;9H}                                                                  [20;9H [21;5H// https://support.xilinx.com/s/article/974879?language=en_US[22;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[23;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [24;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[25;8HAnd xvcServer.c in the git repo                                       [25;1H[26;1H[K- xvcserver.c 211/304 69%[25;1H[1;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[2;5Hreturn 0;                                                                [3;1H}            [4;1H [5;1Hint main(int argc, char **argv) {[6;1H    int i;                       [7;9Hs[8;9Hc[9;9Hfd_uio;[10;5H           [11;5Hstruct sockaddr_in address;[12;5H                           [13;5Hopterr = 0;[14;5H           [15;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[16;5H        case 'v': verbose = 1; break;                   [17;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[18;9H}                                                                  [19;9H [20;5H// https://support.xilinx.com/s/article/974879?language=en_US[21;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[22;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [23;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[24;8HAnd xvcServer.c in the git repo                                       [25;8Hhttps://github.com/Xilinx/XilinxVirtualCable[25;1H[26;1H[K- xvcserver.c 212/304 69%[25;1H[1;5Hreturn 0;                                                                [2;1H}            [3;1H [4;1Hint main(int argc, char **argv) {[5;1H    int i;                       [6;9Hs[7;9Hc[8;9Hfd_uio;[9;5H           [10;5Hstruct sockaddr_in address;[11;5H                           [12;5Hopterr = 0;[13;5H           [14;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[15;5H        case 'v': verbose = 1; break;                   [16;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[17;9H}                                                                  [18;9H [19;5H// https://support.xilinx.com/s/article/974879?language=en_US[20;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[21;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [22;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[23;8HAnd xvcServer.c in the git repo                                       [24;8Hhttps://github.com/Xilinx/XilinxVirtualCable[25;8Halso uses uio0. (K. Okazaki)                [25;1H[26;1H[K- xvcserver.c 213/304 70%[25;1H[1;1H}            [2;1H [3;1Hint main(int argc, char **argv) {[4;1H    int i;                       [5;9Hs[6;9Hc[7;9Hfd_uio;[8;5H           [9;5Hstruct sockaddr_in address;[10;5H                           [11;5Hopterr = 0;[12;5H           [13;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[14;5H        case 'v': verbose = 1; break;                   [15;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[16;9H}                                                                  [17;9H [18;5H// https://support.xilinx.com/s/article/974879?language=en_US[19;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[20;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [21;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[22;8HAnd xvcServer.c in the git repo                                       [23;8Hhttps://github.com/Xilinx/XilinxVirtualCable[24;8Halso uses uio0. (K. Okazaki)                [25;5Hfd_uio = open("/dev/uio0", O_RDWR);[25;1H[26;1H[K- xvcserver.c 214/304 70%[25;1H[1;1H [2;1Hint main(int argc, char **argv) {[3;1H    int i;                       [4;9Hs[5;9Hc[6;9Hfd_uio;[7;5H           [8;5Hstruct sockaddr_in address;[9;5H                           [10;5Hopterr = 0;[11;5H           [12;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[13;5H        case 'v': verbose = 1; break;                   [14;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[15;9H}                                                                  [16;9H [17;5H// https://support.xilinx.com/s/article/974879?language=en_US[18;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[19;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [20;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[21;8HAnd xvcServer.c in the git repo                                       [22;8Hhttps://github.com/Xilinx/XilinxVirtualCable[23;8Halso uses uio0. (K. Okazaki)                [24;5Hfd_uio = open("/dev/uio0", O_RDWR);[25;5Hif (fd_uio < 1) {                  [25;1H[26;1H[K- xvcserver.c 215/304 70%[25;1H[1;1Hint main(int argc, char **argv) {[2;1H    int i;                       [3;9Hs[4;9Hc[5;9Hfd_uio;[6;5H           [7;5Hstruct sockaddr_in address;[8;5H                           [9;5Hopterr = 0;[10;5H           [11;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[12;5H        case 'v': verbose = 1; break;                   [13;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[14;9H}                                                                  [15;9H [16;5H// https://support.xilinx.com/s/article/974879?language=en_US[17;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[18;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [19;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[20;8HAnd xvcServer.c in the git repo                                       [21;8Hhttps://github.com/Xilinx/XilinxVirtualCable[22;8Halso uses uio0. (K. Okazaki)                [23;5Hfd_uio = open("/dev/uio0", O_RDWR);[24;5Hif (fd_uio < 1) {                  [25;5H    fprintf(stderr, "Failed to Open UIO Device\n");[25;1H[26;1H[K- xvcserver.c 216/304 71%[25;1H[1;1H    int i;                       [2;9Hs[3;9Hc[4;9Hfd_uio;[5;5H           [6;5Hstruct sockaddr_in address;[7;5H                           [8;5Hopterr = 0;[9;5H           [10;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[11;5H        case 'v': verbose = 1; break;                   [12;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[13;9H}                                                                  [14;9H [15;5H// https://support.xilinx.com/s/article/974879?language=en_US[16;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[17;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [18;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[19;8HAnd xvcServer.c in the git repo                                       [20;8Hhttps://github.com/Xilinx/XilinxVirtualCable[21;8Halso uses uio0. (K. Okazaki)                [22;5Hfd_uio = open("/dev/uio0", O_RDWR);[23;5Hif (fd_uio < 1) {                  [24;5H    fprintf(stderr, "Failed to Open UIO Device\n");[25;9Hreturn -1;                                     [25;1H[26;1H[K- xvcserver.c 217/304 71%[25;1H[1;9Hs[2;9Hc[3;9Hfd_uio;[4;5H           [5;5Hstruct sockaddr_in address;[6;5H                           [7;5Hopterr = 0;[8;5H           [9;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[10;5H        case 'v': verbose = 1; break;                   [11;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[12;9H}                                                                  [13;9H [14;5H// https://support.xilinx.com/s/article/974879?language=en_US[15;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[16;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [17;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[18;8HAnd xvcServer.c in the git repo                                       [19;8Hhttps://github.com/Xilinx/XilinxVirtualCable[20;8Halso uses uio0. (K. Okazaki)                [21;5Hfd_uio = open("/dev/uio0", O_RDWR);[22;5Hif (fd_uio < 1) {                  [23;5H    fprintf(stderr, "Failed to Open UIO Device\n");[24;9Hreturn -1;                                     [25;5H}             [25;1H[26;1H[K- xvcserver.c 218/304 71%[25;1H[1;9Hc[2;9Hfd_uio;[3;5H           [4;5Hstruct sockaddr_in address;[5;5H                           [6;5Hopterr = 0;[7;5H           [8;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[9;5H        case 'v': verbose = 1; break;                   [10;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[11;9H}                                                                  [12;9H [13;5H// https://support.xilinx.com/s/article/974879?language=en_US[14;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[15;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [16;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[17;8HAnd xvcServer.c in the git repo                                       [18;8Hhttps://github.com/Xilinx/XilinxVirtualCable[19;8Halso uses uio0. (K. Okazaki)                [20;5Hfd_uio = open("/dev/uio0", O_RDWR);[21;5Hif (fd_uio < 1) {                  [22;5H    fprintf(stderr, "Failed to Open UIO Device\n");[23;9Hreturn -1;                                     [24;5H}             [25;5H [25;1H[26;1H[K- xvcserver.c 219/304 72%[25;1H[1;9Hfd_uio;[2;5H           [3;5Hstruct sockaddr_in address;[4;5H                           [5;5Hopterr = 0;[6;5H           [7;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[8;5H        case 'v': verbose = 1; break;                   [9;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[10;9H}                                                                  [11;9H [12;5H// https://support.xilinx.com/s/article/974879?language=en_US[13;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[14;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [15;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[16;8HAnd xvcServer.c in the git repo                                       [17;8Hhttps://github.com/Xilinx/XilinxVirtualCable[18;8Halso uses uio0. (K. Okazaki)                [19;5Hfd_uio = open("/dev/uio0", O_RDWR);[20;5Hif (fd_uio < 1) {                  [21;5H    fprintf(stderr, "Failed to Open UIO Device\n");[22;9Hreturn -1;                                     [23;5H}             [24;5H [25;5Hs = socket(AF_INET, SOCK_STREAM, 0);[25;1H[26;1H[K- xvcserver.c 220/304 72%[25;1H[26;1H[K- xvcserver.c 221/304 72%[25;1H[26;1H[K- xvcserver.c 222/304 73%[25;1H[1;5H           [2;5Hopterr = 0;[3;5H                           [4;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[5;5H        case 'v': verbose = 1; break;[6;13Hcase '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[7;5H    }                                                   [8;13H                             [9;5H// https://support.xilinx.com/s/article/974879?language=en_US          [10;5H// The tutorial above says: "The original code for Zynq-7000 devices uses[11;5H// uio0, but for MPSoC devices, uio1 must be used." But debug_bridge is[12;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[13;8HAnd xvcServer.c in the git repo                                       [14;8Hhttps://github.com/Xilinx/XilinxVirtualCable                        [15;9Hlso uses uio0. (K. Okazaki)                                          [16;5Hfd_uio = open("/dev/uio0", O_RDWR);[17;5Hif (fd_uio < 1) {                              [18;5H    fprintf(stderr, "Failed to Open UIO Device\n");[19;5H    return -1;                     [20;5H}                [21;9H                                               [22;5Hs = socket(AF_INET, SOCK_STREAM, 0);[23;5H [24;5Hif (s < 0) {[25;5H    perror("socket");               [25;1H[26;1H[K- xvcserver.c 223/304 73%[25;1H[1;5Hopterr = 0;[2;5H           [3;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[4;5H        case 'v': verbose = 1; break;                   [5;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[6;9H}                                                                  [7;9H [8;5H// https://support.xilinx.com/s/article/974879?language=en_US[9;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[10;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [11;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[12;8HAnd xvcServer.c in the git repo                                       [13;8Hhttps://github.com/Xilinx/XilinxVirtualCable[14;8Halso uses uio0. (K. Okazaki)                [15;5Hfd_uio = open("/dev/uio0", O_RDWR);[16;5Hif (fd_uio < 1) {                  [17;5H    fprintf(stderr, "Failed to Open UIO Device\n");[18;9Hreturn -1;                                     [19;5H}             [20;5H [21;5Hs = socket(AF_INET, SOCK_STREAM, 0);[22;5H                                    [23;5Hif (s < 0) {[24;5H    perror("socket");[25;9Hreturn 1;        [25;1H[26;1H[K- xvcserver.c 224/304 73%[25;1H[1;5H           [2;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[3;5H        case 'v': verbose = 1; break;                   [4;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[5;9H}                                                                  [6;9H [7;5H// https://support.xilinx.com/s/article/974879?language=en_US[8;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[9;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [10;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[11;8HAnd xvcServer.c in the git repo                                       [12;8Hhttps://github.com/Xilinx/XilinxVirtualCable[13;8Halso uses uio0. (K. Okazaki)                [14;5Hfd_uio = open("/dev/uio0", O_RDWR);[15;5Hif (fd_uio < 1) {                  [16;5H    fprintf(stderr, "Failed to Open UIO Device\n");[17;9Hreturn -1;                                     [18;5H}             [19;5H [20;5Hs = socket(AF_INET, SOCK_STREAM, 0);[21;5H                                    [22;5Hif (s < 0) {[23;5H    perror("socket");[24;9Hreturn 1;        [25;5H}            [25;1H[26;1H[K- xvcserver.c 225/304 74%[25;1H[1;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[2;5H        case 'v': verbose = 1; break;                   [3;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[4;9H}                                                                  [5;9H [6;5H// https://support.xilinx.com/s/article/974879?language=en_US[7;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[8;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [9;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[10;8HAnd xvcServer.c in the git repo                                       [11;8Hhttps://github.com/Xilinx/XilinxVirtualCable[12;8Halso uses uio0. (K. Okazaki)                [13;5Hfd_uio = open("/dev/uio0", O_RDWR);[14;5Hif (fd_uio < 1) {                  [15;5H    fprintf(stderr, "Failed to Open UIO Device\n");[16;9Hreturn -1;                                     [17;5H}             [18;5H [19;5Hs = socket(AF_INET, SOCK_STREAM, 0);[20;5H                                    [21;5Hif (s < 0) {[22;5H    perror("socket");[23;9Hreturn 1;        [24;5H}            [25;5H [25;1H[26;1H[K- xvcserver.c 226/304 74%[25;1H[1;5H        case 'v': verbose = 1; break;                   [2;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[3;9H}                                                                  [4;9H [5;5H// https://support.xilinx.com/s/article/974879?language=en_US[6;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[7;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [8;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[9;8HAnd xvcServer.c in the git repo                                       [10;8Hhttps://github.com/Xilinx/XilinxVirtualCable[11;8Halso uses uio0. (K. Okazaki)                [12;5Hfd_uio = open("/dev/uio0", O_RDWR);[13;5Hif (fd_uio < 1) {                  [14;5H    fprintf(stderr, "Failed to Open UIO Device\n");[15;9Hreturn -1;                                     [16;5H}             [17;5H [18;5Hs = socket(AF_INET, SOCK_STREAM, 0);[19;5H                                    [20;5Hif (s < 0) {[21;5H    perror("socket");[22;9Hreturn 1;        [23;5H}            [24;5H [25;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([25;1H[26;1H[K- xvcserver.c 227/304 74%[25;1H[1;19H?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[2;9H}                                                                  [3;9H [4;5H// https://support.xilinx.com/s/article/974879?language=en_US[5;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[6;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [7;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[8;8HAnd xvcServer.c in the git repo                                       [9;8Hhttps://github.com/Xilinx/XilinxVirtualCable[10;8Halso uses uio0. (K. Okazaki)                [11;5Hfd_uio = open("/dev/uio0", O_RDWR);[12;5Hif (fd_uio < 1) {                  [13;5H    fprintf(stderr, "Failed to Open UIO Device\n");[14;9Hreturn -1;                                     [15;5H}             [16;5H [17;5Hs = socket(AF_INET, SOCK_STREAM, 0);[18;5H                                    [19;5Hif (s < 0) {[20;5H    perror("socket");[21;9Hreturn 1;        [22;5H}            [23;5H [24;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([25;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[25;1H[26;1H[K- xvcserver.c 228/304 75%[25;1H[1;9H}                                                                  [2;9H [3;5H// https://support.xilinx.com/s/article/974879?language=en_US[4;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[5;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [6;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[7;8HAnd xvcServer.c in the git repo                                       [8;8Hhttps://github.com/Xilinx/XilinxVirtualCable[9;8Halso uses uio0. (K. Okazaki)                [10;5Hfd_uio = open("/dev/uio0", O_RDWR);[11;5Hif (fd_uio < 1) {                  [12;5H    fprintf(stderr, "Failed to Open UIO Device\n");[13;9Hreturn -1;                                     [14;5H}             [15;5H [16;5Hs = socket(AF_INET, SOCK_STREAM, 0);[17;5H                                    [18;5Hif (s < 0) {[19;5H    perror("socket");[20;9Hreturn 1;        [21;5H}            [22;5H [23;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([24;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[25;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [25;1H[26;1H[K- xvcserver.c 229/304 75%[25;1H[1;9H [2;5H// https://support.xilinx.com/s/article/974879?language=en_US[3;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[4;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [5;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[6;8HAnd xvcServer.c in the git repo                                       [7;8Hhttps://github.com/Xilinx/XilinxVirtualCable[8;8Halso uses uio0. (K. Okazaki)                [9;5Hfd_uio = open("/dev/uio0", O_RDWR);[10;5Hif (fd_uio < 1) {                  [11;5H    fprintf(stderr, "Failed to Open UIO Device\n");[12;9Hreturn -1;                                     [13;5H}             [14;5H [15;5Hs = socket(AF_INET, SOCK_STREAM, 0);[16;5H                                    [17;5Hif (s < 0) {[18;5H    perror("socket");[19;9Hreturn 1;        [20;5H}            [21;5H [22;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([23;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[24;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [25;5H                                                        [25;1H[26;1H[K- xvcserver.c 230/304 75%[25;1H[1;5H// https://support.xilinx.com/s/article/974879?language=en_US[2;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[3;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [4;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[5;8HAnd xvcServer.c in the git repo                                       [6;8Hhttps://github.com/Xilinx/XilinxVirtualCable[7;8Halso uses uio0. (K. Okazaki)                [8;5Hfd_uio = open("/dev/uio0", O_RDWR);[9;5Hif (fd_uio < 1) {                  [10;5H    fprintf(stderr, "Failed to Open UIO Device\n");[11;9Hreturn -1;                                     [12;5H}             [13;5H [14;5Hs = socket(AF_INET, SOCK_STREAM, 0);[15;5H                                    [16;5Hif (s < 0) {[17;5H    perror("socket");[18;9Hreturn 1;        [19;5H}            [20;5H [21;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([22;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[23;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [24;5H                                                        [25;5Hclose(fd_uio);[25;1H[26;1H[K- xvcserver.c 231/304 75%[25;1H[1;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[2;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [3;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[4;8HAnd xvcServer.c in the git repo                                       [5;8Hhttps://github.com/Xilinx/XilinxVirtualCable[6;8Halso uses uio0. (K. Okazaki)                [7;5Hfd_uio = open("/dev/uio0", O_RDWR);[8;5Hif (fd_uio < 1) {                  [9;5H    fprintf(stderr, "Failed to Open UIO Device\n");[10;9Hreturn -1;                                     [11;5H}             [12;5H [13;5Hs = socket(AF_INET, SOCK_STREAM, 0);[14;5H                                    [15;5Hif (s < 0) {[16;5H    perror("socket");[17;9Hreturn 1;        [18;5H}            [19;5H [20;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([21;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[22;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [23;5H                                                        [24;5Hclose(fd_uio);[25;5H              [25;1H[26;1H[K- xvcserver.c 232/304 76%[25;1H[1;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [2;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[3;8HAnd xvcServer.c in the git repo                                       [4;8Hhttps://github.com/Xilinx/XilinxVirtualCable[5;8Halso uses uio0. (K. Okazaki)                [6;5Hfd_uio = open("/dev/uio0", O_RDWR);[7;5Hif (fd_uio < 1) {                  [8;5H    fprintf(stderr, "Failed to Open UIO Device\n");[9;9Hreturn -1;                                     [10;5H}             [11;5H [12;5Hs = socket(AF_INET, SOCK_STREAM, 0);[13;5H                                    [14;5Hif (s < 0) {[15;5H    perror("socket");[16;9Hreturn 1;        [17;5H}            [18;5H [19;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([20;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[21;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [22;5H                                                        [23;5Hclose(fd_uio);[24;5H              [25;5Hi = 1;[25;1H[26;1H[K- xvcserver.c 233/304 76%[25;1H[1;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[2;8HAnd xvcServer.c in the git repo                                       [3;8Hhttps://github.com/Xilinx/XilinxVirtualCable[4;8Halso uses uio0. (K. Okazaki)                [5;5Hfd_uio = open("/dev/uio0", O_RDWR);[6;5Hif (fd_uio < 1) {                  [7;5H    fprintf(stderr, "Failed to Open UIO Device\n");[8;9Hreturn -1;                                     [9;5H}             [10;5H [11;5Hs = socket(AF_INET, SOCK_STREAM, 0);[12;5H                                    [13;5Hif (s < 0) {[14;5H    perror("socket");[15;9Hreturn 1;        [16;5H}            [17;5H [18;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([19;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[20;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [21;5H                                                        [22;5Hclose(fd_uio);[23;5H              [24;5Hi = 1;[25;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[25;1H[26;1H[K- xvcserver.c 234/304 76%[25;1H[1;8HAnd xvcServer.c in the git repo                                       [2;8Hhttps://github.com/Xilinx/XilinxVirtualCable[3;8Halso uses uio0. (K. Okazaki)                [4;5Hfd_uio = open("/dev/uio0", O_RDWR);[5;5Hif (fd_uio < 1) {                  [6;5H    fprintf(stderr, "Failed to Open UIO Device\n");[7;9Hreturn -1;                                     [8;5H}             [9;5H [10;5Hs = socket(AF_INET, SOCK_STREAM, 0);[11;5H                                    [12;5Hif (s < 0) {[13;5H    perror("socket");[14;9Hreturn 1;        [15;5H}            [16;5H [17;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([18;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[19;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [20;5H                                                        [21;5Hclose(fd_uio);[22;5H              [23;5Hi = 1;[24;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[25;5H                                                      [25;1H[26;1H[K- xvcserver.c 235/304 77%[25;1H[1;8Hhttps://github.com/Xilinx/XilinxVirtualCable[2;8Halso uses uio0. (K. Okazaki)                [3;5Hfd_uio = open("/dev/uio0", O_RDWR);[4;5Hif (fd_uio < 1) {                  [5;5H    fprintf(stderr, "Failed to Open UIO Device\n");[6;9Hreturn -1;                                     [7;5H}             [8;5H [9;5Hs = socket(AF_INET, SOCK_STREAM, 0);[10;5H                                    [11;5Hif (s < 0) {[12;5H    perror("socket");[13;9Hreturn 1;        [14;5H}            [15;5H [16;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([17;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[18;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [19;5H                                                        [20;5Hclose(fd_uio);[21;5H              [22;5Hi = 1;[23;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[24;5H                                                      [25;5Haddress.sin_addr.s_addr = INADDR_ANY;[25;1H[26;1H[K- xvcserver.c 236/304 77%[25;1H[1;8Halso uses uio0. (K. Okazaki)                [2;5Hfd_uio = open("/dev/uio0", O_RDWR);[3;5Hif (fd_uio < 1) {                  [4;5H    fprintf(stderr, "Failed to Open UIO Device\n");[5;9Hreturn -1;                                     [6;5H}             [7;5H [8;5Hs = socket(AF_INET, SOCK_STREAM, 0);[9;5H                                    [10;5Hif (s < 0) {[11;5H    perror("socket");[12;9Hreturn 1;        [13;5H}            [14;5H [15;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([16;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[17;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [18;5H                                                        [19;5Hclose(fd_uio);[20;5H              [21;5Hi = 1;[22;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[23;5H                                                      [24;5Haddress.sin_addr.s_addr = INADDR_ANY;[25;17Hport        = htons(2542);[25;1H[26;1H[K- xvcserver.c 237/304 77%[25;1H[1;5Hfd_uio = open("/dev/uio0", O_RDWR);[2;5Hif (fd_uio < 1) {                  [3;5H    fprintf(stderr, "Failed to Open UIO Device\n");[4;9Hreturn -1;                                     [5;5H}             [6;5H [7;5Hs = socket(AF_INET, SOCK_STREAM, 0);[8;5H                                    [9;5Hif (s < 0) {[10;5H    perror("socket");[11;9Hreturn 1;        [12;5H}            [13;5H [14;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([15;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[16;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [17;5H                                                        [18;5Hclose(fd_uio);[19;5H              [20;5Hi = 1;[21;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[22;5H                                                      [23;5Haddress.sin_addr.s_addr = INADDR_ANY;[24;17Hport        = htons(2542);[25;17Hfamily      = AF_INET;    [25;1H[26;1H[K- xvcserver.c 238/304 78%[25;1H[1;5Hif (fd_uio < 1) {                  [2;5H    fprintf(stderr, "Failed to Open UIO Device\n");[3;9Hreturn -1;                                     [4;5H}             [5;5H [6;5Hs = socket(AF_INET, SOCK_STREAM, 0);[7;5H                                    [8;5Hif (s < 0) {[9;5H    perror("socket");[10;9Hreturn 1;        [11;5H}            [12;5H [13;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([14;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[15;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [16;5H                                                        [17;5Hclose(fd_uio);[18;5H              [19;5Hi = 1;[20;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[21;5H                                                      [22;5Haddress.sin_addr.s_addr = INADDR_ANY;[23;17Hport        = htons(2542);[24;17Hfamily      = AF_INET;    [25;5H                                  [25;1H[26;1H[K- xvcserver.c 239/304 78%[25;1H[1;5H    fprintf(stderr, "Failed to Open UIO Device\n");[2;9Hreturn -1;                                     [3;5H}             [4;5H [5;5Hs = socket(AF_INET, SOCK_STREAM, 0);[6;5H                                    [7;5Hif (s < 0) {[8;5H    perror("socket");[9;9Hreturn 1;        [10;5H}            [11;5H [12;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([13;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[14;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [15;5H                                                        [16;5Hclose(fd_uio);[17;5H              [18;5Hi = 1;[19;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[20;5H                                                      [21;5Haddress.sin_addr.s_addr = INADDR_ANY;[22;17Hport        = htons(2542);[23;17Hfamily      = AF_INET;    [24;5H                                  [25;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[25;1H[26;1H[K- xvcserver.c 240/304 78%[25;1H[1;9Hreturn -1;                                     [2;5H}             [3;5H [4;5Hs = socket(AF_INET, SOCK_STREAM, 0);[5;5H                                    [6;5Hif (s < 0) {[7;5H    perror("socket");[8;9Hreturn 1;        [9;5H}            [10;5H [11;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([12;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[13;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [14;5H                                                        [15;5Hclose(fd_uio);[16;5H              [17;5Hi = 1;[18;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[19;5H                                                      [20;5Haddress.sin_addr.s_addr = INADDR_ANY;[21;17Hport        = htons(2542);[22;17Hfamily      = AF_INET;    [23;5H                                  [24;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[25;5H    perror("bind");                                             [25;1H[26;1H[K- xvcserver.c 241/304 79%[25;1H[1;5H}             [2;5H [3;5Hs = socket(AF_INET, SOCK_STREAM, 0);[4;5H                                    [5;5Hif (s < 0) {[6;5H    perror("socket");[7;9Hreturn 1;        [8;5H}            [9;5H [10;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([11;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[12;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [13;5H                                                        [14;5Hclose(fd_uio);[15;5H              [16;5Hi = 1;[17;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[18;5H                                                      [19;5Haddress.sin_addr.s_addr = INADDR_ANY;[20;17Hport        = htons(2542);[21;17Hfamily      = AF_INET;    [22;5H                                  [23;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[24;5H    perror("bind");                                             [25;9Hreturn 1;      [25;1H[26;1H[K- xvcserver.c 242/304 79%[25;1H[1;5H [2;5Hs = socket(AF_INET, SOCK_STREAM, 0);[3;5H                                    [4;5Hif (s < 0) {[5;5H    perror("socket");[6;9Hreturn 1;        [7;5H}            [8;5H [9;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([10;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[11;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [12;5H                                                        [13;5Hclose(fd_uio);[14;5H              [15;5Hi = 1;[16;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[17;5H                                                      [18;5Haddress.sin_addr.s_addr = INADDR_ANY;[19;17Hport        = htons(2542);[20;17Hfamily      = AF_INET;    [21;5H                                  [22;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[23;5H    perror("bind");                                             [24;9Hreturn 1;      [25;5H}            [25;1H[26;1H[K- xvcserver.c 243/304 79%[25;1H[1;5Hs = socket(AF_INET, SOCK_STREAM, 0);[2;5H                                    [3;5Hif (s < 0) {[4;5H    perror("socket");[5;9Hreturn 1;        [6;5H}            [7;5H [8;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([9;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[10;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [11;5H                                                        [12;5Hclose(fd_uio);[13;5H              [14;5Hi = 1;[15;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[16;5H                                                      [17;5Haddress.sin_addr.s_addr = INADDR_ANY;[18;17Hport        = htons(2542);[19;17Hfamily      = AF_INET;    [20;5H                                  [21;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[22;5H    perror("bind");                                             [23;9Hreturn 1;      [24;5H}            [25;5H [25;1H[26;1H[K- xvcserver.c 244/304 80%[25;1H[1;5H                                    [2;5Hif (s < 0) {[3;5H    perror("socket");[4;9Hreturn 1;        [5;5H}            [6;5H [7;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([8;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[9;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [10;5H                                                        [11;5Hclose(fd_uio);[12;5H              [13;5Hi = 1;[14;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[15;5H                                                      [16;5Haddress.sin_addr.s_addr = INADDR_ANY;[17;17Hport        = htons(2542);[18;17Hfamily      = AF_INET;    [19;5H                                  [20;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[21;5H    perror("bind");                                             [22;9Hreturn 1;      [23;5H}            [24;5H [25;5Hif (listen(s, 0) < 0) {[25;1H[26;1H[K- xvcserver.c 245/304 80%[25;1H[1;5Hif (s < 0) {[2;5H    perror("socket");[3;9Hreturn 1;        [4;5H}            [5;5H [6;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([7;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[8;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [9;5H                                                        [10;5Hclose(fd_uio);[11;5H              [12;5Hi = 1;[13;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[14;5H                                                      [15;5Haddress.sin_addr.s_addr = INADDR_ANY;[16;17Hport        = htons(2542);[17;17Hfamily      = AF_INET;    [18;5H                                  [19;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[20;5H    perror("bind");                                             [21;9Hreturn 1;      [22;5H}            [23;5H [24;5Hif (listen(s, 0) < 0) {[25;5H    perror("listen");  [25;1H[26;1H[K- xvcserver.c 246/304 80%[25;1H[1;5H    perror("socket");[2;9Hreturn 1;        [3;5H}            [4;5H [5;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([6;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[7;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [8;5H                                                        [9;5Hclose(fd_uio);[10;5H              [11;5Hi = 1;[12;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[13;5H                                                      [14;5Haddress.sin_addr.s_addr = INADDR_ANY;[15;17Hport        = htons(2542);[16;17Hfamily      = AF_INET;    [17;5H                                  [18;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[19;5H    perror("bind");                                             [20;9Hreturn 1;      [21;5H}            [22;5H [23;5Hif (listen(s, 0) < 0) {[24;5H    perror("listen");  [25;9Hreturn 1;        [25;1H[26;1H[K- xvcserver.c 247/304 81%[25;1H[1;9Hreturn 1;        [2;5H}            [3;5H [4;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([5;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[6;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [7;5H                                                        [8;5Hclose(fd_uio);[9;5H              [10;5Hi = 1;[11;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[12;5H                                                      [13;5Haddress.sin_addr.s_addr = INADDR_ANY;[14;17Hport        = htons(2542);[15;17Hfamily      = AF_INET;    [16;5H                                  [17;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[18;5H    perror("bind");                                             [19;9Hreturn 1;      [20;5H}            [21;5H [22;5Hif (listen(s, 0) < 0) {[23;5H    perror("listen");  [24;9Hreturn 1;        [25;5H}            [25;1H[26;1H[K- xvcserver.c 248/304 81%[25;1H[1;5H}            [2;5H [3;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([4;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[5;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [6;5H                                                        [7;5Hclose(fd_uio);[8;5H              [9;5Hi = 1;[10;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[11;5H                                                      [12;5Haddress.sin_addr.s_addr = INADDR_ANY;[13;17Hport        = htons(2542);[14;17Hfamily      = AF_INET;    [15;5H                                  [16;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[17;5H    perror("bind");                                             [18;9Hreturn 1;      [19;5H}            [20;5H [21;5Hif (listen(s, 0) < 0) {[22;5H    perror("listen");  [23;9Hreturn 1;        [24;5H}            [25;5H [25;1H[26;1H[K- xvcserver.c 249/304 81%[25;1H[1;5H [2;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([3;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[4;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [5;5H                                                        [6;5Hclose(fd_uio);[7;5H              [8;5Hi = 1;[9;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[10;5H                                                      [11;5Haddress.sin_addr.s_addr = INADDR_ANY;[12;17Hport        = htons(2542);[13;17Hfamily      = AF_INET;    [14;5H                                  [15;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[16;5H    perror("bind");                                             [17;9Hreturn 1;      [18;5H}            [19;5H [20;5Hif (listen(s, 0) < 0) {[21;5H    perror("listen");  [22;9Hreturn 1;        [23;5H}            [24;5H [25;5Hfd_set conn;[25;1H[26;1H[K- xvcserver.c 250/304 82%[25;1H[1;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([2;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[3;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [4;5H                                                        [5;5Hclose(fd_uio);[6;5H              [7;5Hi = 1;[8;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[9;5H                                                      [10;5Haddress.sin_addr.s_addr = INADDR_ANY;[11;17Hport        = htons(2542);[12;17Hfamily      = AF_INET;    [13;5H                                  [14;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[15;5H    perror("bind");                                             [16;9Hreturn 1;      [17;5H}            [18;5H [19;5Hif (listen(s, 0) < 0) {[20;5H    perror("listen");  [21;9Hreturn 1;        [22;5H}            [23;5H [24;5Hfd_set conn;[25;5Hint    maxfd = 0;[25;1H[26;1H[K- xvcserver.c 251/304 82%[25;1H[1;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[2;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [3;5H                                                        [4;5Hclose(fd_uio);[5;5H              [6;5Hi = 1;[7;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[8;5H                                                      [9;5Haddress.sin_addr.s_addr = INADDR_ANY;[10;17Hport        = htons(2542);[11;17Hfamily      = AF_INET;    [12;5H                                  [13;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[14;5H    perror("bind");                                             [15;9Hreturn 1;      [16;5H}            [17;5H [18;5Hif (listen(s, 0) < 0) {[19;5H    perror("listen");  [20;9Hreturn 1;        [21;5H}            [22;5H [23;5Hfd_set conn;[24;5Hint    maxfd = 0;[25;5H                 [25;1H[26;1H[K- xvcserver.c 252/304 82%[25;1H[1;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");           [2;5H                                                        [3;5Hclose(fd_uio);[4;5H              [5;5Hi = 1;[6;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[7;5H                                                      [8;5Haddress.sin_addr.s_addr = INADDR_ANY;[9;17Hport        = htons(2542);[10;17Hfamily      = AF_INET;    [11;5H                                  [12;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[13;5H    perror("bind");                                             [14;9Hreturn 1;      [15;5H}            [16;5H [17;5Hif (listen(s, 0) < 0) {[18;5H    perror("listen");  [19;9Hreturn 1;        [20;5H}            [21;5H [22;5Hfd_set conn;[23;5Hint    maxfd = 0;[24;5H                 [25;5HFD_ZERO(&conn);[25;1H[26;1H[K- xvcserver.c 253/304 83%[25;1H[1;5H                                                        [2;5Hclose(fd_uio);[3;5H              [4;5Hi = 1;[5;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[6;5H                                                      [7;5Haddress.sin_addr.s_addr = INADDR_ANY;[8;17Hport        = htons(2542);[9;17Hfamily      = AF_INET;    [10;5H                                  [11;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[12;5H    perror("bind");                                             [13;9Hreturn 1;      [14;5H}            [15;5H [16;5Hif (listen(s, 0) < 0) {[17;5H    perror("listen");  [18;9Hreturn 1;        [19;5H}            [20;5H [21;5Hfd_set conn;[22;5Hint    maxfd = 0;[23;5H                 [24;5HFD_ZERO(&conn);[25;8HSET(s, &conn);[25;1H[26;1H[K- xvcserver.c 254/304 83%[25;1H[1;5Hclose(fd_uio);[2;5H              [3;5Hi = 1;[4;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[5;5H                                                      [6;5Haddress.sin_addr.s_addr = INADDR_ANY;[7;17Hport        = htons(2542);[8;17Hfamily      = AF_INET;    [9;5H                                  [10;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[11;5H    perror("bind");                                             [12;9Hreturn 1;      [13;5H}            [14;5H [15;5Hif (listen(s, 0) < 0) {[16;5H    perror("listen");  [17;9Hreturn 1;        [18;5H}            [19;5H [20;5Hfd_set conn;[21;5Hint    maxfd = 0;[22;5H                 [23;5HFD_ZERO(&conn);[24;8HSET(s, &conn);[25;5H                 [25;1H[26;1H[K- xvcserver.c 255/304 83%[25;1H[1;5H              [2;5Hi = 1;[3;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[4;5H                                                      [5;5Haddress.sin_addr.s_addr = INADDR_ANY;[6;17Hport        = htons(2542);[7;17Hfamily      = AF_INET;    [8;5H                                  [9;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[10;5H    perror("bind");                                             [11;9Hreturn 1;      [12;5H}            [13;5H [14;5Hif (listen(s, 0) < 0) {[15;5H    perror("listen");  [16;9Hreturn 1;        [17;5H}            [18;5H [19;5Hfd_set conn;[20;5Hint    maxfd = 0;[21;5H                 [22;5HFD_ZERO(&conn);[23;8HSET(s, &conn);[24;5H                 [25;5Hmaxfd = s;[25;1H[26;1H[K- xvcserver.c 256/304 84%[25;1H[1;5Hi = 1;[2;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[3;5H                                                      [4;5Haddress.sin_addr.s_addr = INADDR_ANY;[5;17Hport        = htons(2542);[6;17Hfamily      = AF_INET;    [7;5H                                  [8;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[9;5H    perror("bind");                                             [10;9Hreturn 1;      [11;5H}            [12;5H [13;5Hif (listen(s, 0) < 0) {[14;5H    perror("listen");  [15;9Hreturn 1;        [16;5H}            [17;5H [18;5Hfd_set conn;[19;5Hint    maxfd = 0;[20;5H                 [21;5HFD_ZERO(&conn);[22;8HSET(s, &conn);[23;5H                 [24;5Hmaxfd = s;[25;5H          [25;1H[26;1H[K- xvcserver.c 257/304 84%[25;1H[1;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[2;5H                                                      [3;5Haddress.sin_addr.s_addr = INADDR_ANY;[4;17Hport        = htons(2542);[5;17Hfamily      = AF_INET;    [6;5H                                  [7;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[8;5H    perror("bind");                                             [9;9Hreturn 1;      [10;5H}            [11;5H [12;5Hif (listen(s, 0) < 0) {[13;5H    perror("listen");  [14;9Hreturn 1;        [15;5H}            [16;5H [17;5Hfd_set conn;[18;5Hint    maxfd = 0;[19;5H                 [20;5HFD_ZERO(&conn);[21;8HSET(s, &conn);[22;5H                 [23;5Hmaxfd = s;[24;5H          [25;5Hwhile (1) {[25;1H[26;1H[K- xvcserver.c 258/304 84%[25;1H[1;5H                                                      [2;5Haddress.sin_addr.s_addr = INADDR_ANY;[3;17Hport        = htons(2542);[4;17Hfamily      = AF_INET;    [5;5H                                  [6;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[7;5H    perror("bind");                                             [8;9Hreturn 1;      [9;5H}            [10;5H [11;5Hif (listen(s, 0) < 0) {[12;5H    perror("listen");  [13;9Hreturn 1;        [14;5H}            [15;5H [16;5Hfd_set conn;[17;5Hint    maxfd = 0;[18;5H                 [19;5HFD_ZERO(&conn);[20;8HSET(s, &conn);[21;5H                 [22;5Hmaxfd = s;[23;5H          [24;5Hwhile (1) {[25;5H    fd_set read = conn, except = conn;[25;1H[26;1H[K- xvcserver.c 259/304 85%[25;1H[1;5Haddress.sin_addr.s_addr = INADDR_ANY;[2;17Hport        = htons(2542);[3;17Hfamily      = AF_INET;    [4;5H                                  [5;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[6;5H    perror("bind");                                             [7;9Hreturn 1;      [8;5H}            [9;5H [10;5Hif (listen(s, 0) < 0) {[11;5H    perror("listen");  [12;9Hreturn 1;        [13;5H}            [14;5H [15;5Hfd_set conn;[16;5Hint    maxfd = 0;[17;5H                 [18;5HFD_ZERO(&conn);[19;8HSET(s, &conn);[20;5H                 [21;5Hmaxfd = s;[22;5H          [23;5Hwhile (1) {[24;5H    fd_set read = conn, except = conn;[25;9Hint    fd;                        [25;1H[26;1H[K- xvcserver.c 260/304 85%[25;1H[1;17Hport        = htons(2542);[2;17Hfamily      = AF_INET;    [3;5H                                  [4;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[5;5H    perror("bind");                                             [6;9Hreturn 1;      [7;5H}            [8;5H [9;5Hif (listen(s, 0) < 0) {[10;5H    perror("listen");  [11;9Hreturn 1;        [12;5H}            [13;5H [14;5Hfd_set conn;[15;5Hint    maxfd = 0;[16;5H                 [17;5HFD_ZERO(&conn);[18;8HSET(s, &conn);[19;5H                 [20;5Hmaxfd = s;[21;5H          [22;5Hwhile (1) {[23;5H    fd_set read = conn, except = conn;[24;9Hint    fd;                        [25;9H          [25;1H[26;1H[K- xvcserver.c 261/304 85%[25;1H[1;17Hfamily      = AF_INET;    [2;5H                                  [3;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[4;5H    perror("bind");                                             [5;9Hreturn 1;      [6;5H}            [7;5H [8;5Hif (listen(s, 0) < 0) {[9;5H    perror("listen");  [10;9Hreturn 1;        [11;5H}            [12;5H [13;5Hfd_set conn;[14;5Hint    maxfd = 0;[15;5H                 [16;5HFD_ZERO(&conn);[17;8HSET(s, &conn);[18;5H                 [19;5Hmaxfd = s;[20;5H          [21;5Hwhile (1) {[22;5H    fd_set read = conn, except = conn;[23;9Hint    fd;                        [24;9H          [25;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[25;1H[26;1H[K- xvcserver.c 262/304 86%[25;1H[1;5H                                  [2;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[3;5H    perror("bind");                                             [4;9Hreturn 1;      [5;5H}            [6;5H [7;5Hif (listen(s, 0) < 0) {[8;5H    perror("listen");  [9;9Hreturn 1;        [10;5H}            [11;5H [12;5Hfd_set conn;[13;5Hint    maxfd = 0;[14;5H                 [15;5HFD_ZERO(&conn);[16;8HSET(s, &conn);[17;5H                 [18;5Hmaxfd = s;[19;5H          [20;5Hwhile (1) {[21;5H    fd_set read = conn, except = conn;[22;9Hint    fd;                        [23;9H          [24;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[25;9H    perror("select");                             [25;1H[26;1H[K- xvcserver.c 263/304 86%[25;1H[1;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[2;5H    perror("bind");                                             [3;9Hreturn 1;      [4;5H}            [5;5H [6;5Hif (listen(s, 0) < 0) {[7;5H    perror("listen");  [8;9Hreturn 1;        [9;5H}            [10;5H [11;5Hfd_set conn;[12;5Hint    maxfd = 0;[13;5H                 [14;5HFD_ZERO(&conn);[15;8HSET(s, &conn);[16;5H                 [17;5Hmaxfd = s;[18;5H          [19;5Hwhile (1) {[20;5H    fd_set read = conn, except = conn;[21;9Hint    fd;                        [22;9H          [23;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[24;9H    perror("select");                             [25;13Hbreak;           [25;1H[26;1H[K- xvcserver.c 264/304 86%[25;1H[1;5H    perror("bind");                                             [2;9Hreturn 1;      [3;5H}            [4;5H [5;5Hif (listen(s, 0) < 0) {[6;5H    perror("listen");  [7;9Hreturn 1;        [8;5H}            [9;5H [10;5Hfd_set conn;[11;5Hint    maxfd = 0;[12;5H                 [13;5HFD_ZERO(&conn);[14;8HSET(s, &conn);[15;5H                 [16;5Hmaxfd = s;[17;5H          [18;5Hwhile (1) {[19;5H    fd_set read = conn, except = conn;[20;9Hint    fd;                        [21;9H          [22;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[23;9H    perror("select");                             [24;13Hbreak;           [25;9H}         [25;1H[26;1H[K- xvcserver.c 265/304 87%[25;1H[1;9Hreturn 1;      [2;5H}            [3;5H [4;5Hif (listen(s, 0) < 0) {[5;5H    perror("listen");  [6;9Hreturn 1;        [7;5H}            [8;5H [9;5Hfd_set conn;[10;5Hint    maxfd = 0;[11;5H                 [12;5HFD_ZERO(&conn);[13;8HSET(s, &conn);[14;5H                 [15;5Hmaxfd = s;[16;5H          [17;5Hwhile (1) {[18;5H    fd_set read = conn, except = conn;[19;9Hint    fd;                        [20;9H          [21;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[22;9H    perror("select");                             [23;13Hbreak;           [24;9H}         [25;9H [25;1H[26;1H[K- xvcserver.c 266/304 87%[25;1H[1;5H}            [2;5H [3;5Hif (listen(s, 0) < 0) {[4;5H    perror("listen");  [5;9Hreturn 1;        [6;5H}            [7;5H [8;5Hfd_set conn;[9;5Hint    maxfd = 0;[10;5H                 [11;5HFD_ZERO(&conn);[12;8HSET(s, &conn);[13;5H                 [14;5Hmaxfd = s;[15;5H          [16;5Hwhile (1) {[17;5H    fd_set read = conn, except = conn;[18;9Hint    fd;                        [19;9H          [20;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[21;9H    perror("select");                             [22;13Hbreak;           [23;9H}         [24;9H [25;9Hfor (fd = 0; fd <= maxfd; ++fd) {[25;1H[26;1H[K- xvcserver.c 267/304 87%[25;1H[1;5H [2;5Hif (listen(s, 0) < 0) {[3;5H    perror("listen");  [4;9Hreturn 1;        [5;5H}            [6;5H [7;5Hfd_set conn;[8;5Hint    maxfd = 0;[9;5H                 [10;5HFD_ZERO(&conn);[11;8HSET(s, &conn);[12;5H                 [13;5Hmaxfd = s;[14;5H          [15;5Hwhile (1) {[16;5H    fd_set read = conn, except = conn;[17;9Hint    fd;                        [18;9H          [19;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[20;9H    perror("select");                             [21;13Hbreak;           [22;9H}         [23;9H [24;9Hfor (fd = 0; fd <= maxfd; ++fd) {[25;9H    if (FD_ISSET(fd, &read)) {   [25;1H[26;1H[K- xvcserver.c 268/304 88%[25;1H[1;5Hif (listen(s, 0) < 0) {[2;5H    perror("listen");  [3;9Hreturn 1;        [4;5H}            [5;5H [6;5Hfd_set conn;[7;5Hint    maxfd = 0;[8;5H                 [9;5HFD_ZERO(&conn);[10;8HSET(s, &conn);[11;5H                 [12;5Hmaxfd = s;[13;5H          [14;5Hwhile (1) {[15;5H    fd_set read = conn, except = conn;[16;9Hint    fd;                        [17;9H          [18;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[19;9H    perror("select");                             [20;13Hbreak;           [21;9H}         [22;9H [23;9Hfor (fd = 0; fd <= maxfd; ++fd) {[24;9H    if (FD_ISSET(fd, &read)) {   [25;13H    if (fd == s) {        [25;1H[26;1H[K- xvcserver.c 269/304 88%[25;1H[1;5H    perror("listen");  [2;9Hreturn 1;        [3;5H}            [4;5H [5;5Hfd_set conn;[6;5Hint    maxfd = 0;[7;5H                 [8;5HFD_ZERO(&conn);[9;8HSET(s, &conn);[10;5H                 [11;5Hmaxfd = s;[12;5H          [13;5Hwhile (1) {[14;5H    fd_set read = conn, except = conn;[15;9Hint    fd;                        [16;9H          [17;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[18;9H    perror("select");                             [19;13Hbreak;           [20;9H}         [21;9H [22;9Hfor (fd = 0; fd <= maxfd; ++fd) {[23;9H    if (FD_ISSET(fd, &read)) {   [24;13H    if (fd == s) {        [25;17H    int       newfd;[25;1H[26;1H[K- xvcserver.c 270/304 88%[25;1H[1;9Hreturn 1;        [2;5H}            [3;5H [4;5Hfd_set conn;[5;5Hint    maxfd = 0;[6;5H                 [7;5HFD_ZERO(&conn);[8;8HSET(s, &conn);[9;5H                 [10;5Hmaxfd = s;[11;5H          [12;5Hwhile (1) {[13;5H    fd_set read = conn, except = conn;[14;9Hint    fd;                        [15;9H          [16;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[17;9H    perror("select");                             [18;13Hbreak;           [19;9H}         [20;9H [21;9Hfor (fd = 0; fd <= maxfd; ++fd) {[22;9H    if (FD_ISSET(fd, &read)) {   [23;13H    if (fd == s) {        [24;17H    int       newfd;[25;21Hsocklen_t nsize = sizeof(address);[25;1H[26;1H[K- xvcserver.c 271/304 89%[25;1H[1;5H}            [2;5H [3;5Hfd_set conn;[4;5Hint    maxfd = 0;[5;5H                 [6;5HFD_ZERO(&conn);[7;8HSET(s, &conn);[8;5H                 [9;5Hmaxfd = s;[10;5H          [11;5Hwhile (1) {[12;5H    fd_set read = conn, except = conn;[13;9Hint    fd;                        [14;9H          [15;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[16;9H    perror("select");                             [17;13Hbreak;           [18;9H}         [19;9H [20;9Hfor (fd = 0; fd <= maxfd; ++fd) {[21;9H    if (FD_ISSET(fd, &read)) {   [22;13H    if (fd == s) {        [23;17H    int       newfd;[24;21Hsocklen_t nsize = sizeof(address);[25;21H                                  [25;1H[26;1H[K- xvcserver.c 272/304 89%[25;1H[1;5H [2;5Hfd_set conn;[3;5Hint    maxfd = 0;[4;5H                 [5;5HFD_ZERO(&conn);[6;8HSET(s, &conn);[7;5H                 [8;5Hmaxfd = s;[9;5H          [10;5Hwhile (1) {[11;5H    fd_set read = conn, except = conn;[12;9Hint    fd;                        [13;9H          [14;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[15;9H    perror("select");                             [16;13Hbreak;           [17;9H}         [18;9H [19;9Hfor (fd = 0; fd <= maxfd; ++fd) {[20;9H    if (FD_ISSET(fd, &read)) {   [21;13H    if (fd == s) {        [22;17H    int       newfd;[23;21Hsocklen_t nsize = sizeof(address);[24;21H                                  [25;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[25;1H[26;1H[K- xvcserver.c 273/304 89%[25;1H[1;5Hfd_set conn;[2;5Hint    maxfd = 0;[3;5H                 [4;5HFD_ZERO(&conn);[5;8HSET(s, &conn);[6;5H                 [7;5Hmaxfd = s;[8;5H          [9;5Hwhile (1) {[10;5H    fd_set read = conn, except = conn;[11;9Hint    fd;                        [12;9H          [13;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[14;9H    perror("select");                             [15;13Hbreak;           [16;9H}         [17;9H [18;9Hfor (fd = 0; fd <= maxfd; ++fd) {[19;9H    if (FD_ISSET(fd, &read)) {   [20;13H    if (fd == s) {        [21;17H    int       newfd;[22;21Hsocklen_t nsize = sizeof(address);[23;21H                                  [24;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[25;21H                                                       [25;1H[26;1H[K- xvcserver.c 274/304 90%[25;1H[1;5Hint    maxfd = 0;[2;5H                 [3;5HFD_ZERO(&conn);[4;8HSET(s, &conn);[5;5H                 [6;5Hmaxfd = s;[7;5H          [8;5Hwhile (1) {[9;5H    fd_set read = conn, except = conn;[10;9Hint    fd;                        [11;9H          [12;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[13;9H    perror("select");                             [14;13Hbreak;           [15;9H}         [16;9H [17;9Hfor (fd = 0; fd <= maxfd; ++fd) {[18;9H    if (FD_ISSET(fd, &read)) {   [19;13H    if (fd == s) {        [20;17H    int       newfd;[21;21Hsocklen_t nsize = sizeof(address);[22;21H                                  [23;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[24;21H                                                       [25;21H//               if (verbose)[25;1H[26;1H[K- xvcserver.c 275/304 90%[25;1H[1;5H                 [2;5HFD_ZERO(&conn);[3;8HSET(s, &conn);[4;5H                 [5;5Hmaxfd = s;[6;5H          [7;5Hwhile (1) {[8;5H    fd_set read = conn, except = conn;[9;9Hint    fd;                        [10;9H          [11;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[12;9H    perror("select");                             [13;13Hbreak;           [14;9H}         [15;9H [16;9Hfor (fd = 0; fd <= maxfd; ++fd) {[17;9H    if (FD_ISSET(fd, &read)) {   [18;13H    if (fd == s) {        [19;17H    int       newfd;[20;21Hsocklen_t nsize = sizeof(address);[21;21H                                  [22;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[23;21H                                                       [24;21H//               if (verbose)[25;21Hprintf("connection accepted - fd %d\n", newfd);[25;1H[26;1H[K- xvcserver.c 276/304 90%[25;1H[1;5HFD_ZERO(&conn);[2;8HSET(s, &conn);[3;5H                 [4;5Hmaxfd = s;[5;5H          [6;5Hwhile (1) {[7;5H    fd_set read = conn, except = conn;[8;9Hint    fd;                        [9;9H          [10;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[11;9H    perror("select");                             [12;13Hbreak;           [13;9H}         [14;9H [15;9Hfor (fd = 0; fd <= maxfd; ++fd) {[16;9H    if (FD_ISSET(fd, &read)) {   [17;13H    if (fd == s) {        [18;17H    int       newfd;[19;21Hsocklen_t nsize = sizeof(address);[20;21H                                  [21;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[22;21H                                                       [23;21H//               if (verbose)[24;21Hprintf("connection accepted - fd %d\n", newfd);[25;21Hif (newfd < 0) {                               [25;1H[26;1H[K- xvcserver.c 277/304 91%[25;1H[1;8HSET(s, &conn);[2;5H                 [3;5Hmaxfd = s;[4;5H          [5;5Hwhile (1) {[6;5H    fd_set read = conn, except = conn;[7;9Hint    fd;                        [8;9H          [9;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[10;9H    perror("select");                             [11;13Hbreak;           [12;9H}         [13;9H [14;9Hfor (fd = 0; fd <= maxfd; ++fd) {[15;9H    if (FD_ISSET(fd, &read)) {   [16;13H    if (fd == s) {        [17;17H    int       newfd;[18;21Hsocklen_t nsize = sizeof(address);[19;21H                                  [20;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[21;21H                                                       [22;21H//               if (verbose)[23;21Hprintf("connection accepted - fd %d\n", newfd);[24;21Hif (newfd < 0) {                               [25;21H    perror("accept");[25;1H[26;1H[K- xvcserver.c 278/304 91%[25;1H[1;5H                 [2;5Hmaxfd = s;[3;5H          [4;5Hwhile (1) {[5;5H    fd_set read = conn, except = conn;[6;9Hint    fd;                        [7;9H          [8;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[9;9H    perror("select");                             [10;13Hbreak;           [11;9H}         [12;9H [13;9Hfor (fd = 0; fd <= maxfd; ++fd) {[14;9H    if (FD_ISSET(fd, &read)) {   [15;13H    if (fd == s) {        [16;17H    int       newfd;[17;21Hsocklen_t nsize = sizeof(address);[18;21H                                  [19;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[20;21H                                                       [21;21H//               if (verbose)[22;21Hprintf("connection accepted - fd %d\n", newfd);[23;21Hif (newfd < 0) {                               [24;21H    perror("accept");[25;21H} else {             [25;1H[26;1H[K- xvcserver.c 279/304 91%[25;1H[1;5Hmaxfd = s;[2;5H          [3;5Hwhile (1) {[4;5H    fd_set read = conn, except = conn;[5;9Hint    fd;                        [6;9H          [7;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[8;9H    perror("select");                             [9;13Hbreak;           [10;9H}         [11;9H [12;9Hfor (fd = 0; fd <= maxfd; ++fd) {[13;9H    if (FD_ISSET(fd, &read)) {   [14;13H    if (fd == s) {        [15;17H    int       newfd;[16;21Hsocklen_t nsize = sizeof(address);[17;21H                                  [18;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[19;21H                                                       [20;21H//               if (verbose)[21;21Hprintf("connection accepted - fd %d\n", newfd);[22;21Hif (newfd < 0) {                               [23;21H    perror("accept");[24;21H} else {             [25;21H    printf("setting TCP_NODELAY to 1\n");[25;1H[26;1H[K- xvcserver.c 280/304 92%[25;1H[1;5H          [2;5Hwhile (1) {[3;5H    fd_set read = conn, except = conn;[4;9Hint    fd;                        [5;9H          [6;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[7;9H    perror("select");                             [8;13Hbreak;           [9;9H}         [10;9H [11;9Hfor (fd = 0; fd <= maxfd; ++fd) {[12;9H    if (FD_ISSET(fd, &read)) {   [13;13H    if (fd == s) {        [14;17H    int       newfd;[15;21Hsocklen_t nsize = sizeof(address);[16;21H                                  [17;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[18;21H                                                       [19;21H//               if (verbose)[20;21Hprintf("connection accepted - fd %d\n", newfd);[21;21Hif (newfd < 0) {                               [22;21H    perror("accept");[23;21H} else {             [24;21H    printf("setting TCP_NODELAY to 1\n");[25;25Hint flag = 1;                        [25;1H[26;1H[K- xvcserver.c 281/304 92%[25;1H[1;5Hwhile (1) {[2;5H    fd_set read = conn, except = conn;[3;9Hint    fd;                        [4;9H          [5;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[6;9H    perror("select");                             [7;13Hbreak;           [8;9H}         [9;9H [10;9Hfor (fd = 0; fd <= maxfd; ++fd) {[11;9H    if (FD_ISSET(fd, &read)) {   [12;13H    if (fd == s) {        [13;17H    int       newfd;[14;21Hsocklen_t nsize = sizeof(address);[15;21H                                  [16;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[17;21H                                                       [18;21H//               if (verbose)[19;21Hprintf("connection accepted - fd %d\n", newfd);[20;21Hif (newfd < 0) {                               [21;21H    perror("accept");[22;21H} else {             [23;21H    printf("setting TCP_NODELAY to 1\n");[24;25Hint flag = 1;                        [25;29HoptResult =[25;1H[26;1H[K- xvcserver.c 282/304 92%[25;1H[1;5H    fd_set read = conn, except = conn;[2;9Hint    fd;                        [3;9H          [4;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[5;9H    perror("select");                             [6;13Hbreak;           [7;9H}         [8;9H [9;9Hfor (fd = 0; fd <= maxfd; ++fd) {[10;9H    if (FD_ISSET(fd, &read)) {   [11;13H    if (fd == s) {        [12;17H    int       newfd;[13;21Hsocklen_t nsize = sizeof(address);[14;21H                                  [15;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[16;21H                                                       [17;21H//               if (verbose)[18;21Hprintf("connection accepted - fd %d\n", newfd);[19;21Hif (newfd < 0) {                               [20;21H    perror("accept");[21;21H} else {             [22;21H    printf("setting TCP_NODELAY to 1\n");[23;25Hint flag = 1;                        [24;29HoptResult =[25;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[25;1H[26;1H[K- xvcserver.c 283/304 93%[25;1H[1;9Hint    fd;                        [2;9H          [3;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[4;9H    perror("select");                             [5;13Hbreak;           [6;9H}         [7;9H [8;9Hfor (fd = 0; fd <= maxfd; ++fd) {[9;9H    if (FD_ISSET(fd, &read)) {   [10;13H    if (fd == s) {        [11;17H    int       newfd;[12;21Hsocklen_t nsize = sizeof(address);[13;21H                                  [14;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[15;21H                                                       [16;21H//               if (verbose)[17;21Hprintf("connection accepted - fd %d\n", newfd);[18;21Hif (newfd < 0) {                               [19;21H    perror("accept");[20;21H} else {             [21;21H    printf("setting TCP_NODELAY to 1\n");[22;25Hint flag = 1;                        [23;29HoptResult =[24;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[25;29H           (char *)&flag, sizeof(int));    [25;1H[26;1H[K- xvcserver.c 284/304 93%[25;1H[1;9H          [2;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[3;9H    perror("select");                             [4;13Hbreak;           [5;9H}         [6;9H [7;9Hfor (fd = 0; fd <= maxfd; ++fd) {[8;9H    if (FD_ISSET(fd, &read)) {   [9;13H    if (fd == s) {        [10;17H    int       newfd;[11;21Hsocklen_t nsize = sizeof(address);[12;21H                                  [13;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[14;21H                                                       [15;21H//               if (verbose)[16;21Hprintf("connection accepted - fd %d\n", newfd);[17;21Hif (newfd < 0) {                               [18;21H    perror("accept");[19;21H} else {             [20;21H    printf("setting TCP_NODELAY to 1\n");[21;25Hint flag = 1;                        [22;29HoptResult =[23;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[24;29H           (char *)&flag, sizeof(int));    [25;25Hif (optResult < 0) perror("TCP_NODELAY error");[25;1H[26;1H[K- xvcserver.c 285/304 93%[25;1H[1;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[2;9H    perror("select");                             [3;13Hbreak;           [4;9H}         [5;9H [6;9Hfor (fd = 0; fd <= maxfd; ++fd) {[7;9H    if (FD_ISSET(fd, &read)) {   [8;13H    if (fd == s) {        [9;17H    int       newfd;[10;21Hsocklen_t nsize = sizeof(address);[11;21H                                  [12;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[13;21H                                                       [14;21H//               if (verbose)[15;21Hprintf("connection accepted - fd %d\n", newfd);[16;21Hif (newfd < 0) {                               [17;21H    perror("accept");[18;21H} else {             [19;21H    printf("setting TCP_NODELAY to 1\n");[20;25Hint flag = 1;                        [21;29HoptResult =[22;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[23;29H           (char *)&flag, sizeof(int));    [24;25Hif (optResult < 0) perror("TCP_NODELAY error");[25;29Hnewfd > maxfd) { maxfd = newfd; }          [25;1H[26;1H[K- xvcserver.c 286/304 94%[25;1H[1;9H    perror("select");                             [2;13Hbreak;           [3;9H}         [4;9H [5;9Hfor (fd = 0; fd <= maxfd; ++fd) {[6;9H    if (FD_ISSET(fd, &read)) {   [7;13H    if (fd == s) {        [8;17H    int       newfd;[9;21Hsocklen_t nsize = sizeof(address);[10;21H                                  [11;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[12;21H                                                       [13;21H//               if (verbose)[14;21Hprintf("connection accepted - fd %d\n", newfd);[15;21Hif (newfd < 0) {                               [16;21H    perror("accept");[17;21H} else {             [18;21H    printf("setting TCP_NODELAY to 1\n");[19;25Hint flag = 1;                        [20;29HoptResult =[21;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[22;29H           (char *)&flag, sizeof(int));    [23;25Hif (optResult < 0) perror("TCP_NODELAY error");[24;29Hnewfd > maxfd) { maxfd = newfd; }          [25;25HFD_SET(newfd, &conn);                [25;1H[26;1H[K- xvcserver.c 287/304 94%[25;1H[1;13Hbreak;           [2;9H}         [3;9H [4;9Hfor (fd = 0; fd <= maxfd; ++fd) {[5;9H    if (FD_ISSET(fd, &read)) {   [6;13H    if (fd == s) {        [7;17H    int       newfd;[8;21Hsocklen_t nsize = sizeof(address);[9;21H                                  [10;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[11;21H                                                       [12;21H//               if (verbose)[13;21Hprintf("connection accepted - fd %d\n", newfd);[14;21Hif (newfd < 0) {                               [15;21H    perror("accept");[16;21H} else {             [17;21H    printf("setting TCP_NODELAY to 1\n");[18;25Hint flag = 1;                        [19;29HoptResult =[20;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[21;29H           (char *)&flag, sizeof(int));    [22;25Hif (optResult < 0) perror("TCP_NODELAY error");[23;29Hnewfd > maxfd) { maxfd = newfd; }          [24;25HFD_SET(newfd, &conn);                [25;21H}                        [25;1H[26;1H[K- xvcserver.c 288/304 94%[25;1H[1;9H}         [2;9H [3;9Hfor (fd = 0; fd <= maxfd; ++fd) {[4;9H    if (FD_ISSET(fd, &read)) {   [5;13H    if (fd == s) {        [6;17H    int       newfd;[7;21Hsocklen_t nsize = sizeof(address);[8;21H                                  [9;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[10;21H                                                       [11;21H//               if (verbose)[12;21Hprintf("connection accepted - fd %d\n", newfd);[13;21Hif (newfd < 0) {                               [14;21H    perror("accept");[15;21H} else {             [16;21H    printf("setting TCP_NODELAY to 1\n");[17;25Hint flag = 1;                        [18;29HoptResult =[19;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[20;29H           (char *)&flag, sizeof(int));    [21;25Hif (optResult < 0) perror("TCP_NODELAY error");[22;29Hnewfd > maxfd) { maxfd = newfd; }          [23;25HFD_SET(newfd, &conn);                [24;21H}                        [25;17H} else if (handle_data(fd, ptr)) {[25;1H[26;1H[K- xvcserver.c 289/304 95%[25;1H[1;9H [2;9Hfor (fd = 0; fd <= maxfd; ++fd) {[3;9H    if (FD_ISSET(fd, &read)) {   [4;13H    if (fd == s) {        [5;17H    int       newfd;[6;21Hsocklen_t nsize = sizeof(address);[7;21H                                  [8;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[9;21H                                                       [10;21H//               if (verbose)[11;21Hprintf("connection accepted - fd %d\n", newfd);[12;21Hif (newfd < 0) {                               [13;21H    perror("accept");[14;21H} else {             [15;21H    printf("setting TCP_NODELAY to 1\n");[16;25Hint flag = 1;                        [17;29HoptResult =[18;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[19;29H           (char *)&flag, sizeof(int));    [20;25Hif (optResult < 0) perror("TCP_NODELAY error");[21;29Hnewfd > maxfd) { maxfd = newfd; }          [22;25HFD_SET(newfd, &conn);                [23;21H}                        [24;17H} else if (handle_data(fd, ptr)) {[25;17H    if (verbose) printf("connection closed - fd %d\n", fd);[25;1H[26;1H[K- xvcserver.c 290/304 95%[25;1H[1;9Hfor (fd = 0; fd <= maxfd; ++fd) {[2;9H    if (FD_ISSET(fd, &read)) {   [3;13H    if (fd == s) {        [4;17H    int       newfd;[5;21Hsocklen_t nsize = sizeof(address);[6;21H                                  [7;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[8;21H                                                       [9;21H//               if (verbose)[10;21Hprintf("connection accepted - fd %d\n", newfd);[11;21Hif (newfd < 0) {                               [12;21H    perror("accept");[13;21H} else {             [14;21H    printf("setting TCP_NODELAY to 1\n");[15;25Hint flag = 1;                        [16;29HoptResult =[17;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[18;29H           (char *)&flag, sizeof(int));    [19;25Hif (optResult < 0) perror("TCP_NODELAY error");[20;29Hnewfd > maxfd) { maxfd = newfd; }          [21;25HFD_SET(newfd, &conn);                [22;21H}                        [23;17H} else if (handle_data(fd, ptr)) {[24;17H    if (verbose) printf("connection closed - fd %d\n", fd);[25;21Hclose(fd);                                             [25;1H[26;1H[K- xvcserver.c 291/304 95%[25;1H[1;9H    if (FD_ISSET(fd, &read)) {   [2;13H    if (fd == s) {        [3;17H    int       newfd;[4;21Hsocklen_t nsize = sizeof(address);[5;21H                                  [6;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[7;21H                                                       [8;21H//               if (verbose)[9;21Hprintf("connection accepted - fd %d\n", newfd);[10;21Hif (newfd < 0) {                               [11;21H    perror("accept");[12;21H} else {             [13;21H    printf("setting TCP_NODELAY to 1\n");[14;25Hint flag = 1;                        [15;29HoptResult =[16;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[17;29H           (char *)&flag, sizeof(int));    [18;25Hif (optResult < 0) perror("TCP_NODELAY error");[19;29Hnewfd > maxfd) { maxfd = newfd; }          [20;25HFD_SET(newfd, &conn);                [21;21H}                        [22;17H} else if (handle_data(fd, ptr)) {[23;17H    if (verbose) printf("connection closed - fd %d\n", fd);[24;21Hclose(fd);                                             [25;21HFD_CLR(fd, &conn);[25;1H[26;1H[K- xvcserver.c 292/304 96%[25;1H[1;13H    if (fd == s) {        [2;17H    int       newfd;[3;21Hsocklen_t nsize = sizeof(address);[4;21H                                  [5;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[6;21H                                                       [7;21H//               if (verbose)[8;21Hprintf("connection accepted - fd %d\n", newfd);[9;21Hif (newfd < 0) {                               [10;21H    perror("accept");[11;21H} else {             [12;21H    printf("setting TCP_NODELAY to 1\n");[13;25Hint flag = 1;                        [14;29HoptResult =[15;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[16;29H           (char *)&flag, sizeof(int));    [17;25Hif (optResult < 0) perror("TCP_NODELAY error");[18;29Hnewfd > maxfd) { maxfd = newfd; }          [19;25HFD_SET(newfd, &conn);                [20;21H}                        [21;17H} else if (handle_data(fd, ptr)) {[22;17H    if (verbose) printf("connection closed - fd %d\n", fd);[23;21Hclose(fd);                                             [24;21HFD_CLR(fd, &conn);[25;17H}                     [25;1H[26;1H[K- xvcserver.c 293/304 96%[25;1H[1;17H    int       newfd;[2;21Hsocklen_t nsize = sizeof(address);[3;21H                                  [4;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[5;21H                                                       [6;21H//               if (verbose)[7;21Hprintf("connection accepted - fd %d\n", newfd);[8;21Hif (newfd < 0) {                               [9;21H    perror("accept");[10;21H} else {             [11;21H    printf("setting TCP_NODELAY to 1\n");[12;25Hint flag = 1;                        [13;29HoptResult =[14;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[15;29H           (char *)&flag, sizeof(int));    [16;25Hif (optResult < 0) perror("TCP_NODELAY error");[17;29Hnewfd > maxfd) { maxfd = newfd; }          [18;25HFD_SET(newfd, &conn);                [19;21H}                        [20;17H} else if (handle_data(fd, ptr)) {[21;17H    if (verbose) printf("connection closed - fd %d\n", fd);[22;21Hclose(fd);                                             [23;21HFD_CLR(fd, &conn);[24;17H}                     [25;13H} else if (FD_ISSET(fd, &except)) {[25;1H[26;1H[K- xvcserver.c 294/304 96%[25;1H[1;21Hsocklen_t nsize = sizeof(address);[2;21H                                  [3;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[4;21H                                                       [5;21H//               if (verbose)[6;21Hprintf("connection accepted - fd %d\n", newfd);[7;21Hif (newfd < 0) {                               [8;21H    perror("accept");[9;21H} else {             [10;21H    printf("setting TCP_NODELAY to 1\n");[11;25Hint flag = 1;                        [12;29HoptResult =[13;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[14;29H           (char *)&flag, sizeof(int));    [15;25Hif (optResult < 0) perror("TCP_NODELAY error");[16;29Hnewfd > maxfd) { maxfd = newfd; }          [17;25HFD_SET(newfd, &conn);                [18;21H}                        [19;17H} else if (handle_data(fd, ptr)) {[20;17H    if (verbose) printf("connection closed - fd %d\n", fd);[21;21Hclose(fd);                                             [22;21HFD_CLR(fd, &conn);[23;17H}                     [24;13H} else if (FD_ISSET(fd, &except)) {[25;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[25;1H[26;1H[K- xvcserver.c 295/304 97%[25;1H[1;21H                                  [2;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[3;21H                                                       [4;21H//               if (verbose)[5;21Hprintf("connection accepted - fd %d\n", newfd);[6;21Hif (newfd < 0) {                               [7;21H    perror("accept");[8;21H} else {             [9;21H    printf("setting TCP_NODELAY to 1\n");[10;25Hint flag = 1;                        [11;29HoptResult =[12;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[13;29H           (char *)&flag, sizeof(int));    [14;25Hif (optResult < 0) perror("TCP_NODELAY error");[15;29Hnewfd > maxfd) { maxfd = newfd; }          [16;25HFD_SET(newfd, &conn);                [17;21H}                        [18;17H} else if (handle_data(fd, ptr)) {[19;17H    if (verbose) printf("connection closed - fd %d\n", fd);[20;21Hclose(fd);                                             [21;21HFD_CLR(fd, &conn);[22;17H}                     [23;13H} else if (FD_ISSET(fd, &except)) {[24;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[25;17Hclose(fd);                                              [25;1H[26;1H[K- xvcserver.c 296/304 97%[25;1H[1;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[2;21H                                                       [3;21H//               if (verbose)[4;21Hprintf("connection accepted - fd %d\n", newfd);[5;21Hif (newfd < 0) {                               [6;21H    perror("accept");[7;21H} else {             [8;21H    printf("setting TCP_NODELAY to 1\n");[9;25Hint flag = 1;                        [10;29HoptResult =[11;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[12;29H           (char *)&flag, sizeof(int));    [13;25Hif (optResult < 0) perror("TCP_NODELAY error");[14;29Hnewfd > maxfd) { maxfd = newfd; }          [15;25HFD_SET(newfd, &conn);                [16;21H}                        [17;17H} else if (handle_data(fd, ptr)) {[18;17H    if (verbose) printf("connection closed - fd %d\n", fd);[19;21Hclose(fd);                                             [20;21HFD_CLR(fd, &conn);[21;17H}                     [22;13H} else if (FD_ISSET(fd, &except)) {[23;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[24;17Hclose(fd);                                              [25;17HFD_CLR(fd, &conn);[25;1H[26;1H[K- xvcserver.c 297/304 97%[25;1H[1;21H                                                       [2;21H//               if (verbose)[3;21Hprintf("connection accepted - fd %d\n", newfd);[4;21Hif (newfd < 0) {                               [5;21H    perror("accept");[6;21H} else {             [7;21H    printf("setting TCP_NODELAY to 1\n");[8;25Hint flag = 1;                        [9;29HoptResult =[10;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[11;29H           (char *)&flag, sizeof(int));    [12;25Hif (optResult < 0) perror("TCP_NODELAY error");[13;29Hnewfd > maxfd) { maxfd = newfd; }          [14;25HFD_SET(newfd, &conn);                [15;21H}                        [16;17H} else if (handle_data(fd, ptr)) {[17;17H    if (verbose) printf("connection closed - fd %d\n", fd);[18;21Hclose(fd);                                             [19;21HFD_CLR(fd, &conn);[20;17H}                     [21;13H} else if (FD_ISSET(fd, &except)) {[22;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[23;17Hclose(fd);                                              [24;17HFD_CLR(fd, &conn);[25;17Hif (fd == s) break;[25;1H[26;1H[K- xvcserver.c 298/304 98%[25;1H[1;21H//               if (verbose)[2;21Hprintf("connection accepted - fd %d\n", newfd);[3;21Hif (newfd < 0) {                               [4;21H    perror("accept");[5;21H} else {             [6;21H    printf("setting TCP_NODELAY to 1\n");[7;25Hint flag = 1;                        [8;29HoptResult =[9;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[10;29H           (char *)&flag, sizeof(int));    [11;25Hif (optResult < 0) perror("TCP_NODELAY error");[12;29Hnewfd > maxfd) { maxfd = newfd; }          [13;25HFD_SET(newfd, &conn);                [14;21H}                        [15;17H} else if (handle_data(fd, ptr)) {[16;17H    if (verbose) printf("connection closed - fd %d\n", fd);[17;21Hclose(fd);                                             [18;21HFD_CLR(fd, &conn);[19;17H}                     [20;13H} else if (FD_ISSET(fd, &except)) {[21;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[22;17Hclose(fd);                                              [23;17HFD_CLR(fd, &conn);[24;17Hif (fd == s) break;[25;13H}                      [25;1H[26;1H[K- xvcserver.c 299/304 98%[25;1H[1;21Hprintf("connection accepted - fd %d\n", newfd);[2;21Hif (newfd < 0) {                               [3;21H    perror("accept");[4;21H} else {             [5;21H    printf("setting TCP_NODELAY to 1\n");[6;25Hint flag = 1;                        [7;29HoptResult =[8;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[9;29H           (char *)&flag, sizeof(int));    [10;25Hif (optResult < 0) perror("TCP_NODELAY error");[11;29Hnewfd > maxfd) { maxfd = newfd; }          [12;25HFD_SET(newfd, &conn);                [13;21H}                        [14;17H} else if (handle_data(fd, ptr)) {[15;17H    if (verbose) printf("connection closed - fd %d\n", fd);[16;21Hclose(fd);                                             [17;21HFD_CLR(fd, &conn);[18;17H}                     [19;13H} else if (FD_ISSET(fd, &except)) {[20;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[21;17Hclose(fd);                                              [22;17HFD_CLR(fd, &conn);[23;17Hif (fd == s) break;[24;13H}                      [25;9H}    [25;1H[26;1H[K- xvcserver.c 300/304 98%[25;1H[1;21Hif (newfd < 0) {                               [2;21H    perror("accept");[3;21H} else {             [4;21H    printf("setting TCP_NODELAY to 1\n");[5;25Hint flag = 1;                        [6;29HoptResult =[7;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[8;29H           (char *)&flag, sizeof(int));    [9;25Hif (optResult < 0) perror("TCP_NODELAY error");[10;29Hnewfd > maxfd) { maxfd = newfd; }          [11;25HFD_SET(newfd, &conn);                [12;21H}                        [13;17H} else if (handle_data(fd, ptr)) {[14;17H    if (verbose) printf("connection closed - fd %d\n", fd);[15;21Hclose(fd);                                             [16;21HFD_CLR(fd, &conn);[17;17H}                     [18;13H} else if (FD_ISSET(fd, &except)) {[19;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[20;17Hclose(fd);                                              [21;17HFD_CLR(fd, &conn);[22;17Hif (fd == s) break;[23;13H}                      [24;9H}    [25;5H}    [25;1H[26;1H[K- xvcserver.c 301/304 99%[25;1H[1;21H    perror("accept");[2;21H} else {             [3;21H    printf("setting TCP_NODELAY to 1\n");[4;25Hint flag = 1;                        [5;29HoptResult =[6;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[7;29H           (char *)&flag, sizeof(int));    [8;25Hif (optResult < 0) perror("TCP_NODELAY error");[9;29Hnewfd > maxfd) { maxfd = newfd; }          [10;25HFD_SET(newfd, &conn);                [11;21H}                        [12;17H} else if (handle_data(fd, ptr)) {[13;17H    if (verbose) printf("connection closed - fd %d\n", fd);[14;21Hclose(fd);                                             [15;21HFD_CLR(fd, &conn);[16;17H}                     [17;13H} else if (FD_ISSET(fd, &except)) {[18;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[19;17Hclose(fd);                                              [20;17HFD_CLR(fd, &conn);[21;17Hif (fd == s) break;[22;13H}                      [23;9H}    [24;5H}    [25;5Hmunmap((void *)ptr, MAP_SIZE);[25;1H[26;1H[K- xvcserver.c 302/304 99%[25;1H[1;21H} else {             [2;21H    printf("setting TCP_NODELAY to 1\n");[3;25Hint flag = 1;                        [4;29HoptResult =[5;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[6;29H           (char *)&flag, sizeof(int));    [7;25Hif (optResult < 0) perror("TCP_NODELAY error");[8;29Hnewfd > maxfd) { maxfd = newfd; }          [9;25HFD_SET(newfd, &conn);                [10;21H}                        [11;17H} else if (handle_data(fd, ptr)) {[12;17H    if (verbose) printf("connection closed - fd %d\n", fd);[13;21Hclose(fd);                                             [14;21HFD_CLR(fd, &conn);[15;17H}                     [16;13H} else if (FD_ISSET(fd, &except)) {[17;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[18;17Hclose(fd);                                              [19;17HFD_CLR(fd, &conn);[20;17Hif (fd == s) break;[21;13H}                      [22;9H}    [23;5H}    [24;5Hmunmap((void *)ptr, MAP_SIZE);[25;5Hreturn 0;                     [25;1H[26;1H[K- xvcserver.c 303/304 99%[25;1H[1;21H    printf("setting TCP_NODELAY to 1\n");[2;25Hint flag = 1;                        [3;29HoptResult =[4;25H    setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[5;29H           (char *)&flag, sizeof(int));    [6;25Hif (optResult < 0) perror("TCP_NODELAY error");[7;29Hnewfd > maxfd) { maxfd = newfd; }          [8;25HFD_SET(newfd, &conn);                [9;21H}                        [10;17H} else if (handle_data(fd, ptr)) {[11;17H    if (verbose) printf("connection closed - fd %d\n", fd);[12;21Hclose(fd);                                             [13;21HFD_CLR(fd, &conn);[14;17H}                     [15;13H} else if (FD_ISSET(fd, &except)) {[16;13H    if (verbose) printf("connection aborted - fd %d\n", fd);[17;17Hclose(fd);                                              [18;17HFD_CLR(fd, &conn);[19;17Hif (fd == s) break;[20;13H}                      [21;9H}    [22;5H}    [23;5Hmunmap((void *)ptr, MAP_SIZE);[24;5Hreturn 0;                     [25;1H}            [25;1H[26;1H[K- xvcserver.c 304/304 100%[25;1H[25;1H[25;1H[25;1H[24;1H[26;1H[K- xvcserver.c 303/304 99%[24;1H[23;1H[26;1H[K- xvcserver.c 302/304 99%[23;1H[22;1H[26;1H[K- xvcserver.c 301/304 99%[22;1H[21;1H[26;1H[K- xvcserver.c 300/304 98%[21;1H[20;1H[26;1H[K- xvcserver.c 299/304 98%[20;1H[19;1H[26;1H[K- xvcserver.c 298/304 98%[19;1H[18;1H[26;1H[K- xvcserver.c 297/304 97%[18;1H[17;1H[26;1H[K- xvcserver.c 296/304 97%[17;1H[16;1H[26;1H[K- xvcserver.c 295/304 97%[16;1H[15;1H[26;1H[K- xvcserver.c 294/304 96%[15;1H[14;1H[26;1H[K- xvcserver.c 293/304 96%[14;1H[13;1H[26;1H[K- xvcserver.c 292/304 96%[13;1H[12;1H[26;1H[K- xvcserver.c 291/304 95%[12;1H[11;1H[26;1H[K- xvcserver.c 290/304 95%[11;1H[10;1H[26;1H[K- xvcserver.c 289/304 95%[10;1H[9;1H[26;1H[K- xvcserver.c 288/304 94%[9;1H[8;1H[26;1H[K- xvcserver.c 287/304 94%[8;1H[7;1H[26;1H[K- xvcserver.c 286/304 94%[7;1H[6;1H[26;1H[K- xvcserver.c 285/304 93%[6;1H[5;1H[26;1H[K- xvcserver.c 284/304 93%[5;1H[4;1H[26;1H[K- xvcserver.c 283/304 93%[4;1H[3;1H[26;1H[K- xvcserver.c 282/304 92%[3;1H[2;1H[26;1H[K- xvcserver.c 281/304 92%[2;1H[1;1H[26;1H[K- xvcserver.c 280/304 92%[1;1H[1;21H} else {                                 [2;25Hprintf("setting TCP_NODELAY to 1\n");[3;29Hflag = 1;  [4;25Hint optResult =                                [5;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[6;25H               (char *)&flag, sizeof(int));    [7;29HoptResult < 0) perror("TCP_NODELAY error");[8;25Hif (newfd > maxfd) { maxfd = newfd; }[9;21H    FD_SET(newfd, &conn);[10;17H    }                             [11;17H} else if (handle_data(fd, ptr)) {                         [12;21Hif (verbose) printf("connection closed - fd %d\n", fd);[13;21Hclose(fd);        [14;17H    FD_CLR(fd, &conn);[15;13H    }                              [16;13H} else if (FD_ISSET(fd, &except)) {                         [17;17Hif (verbose) printf("connection aborted - fd %d\n", fd);[18;17Hclose(fd);        [19;17HFD_CLR(fd, &conn); [20;13H    if (fd == s) break;[21;9H    }[22;5H    }[23;5H}                             [24;5Hmunmap((void *)ptr, MAP_SIZE);[25;1H    return 0;[1;1H[26;1H[K- xvcserver.c 279/304 91%[1;1H[1;21H    perror("accept");[2;21H} else {                                 [3;25Hprintf("setting TCP_NODELAY to 1\n");[4;29Hflag = 1;  [5;25Hint optResult =                                [6;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[7;25H               (char *)&flag, sizeof(int));    [8;29HoptResult < 0) perror("TCP_NODELAY error");[9;25Hif (newfd > maxfd) { maxfd = newfd; }[10;21H    FD_SET(newfd, &conn);[11;17H    }                             [12;17H} else if (handle_data(fd, ptr)) {                         [13;21Hif (verbose) printf("connection closed - fd %d\n", fd);[14;21Hclose(fd);        [15;17H    FD_CLR(fd, &conn);[16;13H    }                              [17;13H} else if (FD_ISSET(fd, &except)) {                         [18;17Hif (verbose) printf("connection aborted - fd %d\n", fd);[19;17Hclose(fd);        [20;17HFD_CLR(fd, &conn); [21;13H    if (fd == s) break;[22;9H    }[23;5H    }[24;5H}                             [25;5Hmunmap((void *)ptr, MAP_SIZE);[1;1H[26;1H[K- xvcserver.c 278/304 91%[1;1H[1;21Hif (newfd < 0) {     [2;21H    perror("accept");[3;21H} else {                                 [4;25Hprintf("setting TCP_NODELAY to 1\n");[5;29Hflag = 1;  [6;25Hint optResult =                                [7;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[8;25H               (char *)&flag, sizeof(int));    [9;29HoptResult < 0) perror("TCP_NODELAY error");[10;25Hif (newfd > maxfd) { maxfd = newfd; }[11;21H    FD_SET(newfd, &conn);[12;17H    }                             [13;17H} else if (handle_data(fd, ptr)) {                         [14;21Hif (verbose) printf("connection closed - fd %d\n", fd);[15;21Hclose(fd);        [16;17H    FD_CLR(fd, &conn);[17;13H    }                              [18;13H} else if (FD_ISSET(fd, &except)) {                         [19;17Hif (verbose) printf("connection aborted - fd %d\n", fd);[20;17Hclose(fd);        [21;17HFD_CLR(fd, &conn); [22;13H    if (fd == s) break;[23;9H    }[24;5H    }[25;5H}                             [1;1H[26;1H[K- xvcserver.c 277/304 91%[1;1H[1;21Hprintf("connection accepted - fd %d\n", newfd);[2;21Hif (newfd < 0) {     [3;21H    perror("accept");[4;21H} else {                                 [5;25Hprintf("setting TCP_NODELAY to 1\n");[6;29Hflag = 1;  [7;25Hint optResult =                                [8;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[9;25H               (char *)&flag, sizeof(int));    [10;29HoptResult < 0) perror("TCP_NODELAY error");[11;25Hif (newfd > maxfd) { maxfd = newfd; }[12;21H    FD_SET(newfd, &conn);[13;17H    }                             [14;17H} else if (handle_data(fd, ptr)) {                         [15;21Hif (verbose) printf("connection closed - fd %d\n", fd);[16;21Hclose(fd);        [17;17H    FD_CLR(fd, &conn);[18;13H    }                              [19;13H} else if (FD_ISSET(fd, &except)) {                         [20;17Hif (verbose) printf("connection aborted - fd %d\n", fd);[21;17Hclose(fd);        [22;17HFD_CLR(fd, &conn); [23;13H    if (fd == s) break;[24;9H    }[25;5H    }[1;1H[26;1H[K- xvcserver.c 276/304 90%[1;1H[1;21H//               if (verbose)                  [2;21Hprintf("connection accepted - fd %d\n", newfd);[3;21Hif (newfd < 0) {     [4;21H    perror("accept");[5;21H} else {                                 [6;25Hprintf("setting TCP_NODELAY to 1\n");[7;29Hflag = 1;  [8;25Hint optResult =                                [9;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[10;25H               (char *)&flag, sizeof(int));    [11;29HoptResult < 0) perror("TCP_NODELAY error");[12;25Hif (newfd > maxfd) { maxfd = newfd; }[13;21H    FD_SET(newfd, &conn);[14;17H    }                             [15;17H} else if (handle_data(fd, ptr)) {                         [16;21Hif (verbose) printf("connection closed - fd %d\n", fd);[17;21Hclose(fd);        [18;17H    FD_CLR(fd, &conn);[19;13H    }                              [20;13H} else if (FD_ISSET(fd, &except)) {                         [21;17Hif (verbose) printf("connection aborted - fd %d\n", fd);[22;17Hclose(fd);        [23;17HFD_CLR(fd, &conn); [24;13H    if (fd == s) break;[25;9H    }[1;1H[26;1H[K- xvcserver.c 275/304 90%[1;1H[1;21H                             [2;21H//               if (verbose)                  [3;21Hprintf("connection accepted - fd %d\n", newfd);[4;21Hif (newfd < 0) {     [5;21H    perror("accept");[6;21H} else {                                 [7;25Hprintf("setting TCP_NODELAY to 1\n");[8;29Hflag = 1;  [9;25Hint optResult =                                [10;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[11;25H               (char *)&flag, sizeof(int));    [12;29HoptResult < 0) perror("TCP_NODELAY error");[13;25Hif (newfd > maxfd) { maxfd = newfd; }[14;21H    FD_SET(newfd, &conn);[15;17H    }                             [16;17H} else if (handle_data(fd, ptr)) {                         [17;21Hif (verbose) printf("connection closed - fd %d\n", fd);[18;21Hclose(fd);        [19;17H    FD_CLR(fd, &conn);[20;13H    }                              [21;13H} else if (FD_ISSET(fd, &except)) {                         [22;17Hif (verbose) printf("connection aborted - fd %d\n", fd);[23;17Hclose(fd);        [24;17HFD_CLR(fd, &conn); [25;13H    if (fd == s) break;[1;1H[26;1H[K- xvcserver.c 274/304 90%[1;1H[26;1H[K- xvcserver.c 273/304 89%[1;1H[26;1H[K- xvcserver.c 272/304 89%[1;1H[26;1H[K- xvcserver.c 271/304 89%[1;1H[26;1H[K- xvcserver.c 270/304 88%[1;1H[26;1H[K- xvcserver.c 269/304 88%[1;1H[26;1H[K- xvcserver.c 268/304 88%[1;1H[26;1H[K- xvcserver.c 267/304 87%[1;1H[26;1H[K- xvcserver.c 266/304 87%[1;1H[26;1H[K- xvcserver.c 265/304 87%[1;1H[26;1H[K- xvcserver.c 264/304 86%[1;1H[1;13Hperror("select");[2;13Hbreak;                               [3;9H}                                                          [4;21H                [5;9Hfor (fd = 0; fd <= maxfd; ++fd) {[6;13Hif (FD_ISSET(fd, &read)) {[7;17Hif (fd == s) {                               [8;21Hint       newfd; [9;21Hsocklen_t nsize = sizeof(address);[10;29H                                           [11;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[12;25H                                               [13;21H//               if (verbose)            [14;21Hprintf("connection accepted - fd %d\n", newfd);[15;21Hif (newfd < 0) {[16;17H        perror("accept");         [17;21H} else {                                               [18;21H    printf("setting TCP_NODELAY to 1\n");[19;21H    int flag = 1; [20;17H        int optResult =[21;13H                setsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[22;17H                       (char *)&flag, sizeof(int));     [23;17H        if (optResult < 0) perror("TCP_NODELAY error");[24;17H        if (newfd > maxfd) { maxfd = newfd; }[25;17H        FD_SET(newfd, &conn);[1;1H[26;1H[K- xvcserver.c 263/304 86%[1;1H[1;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[2;13Hperror("select");[3;9H    break;[4;9H}[5;9H                                 [6;9Hfor (fd = 0; fd <= maxfd; ++fd) {[7;13Hif (FD_ISSET(fd, &read)) {[8;17Hif (fd == s) {      [9;21Hint       newfd;                  [10;21Hsocklen_t nsize = sizeof(address);[11;21H                                                       [12;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[13;21H                             [14;21H//               if (verbose)                  [15;21Hprintf("connection accepted - fd %d\n", newfd);[16;21Hif (newfd < 0) {     [17;21H    perror("accept");[18;21H} else {                                 [19;25Hprintf("setting TCP_NODELAY to 1\n");[20;29Hflag = 1;  [21;25Hint optResult =                                [22;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[23;25H               (char *)&flag, sizeof(int));    [24;29HoptResult < 0) perror("TCP_NODELAY error");[25;25Hif (newfd > maxfd) { maxfd = newfd; }[1;1H[26;1H[K- xvcserver.c 262/304 86%[1;1H[1;9H                                                  [2;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[3;13Hperror("select");[4;9H    break;[5;9H}[6;9H                                 [7;9Hfor (fd = 0; fd <= maxfd; ++fd) {[8;13Hif (FD_ISSET(fd, &read)) {[9;17Hif (fd == s) {      [10;21Hint       newfd;                  [11;21Hsocklen_t nsize = sizeof(address);[12;21H                                                       [13;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[14;21H                             [15;21H//               if (verbose)                  [16;21Hprintf("connection accepted - fd %d\n", newfd);[17;21Hif (newfd < 0) {     [18;21H    perror("accept");[19;21H} else {                                 [20;25Hprintf("setting TCP_NODELAY to 1\n");[21;29Hflag = 1;  [22;25Hint optResult =                                [23;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[24;25H               (char *)&flag, sizeof(int));    [25;29HoptResult < 0) perror("TCP_NODELAY error");[1;1H[26;1H[K- xvcserver.c 261/304 85%[1;1H[1;9Hint    fd;[2;9H                                                  [3;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[4;13Hperror("select");[5;9H    break;[6;9H}[7;9H                                 [8;9Hfor (fd = 0; fd <= maxfd; ++fd) {[9;13Hif (FD_ISSET(fd, &read)) {[10;17Hif (fd == s) {      [11;21Hint       newfd;                  [12;21Hsocklen_t nsize = sizeof(address);[13;21H                                                       [14;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[15;21H                             [16;21H//               if (verbose)                  [17;21Hprintf("connection accepted - fd %d\n", newfd);[18;21Hif (newfd < 0) {     [19;21H    perror("accept");[20;21H} else {                                 [21;25Hprintf("setting TCP_NODELAY to 1\n");[22;29Hflag = 1;  [23;25Hint optResult =                                [24;29Hsetsockopt(newfd, IPPROTO_TCP, TCP_NODELAY,[25;25H               (char *)&flag, sizeof(int));    [1;1H[26;1H[K- xvcserver.c 260/304 85%[1;1H[26;1H[K- xvcserver.c 259/304 85%[1;1H[26;1H[K- xvcserver.c 258/304 84%[1;1H[26;1H[K- xvcserver.c 257/304 84%[1;1H[26;1H[K- xvcserver.c 256/304 84%[1;1H[26;1H[K- xvcserver.c 255/304 83%[1;1H[26;1H[K- xvcserver.c 254/304 83%[1;1H[26;1H[K- xvcserver.c 253/304 83%[1;1H[26;1H[K- xvcserver.c 252/304 82%[1;1H[26;1H[K- xvcserver.c 251/304 82%[1;1H[1;5Hfd_set conn;  [2;5Hint    maxfd = 0;[3;9H                                                  [4;5HFD_ZERO(&conn);          [5;5HFD_SET(s, &conn);[6;9H [7;5Hmaxfd = s;[8;9H                                 [9;5Hwhile (1) {                       [10;9Hfd_set read = conn, except = conn;[11;9Hint    fd;                  [12;21H                                  [13;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[14;13Hperror("select");                                              [15;13Hbreak;[16;9H}                                        [17;21H                                               [18;9Hfor (fd = 0; fd <= maxfd; ++fd) {[19;13Hif (FD_ISSET(fd, &read)) {   [20;17Hif (fd == s) {[21;21Hint       newfd;                         [22;21Hsocklen_t nsize = sizeof(address);[23;25H               [24;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[25;40H                            [1;1H[26;1H[K- xvcserver.c 250/304 82%[1;1H[2;1H[26;1H[K- xvcserver.c 251/304 82%[2;1H[3;1H[26;1H[K- xvcserver.c 252/304 82%[3;1H[4;1H[26;1H[K- xvcserver.c 253/304 83%[4;1H[5;1H[26;1H[K- xvcserver.c 254/304 83%[5;1H[6;1H[26;1H[K- xvcserver.c 255/304 83%[6;1H[7;1H[26;1H[K- xvcserver.c 256/304 84%[7;1H[8;1H[26;1H[K- xvcserver.c 257/304 84%[8;1H[9;1H[26;1H[K- xvcserver.c 258/304 84%[9;1H[10;1H[26;1H[K- xvcserver.c 259/304 85%[10;1H[11;1H[26;1H[K- xvcserver.c 260/304 85%[11;1H[12;1H[26;1H[K- xvcserver.c 261/304 85%[12;1H[13;1H[26;1H[K- xvcserver.c 262/304 86%[13;1H[12;1H[26;1H[K- xvcserver.c 261/304 85%[12;1H[11;1H[26;1H[K- xvcserver.c 260/304 85%[11;1H[10;1H[26;1H[K- xvcserver.c 259/304 85%[10;1H[9;1H[26;1H[K- xvcserver.c 258/304 84%[9;1H[8;1H[26;1H[K- xvcserver.c 257/304 84%[8;1H[7;1H[26;1H[K- xvcserver.c 256/304 84%[7;1H[6;1H[26;1H[K- xvcserver.c 255/304 83%[6;1H[5;1H[26;1H[K- xvcserver.c 254/304 83%[5;1H[4;1H[26;1H[K- xvcserver.c 253/304 83%[4;1H[3;1H[26;1H[K- xvcserver.c 252/304 82%[3;1H[2;1H[26;1H[K- xvcserver.c 251/304 82%[2;1H[1;1H[26;1H[K- xvcserver.c 250/304 82%[1;1H[1;5H            [2;5Hfd_set conn;     [3;5Hint    maxfd = 0;[4;5H               [5;8HZERO(&conn);  [6;5HFD_SET(s, &conn);[7;5H          [8;5Hmaxfd = s;[9;5H           [10;5Hwhile (1) {                           [11;9Hfd_set read = conn, except = conn;[12;9Hint    fd;[13;9H                                                  [14;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[15;13Hperror("select");[16;9H    break;[17;9H}[18;9H                                 [19;9Hfor (fd = 0; fd <= maxfd; ++fd) {[20;13Hif (FD_ISSET(fd, &read)) {[21;17Hif (fd == s) {      [22;21Hint       newfd;                  [23;21Hsocklen_t nsize = sizeof(address);[24;21H                                                       [25;21Hnewfd = accept(s, (struct sockaddr *)&address, &nsize);[1;1H[26;1H[K- xvcserver.c 249/304 81%[1;1H[1;5H}[2;5H            [3;5Hfd_set conn;     [4;5Hint    maxfd = 0;[5;5H               [6;8HZERO(&conn);  [7;5HFD_SET(s, &conn);[8;5H          [9;5Hmaxfd = s;[10;5H           [11;5Hwhile (1) {                           [12;9Hfd_set read = conn, except = conn;[13;9Hint    fd;[14;9H                                                  [15;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[16;13Hperror("select");[17;9H    break;[18;9H}[19;9H                                 [20;9Hfor (fd = 0; fd <= maxfd; ++fd) {[21;13Hif (FD_ISSET(fd, &read)) {[22;17Hif (fd == s) {      [23;21Hint       newfd;                  [24;21Hsocklen_t nsize = sizeof(address);[25;21H                                                       [1;1H[26;1H[K- xvcserver.c 248/304 81%[1;1H[1;5H    return 1;[2;5H}[3;5H            [4;5Hfd_set conn;     [5;5Hint    maxfd = 0;[6;5H               [7;8HZERO(&conn);  [8;5HFD_SET(s, &conn);[9;5H          [10;5Hmaxfd = s;[11;5H           [12;5Hwhile (1) {                           [13;9Hfd_set read = conn, except = conn;[14;9Hint    fd;[15;9H                                                  [16;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[17;13Hperror("select");[18;9H    break;[19;9H}[20;9H                                 [21;9Hfor (fd = 0; fd <= maxfd; ++fd) {[22;13Hif (FD_ISSET(fd, &read)) {[23;17Hif (fd == s) {      [24;21Hint       newfd;                  [25;21Hsocklen_t nsize = sizeof(address);[1;1H[26;1H[K- xvcserver.c 247/304 81%[1;1H[1;9Hperror("listen");[2;5H    return 1;[3;5H}[4;5H            [5;5Hfd_set conn;     [6;5Hint    maxfd = 0;[7;5H               [8;8HZERO(&conn);  [9;5HFD_SET(s, &conn);[10;5H          [11;5Hmaxfd = s;[12;5H           [13;5Hwhile (1) {                           [14;9Hfd_set read = conn, except = conn;[15;9Hint    fd;[16;9H                                                  [17;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[18;13Hperror("select");[19;9H    break;[20;9H}[21;9H                                 [22;9Hfor (fd = 0; fd <= maxfd; ++fd) {[23;13Hif (FD_ISSET(fd, &read)) {[24;17Hif (fd == s) {      [25;21Hint       newfd;                  [1;1H[26;1H[K- xvcserver.c 246/304 80%[1;1H[1;5Hif (listen(s, 0) < 0) {[2;9Hperror("listen");[3;5H    return 1;[4;5H}[5;5H            [6;5Hfd_set conn;     [7;5Hint    maxfd = 0;[8;5H               [9;8HZERO(&conn);  [10;5HFD_SET(s, &conn);[11;5H          [12;5Hmaxfd = s;[13;5H           [14;5Hwhile (1) {                           [15;9Hfd_set read = conn, except = conn;[16;9Hint    fd;[17;9H                                                  [18;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[19;13Hperror("select");[20;9H    break;[21;9H}[22;9H                                 [23;9Hfor (fd = 0; fd <= maxfd; ++fd) {[24;13Hif (FD_ISSET(fd, &read)) {[25;17Hif (fd == s) {      [1;1H[26;1H[K- xvcserver.c 245/304 80%[1;1H[1;5H                       [2;5Hif (listen(s, 0) < 0) {[3;9Hperror("listen");[4;5H    return 1;[5;5H}[6;5H            [7;5Hfd_set conn;     [8;5Hint    maxfd = 0;[9;5H               [10;8HZERO(&conn);  [11;5HFD_SET(s, &conn);[12;5H          [13;5Hmaxfd = s;[14;5H           [15;5Hwhile (1) {                           [16;9Hfd_set read = conn, except = conn;[17;9Hint    fd;[18;9H                                                  [19;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[20;13Hperror("select");[21;9H    break;[22;9H}[23;9H                                 [24;9Hfor (fd = 0; fd <= maxfd; ++fd) {[25;13Hif (FD_ISSET(fd, &read)) {[1;1H[26;1H[K- xvcserver.c 244/304 80%[1;1H[1;5H}[2;5H                       [3;5Hif (listen(s, 0) < 0) {[4;9Hperror("listen");[5;5H    return 1;[6;5H}[7;5H            [8;5Hfd_set conn;     [9;5Hint    maxfd = 0;[10;5H               [11;8HZERO(&conn);  [12;5HFD_SET(s, &conn);[13;5H          [14;5Hmaxfd = s;[15;5H           [16;5Hwhile (1) {                           [17;9Hfd_set read = conn, except = conn;[18;9Hint    fd;[19;9H                                                  [20;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[21;13Hperror("select");[22;9H    break;[23;9H}[24;9H                                 [25;9Hfor (fd = 0; fd <= maxfd; ++fd) {[1;1H[26;1H[K- xvcserver.c 243/304 79%[1;1H[1;5H    return 1;[2;5H}[3;5H                       [4;5Hif (listen(s, 0) < 0) {[5;9Hperror("listen");[6;5H    return 1;[7;5H}[8;5H            [9;5Hfd_set conn;     [10;5Hint    maxfd = 0;[11;5H               [12;8HZERO(&conn);  [13;5HFD_SET(s, &conn);[14;5H          [15;5Hmaxfd = s;[16;5H           [17;5Hwhile (1) {                           [18;9Hfd_set read = conn, except = conn;[19;9Hint    fd;[20;9H                                                  [21;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[22;13Hperror("select");[23;9H    break;[24;9H}[25;9H                                 [1;1H[26;1H[K- xvcserver.c 242/304 79%[1;1H[1;9Hperror("bind");[2;5H    return 1;[3;5H}[4;5H                       [5;5Hif (listen(s, 0) < 0) {[6;9Hperror("listen");[7;5H    return 1;[8;5H}[9;5H            [10;5Hfd_set conn;     [11;5Hint    maxfd = 0;[12;5H               [13;8HZERO(&conn);  [14;5HFD_SET(s, &conn);[15;5H          [16;5Hmaxfd = s;[17;5H           [18;5Hwhile (1) {                           [19;9Hfd_set read = conn, except = conn;[20;9Hint    fd;[21;9H                                                  [22;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[23;13Hperror("select");[24;9H    break;[25;9H}[1;1H[26;1H[K- xvcserver.c 241/304 79%[1;1H[1;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[2;9Hperror("bind");[3;5H    return 1;[4;5H}[5;5H                       [6;5Hif (listen(s, 0) < 0) {[7;9Hperror("listen");[8;5H    return 1;[9;5H}[10;5H            [11;5Hfd_set conn;     [12;5Hint    maxfd = 0;[13;5H               [14;8HZERO(&conn);  [15;5HFD_SET(s, &conn);[16;5H          [17;5Hmaxfd = s;[18;5H           [19;5Hwhile (1) {                           [20;9Hfd_set read = conn, except = conn;[21;9Hint    fd;[22;9H                                                  [23;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[24;13Hperror("select");[25;9H    break;[1;1H[26;1H[K- xvcserver.c 240/304 78%[1;1H[1;5H                                                                [2;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[3;9Hperror("bind");[4;5H    return 1;[5;5H}[6;5H                       [7;5Hif (listen(s, 0) < 0) {[8;9Hperror("listen");[9;5H    return 1;[10;5H}[11;5H            [12;5Hfd_set conn;     [13;5Hint    maxfd = 0;[14;5H               [15;8HZERO(&conn);  [16;5HFD_SET(s, &conn);[17;5H          [18;5Hmaxfd = s;[19;5H           [20;5Hwhile (1) {                           [21;9Hfd_set read = conn, except = conn;[22;9Hint    fd;[23;9H                                                  [24;9Hif (select(maxfd + 1, &read, 0, &except, 0) < 0) {[25;13Hperror("select");[1;1H[26;1H[K- xvcserver.c 239/304 78%[1;1H[26;1H[K- xvcserver.c 238/304 78%[1;1H[26;1H[K- xvcserver.c 237/304 77%[1;1H[26;1H[K- xvcserver.c 236/304 77%[1;1H[26;1H[K- xvcserver.c 235/304 77%[1;1H[26;1H[K- xvcserver.c 234/304 76%[1;1H[26;1H[K- xvcserver.c 233/304 76%[1;1H[26;1H[K- xvcserver.c 232/304 76%[1;1H[26;1H[K- xvcserver.c 231/304 75%[1;1H[26;1H[K- xvcserver.c 230/304 75%[1;1H[26;1H[K- xvcserver.c 229/304 75%[1;1H[1;9HNULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[2;9Hptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");        [3;9H               [4;5Hclose(fd_uio);[5;5H [6;5Hi = 1;[7;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[8;9H                 [9;5Haddress.sin_addr.s_addr = INADDR_ANY;[10;5Haddress.sin_port        = htons(2542);[11;5Haddress.sin_family      = AF_INET;[12;5H            [13;6Hf (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[14;9Hperror("bind");[15;5H    return 1;  [16;5H}                [18;5Hif (listen(s, 0) < 0) {[19;9Hperror("listen");[20;5H    return 1;[21;5H}                                     [22;9H          [23;5Hfd_set conn;[24;5Hint    maxfd = 0;                                     [25;13H                 [1;1H[26;1H[K- xvcserver.c 228/304 75%[1;1H[1;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [2;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[3;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[4;5H              [5;5Hclose(fd_uio);[6;5H      [7;5Hi = 1;                                                [8;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[9;5H                                     [10;17Haddr.s_addr = INADDR_ANY; [11;17Hport        = htons(2542);[12;5Haddress.sin_family      = AF_INET;[13;5H                                                                [14;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[15;9Hperror("bind");[16;5H    return 1;[17;5H}[18;5H                       [19;5Hif (listen(s, 0) < 0) {[20;9Hperror("listen");[21;5H    return 1;[22;5H}[23;5H            [24;5Hfd_set conn;     [25;5Hint    maxfd = 0;[1;1H[26;1H[K- xvcserver.c 227/304 74%[1;1H[1;5H                                               [2;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [3;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[4;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[5;5H              [6;5Hclose(fd_uio);[7;5H      [8;5Hi = 1;                                                [9;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[10;5H                                     [11;17Haddr.s_addr = INADDR_ANY; [12;17Hport        = htons(2542);[13;5Haddress.sin_family      = AF_INET;[14;5H                                                                [15;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[16;9Hperror("bind");[17;5H    return 1;[18;5H}[19;5H                       [20;5Hif (listen(s, 0) < 0) {[21;9Hperror("listen");[22;5H    return 1;[23;5H}[24;5H            [25;5Hfd_set conn;     [1;1H[26;1H[K- xvcserver.c 226/304 74%[1;1H[1;5H}[2;5H                                               [3;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [4;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[5;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[6;5H              [7;5Hclose(fd_uio);[8;5H      [9;5Hi = 1;                                                [10;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[11;5H                                     [12;17Haddr.s_addr = INADDR_ANY; [13;17Hport        = htons(2542);[14;5Haddress.sin_family      = AF_INET;[15;5H                                                                [16;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[17;9Hperror("bind");[18;5H    return 1;[19;5H}[20;5H                       [21;5Hif (listen(s, 0) < 0) {[22;9Hperror("listen");[23;5H    return 1;[24;5H}[25;5H            [1;1H[26;1H[K- xvcserver.c 225/304 74%[1;1H[1;5H    return 1;[2;5H}[3;5H                                               [4;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [5;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[6;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[7;5H              [8;5Hclose(fd_uio);[9;5H      [10;5Hi = 1;                                                [11;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[12;5H                                     [13;17Haddr.s_addr = INADDR_ANY; [14;17Hport        = htons(2542);[15;5Haddress.sin_family      = AF_INET;[16;5H                                                                [17;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[18;9Hperror("bind");[19;5H    return 1;[20;5H}[21;5H                       [22;5Hif (listen(s, 0) < 0) {[23;9Hperror("listen");[24;5H    return 1;[25;5H}[1;1H[26;1H[K- xvcserver.c 224/304 73%[1;1H[1;9Hperror("socket");[2;5H    return 1;[3;5H}[4;5H                                               [5;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [6;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[7;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[8;5H              [9;5Hclose(fd_uio);[10;5H      [11;5Hi = 1;                                                [12;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[13;5H                                     [14;17Haddr.s_addr = INADDR_ANY; [15;17Hport        = htons(2542);[16;5Haddress.sin_family      = AF_INET;[17;5H                                                                [18;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[19;9Hperror("bind");[20;5H    return 1;[21;5H}[22;5H                       [23;5Hif (listen(s, 0) < 0) {[24;9Hperror("listen");[25;5H    return 1;[1;1H[26;1H[K- xvcserver.c 223/304 73%[1;1H[1;5Hif (s < 0) {         [2;9Hperror("socket");[3;5H    return 1;[4;5H}[5;5H                                               [6;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [7;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[8;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[9;5H              [10;5Hclose(fd_uio);[11;5H      [12;5Hi = 1;                                                [13;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[14;5H                                     [15;17Haddr.s_addr = INADDR_ANY; [16;17Hport        = htons(2542);[17;5Haddress.sin_family      = AF_INET;[18;5H                                                                [19;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[20;9Hperror("bind");[21;5H    return 1;[22;5H}[23;5H                       [24;5Hif (listen(s, 0) < 0) {[25;9Hperror("listen");[1;1H[26;1H[K- xvcserver.c 222/304 73%[1;1H[1;5H            [2;5Hif (s < 0) {         [3;9Hperror("socket");[4;5H    return 1;[5;5H}[6;5H                                               [7;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [8;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[9;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[10;5H              [11;5Hclose(fd_uio);[12;5H      [13;5Hi = 1;                                                [14;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[15;5H                                     [16;17Haddr.s_addr = INADDR_ANY; [17;17Hport        = htons(2542);[18;5Haddress.sin_family      = AF_INET;[19;5H                                                                [20;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[21;9Hperror("bind");[22;5H    return 1;[23;5H}[24;5H                       [25;5Hif (listen(s, 0) < 0) {[1;1H[26;1H[K- xvcserver.c 221/304 72%[1;1H[1;5Hs = socket(AF_INET, SOCK_STREAM, 0);[2;5H            [3;5Hif (s < 0) {         [4;9Hperror("socket");[5;5H    return 1;[6;5H}[7;5H                                               [8;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [9;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[10;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[11;5H              [12;5Hclose(fd_uio);[13;5H      [14;5Hi = 1;                                                [15;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[16;5H                                     [17;17Haddr.s_addr = INADDR_ANY; [18;17Hport        = htons(2542);[19;5Haddress.sin_family      = AF_INET;[20;5H                                                                [21;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[22;9Hperror("bind");[23;5H    return 1;[24;5H}[25;5H                       [1;1H[26;1H[K- xvcserver.c 220/304 72%[1;1H[1;5H                                    [2;5Hs = socket(AF_INET, SOCK_STREAM, 0);[3;5H            [4;5Hif (s < 0) {         [5;9Hperror("socket");[6;5H    return 1;[7;5H}[8;5H                                               [9;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [10;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[11;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[12;5H              [13;5Hclose(fd_uio);[14;5H      [15;5Hi = 1;                                                [16;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[17;5H                                     [18;17Haddr.s_addr = INADDR_ANY; [19;17Hport        = htons(2542);[20;5Haddress.sin_family      = AF_INET;[21;5H                                                                [22;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[23;9Hperror("bind");[24;5H    return 1;[25;5H}[1;1H[26;1H[K- xvcserver.c 219/304 72%[1;1H[1;5H}[2;5H                                    [3;5Hs = socket(AF_INET, SOCK_STREAM, 0);[4;5H            [5;5Hif (s < 0) {         [6;9Hperror("socket");[7;5H    return 1;[8;5H}[9;5H                                               [10;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [11;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[12;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[13;5H              [14;5Hclose(fd_uio);[15;5H      [16;5Hi = 1;                                                [17;5Hsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i);[18;5H                                     [19;17Haddr.s_addr = INADDR_ANY; [20;17Hport        = htons(2542);[21;5Haddress.sin_family      = AF_INET;[22;5H                                                                [23;5Hif (bind(s, (struct sockaddr *)&address, sizeof(address)) < 0) {[24;9Hperror("bind");[25;5H    return 1;[1;1H[26;1H[K- xvcserver.c 218/304 71%[1;1H[26;1H[K- xvcserver.c 217/304 71%[1;1H[26;1H[K- xvcserver.c 216/304 71%[1;1H[26;1H[K- xvcserver.c 215/304 70%[1;1H[26;1H[K- xvcserver.c 214/304 70%[1;1H[26;1H[K- xvcserver.c 213/304 70%[1;1H[26;1H[K- xvcserver.c 212/304 69%[1;1H[26;1H[K- xvcserver.c 211/304 69%[1;1H[26;1H[K- xvcserver.c 210/304 69%[1;1H[26;1H[K- xvcserver.c 209/304 68%[1;1H[26;1H[K- xvcserver.c 208/304 68%[1;1H[1;5H// https://support.xilinx.com/s/article/974879?language=en_US[2;5H// The tutorial above says: "The original code for Zynq-7000 devices uses[3;5H// uio0, but for MPSoC devices, uio1 must be used." But debug_bridge is[4;5H// actually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[5;5H// And xvcServer.c in the git repo[6;5H// https://github.com/Xilinx/XilinxVirtualCable[7;5H// also uses uio0. (K. Okazaki)[8;5Hfd_uio = open("/dev/uio0", O_RDWR);[9;5Hif (fd_uio < 1) {[10;5H    fprintf(stderr, "Failed to Open UIO Device\n");[11;9Hreturn -1;                                                     [12;5H}                                                       [14;5Hs = socket(AF_INET, SOCK_STREAM, 0);[16;6Hf (s < 0) {[17;5H    perror("socket");                                 [18;9Hreturn 1;[19;5H}                                    [20;5H                                      [21;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap([22;9HNULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[23;9Hptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");        [24;9H               [25;5Hclose(fd_uio);[1;1H[26;1H[K- xvcserver.c 207/304 68%[1;1H[1;5H                                                             [2;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [3;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[4;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [5;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[6;8HAnd xvcServer.c in the git repo             [7;8Hhttps://github.com/Xilinx/XilinxVirtualCable[8;5H// also uses uio0. (K. Okazaki)    [9;5Hfd_uio = open("/dev/uio0", O_RDWR);[10;5Hif (fd_uio < 1) {                                  [11;9Hfprintf(stderr, "Failed to Open UIO Device\n");[12;5H    return -1;[13;5H}[14;5H                                    [15;5Hs = socket(AF_INET, SOCK_STREAM, 0);[16;5H            [17;5Hif (s < 0) {         [18;9Hperror("socket");[19;5H    return 1;[20;5H}[21;5H                                               [22;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [23;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[24;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[25;5H              [1;1H[26;1H[K- xvcserver.c 206/304 67%[1;1H[1;9H}[2;5H                                                             [3;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [4;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[5;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [6;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[7;8HAnd xvcServer.c in the git repo             [8;8Hhttps://github.com/Xilinx/XilinxVirtualCable[9;5H// also uses uio0. (K. Okazaki)    [10;5Hfd_uio = open("/dev/uio0", O_RDWR);[11;5Hif (fd_uio < 1) {                                  [12;9Hfprintf(stderr, "Failed to Open UIO Device\n");[13;5H    return -1;[14;5H}[15;5H                                    [16;5Hs = socket(AF_INET, SOCK_STREAM, 0);[17;5H            [18;5Hif (s < 0) {         [19;9Hperror("socket");[20;5H    return 1;[21;5H}[22;5H                                               [23;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [24;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[25;5Hif (ptr == MAP_FAILED) fprintf(stderr, "MMAP Failed\n");[1;1H[26;1H[K- xvcserver.c 205/304 67%[1;1H[1;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[2;9H}[3;5H                                                             [4;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [5;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[6;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [7;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[8;8HAnd xvcServer.c in the git repo             [9;8Hhttps://github.com/Xilinx/XilinxVirtualCable[10;5H// also uses uio0. (K. Okazaki)    [11;5Hfd_uio = open("/dev/uio0", O_RDWR);[12;5Hif (fd_uio < 1) {                                  [13;9Hfprintf(stderr, "Failed to Open UIO Device\n");[14;5H    return -1;[15;5H}[16;5H                                    [17;5Hs = socket(AF_INET, SOCK_STREAM, 0);[18;5H            [19;5Hif (s < 0) {         [20;9Hperror("socket");[21;5H    return 1;[22;5H}[23;5H                                               [24;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [25;5H    NULL, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_uio, 0);[1;1H[26;1H[K- xvcserver.c 204/304 67%[1;1H[1;19Hv': verbose = 1; break;                                  [2;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[3;9H}[4;5H                                                             [5;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [6;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[7;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [8;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[9;8HAnd xvcServer.c in the git repo             [10;8Hhttps://github.com/Xilinx/XilinxVirtualCable[11;5H// also uses uio0. (K. Okazaki)    [12;5Hfd_uio = open("/dev/uio0", O_RDWR);[13;5Hif (fd_uio < 1) {                                  [14;9Hfprintf(stderr, "Failed to Open UIO Device\n");[15;5H    return -1;[16;5H}[17;5H                                    [18;5Hs = socket(AF_INET, SOCK_STREAM, 0);[19;5H            [20;5Hif (s < 0) {         [21;9Hperror("socket");[22;5H    return 1;[23;5H}[24;5H                                               [25;5Hvolatile jtag_t *ptr = (volatile jtag_t *)mmap(                    [1;1H[26;1H[K- xvcserver.c 203/304 66%[1;1H[1;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[2;19Hv': verbose = 1; break;                                  [3;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[4;9H}[5;5H                                                             [6;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [7;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[8;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [9;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[10;8HAnd xvcServer.c in the git repo             [11;8Hhttps://github.com/Xilinx/XilinxVirtualCable[12;5H// also uses uio0. (K. Okazaki)    [13;5Hfd_uio = open("/dev/uio0", O_RDWR);[14;5Hif (fd_uio < 1) {                                  [15;9Hfprintf(stderr, "Failed to Open UIO Device\n");[16;5H    return -1;[17;5H}[18;5H                                    [19;5Hs = socket(AF_INET, SOCK_STREAM, 0);[20;5H            [21;5Hif (s < 0) {         [22;9Hperror("socket");[23;5H    return 1;[24;5H}[25;5H                                               [1;1H[26;1H[K- xvcserver.c 202/304 66%[1;1H[1;5H                                                        [2;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[3;19Hv': verbose = 1; break;                                  [4;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[5;9H}[6;5H                                                             [7;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [8;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[9;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [10;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[11;8HAnd xvcServer.c in the git repo             [12;8Hhttps://github.com/Xilinx/XilinxVirtualCable[13;5H// also uses uio0. (K. Okazaki)    [14;5Hfd_uio = open("/dev/uio0", O_RDWR);[15;5Hif (fd_uio < 1) {                                  [16;9Hfprintf(stderr, "Failed to Open UIO Device\n");[17;5H    return -1;[18;5H}[19;5H                                    [20;5Hs = socket(AF_INET, SOCK_STREAM, 0);[21;5H            [22;5Hif (s < 0) {         [23;9Hperror("socket");[24;5H    return 1;[25;5H}[1;1H[26;1H[K- xvcserver.c 201/304 66%[1;1H[1;5Hopterr = 0;[2;5H                                                        [3;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[4;19Hv': verbose = 1; break;                                  [5;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[6;9H}[7;5H                                                             [8;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [9;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[10;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [11;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[12;8HAnd xvcServer.c in the git repo             [13;8Hhttps://github.com/Xilinx/XilinxVirtualCable[14;5H// also uses uio0. (K. Okazaki)    [15;5Hfd_uio = open("/dev/uio0", O_RDWR);[16;5Hif (fd_uio < 1) {                                  [17;9Hfprintf(stderr, "Failed to Open UIO Device\n");[18;5H    return -1;[19;5H}[20;5H                                    [21;5Hs = socket(AF_INET, SOCK_STREAM, 0);[22;5H            [23;5Hif (s < 0) {         [24;9Hperror("socket");[25;5H    return 1;[1;1H[26;1H[K- xvcserver.c 200/304 65%[1;1H[1;5H           [2;5Hopterr = 0;[3;5H                                                        [4;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[5;19Hv': verbose = 1; break;                                  [6;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[7;9H}[8;5H                                                             [9;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [10;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[11;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [12;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[13;8HAnd xvcServer.c in the git repo             [14;8Hhttps://github.com/Xilinx/XilinxVirtualCable[15;5H// also uses uio0. (K. Okazaki)    [16;5Hfd_uio = open("/dev/uio0", O_RDWR);[17;5Hif (fd_uio < 1) {                                  [18;9Hfprintf(stderr, "Failed to Open UIO Device\n");[19;5H    return -1;[20;5H}[21;5H                                    [22;5Hs = socket(AF_INET, SOCK_STREAM, 0);[23;5H            [24;5Hif (s < 0) {         [25;9Hperror("socket");[1;1H[26;1H[K- xvcserver.c 199/304 65%[1;1H[1;5Hstruct sockaddr_in address;[2;5H           [3;5Hopterr = 0;[4;5H                                                        [5;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[6;19Hv': verbose = 1; break;                                  [7;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[8;9H}[9;5H                                                             [10;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [11;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[12;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [13;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[14;8HAnd xvcServer.c in the git repo             [15;8Hhttps://github.com/Xilinx/XilinxVirtualCable[16;5H// also uses uio0. (K. Okazaki)    [17;5Hfd_uio = open("/dev/uio0", O_RDWR);[18;5Hif (fd_uio < 1) {                                  [19;9Hfprintf(stderr, "Failed to Open UIO Device\n");[20;5H    return -1;[21;5H}[22;5H                                    [23;5Hs = socket(AF_INET, SOCK_STREAM, 0);[24;5H            [25;5Hif (s < 0) {         [1;1H[26;1H[K- xvcserver.c 198/304 65%[1;1H[1;5H                           [2;5Hstruct sockaddr_in address;[3;5H           [4;5Hopterr = 0;[5;5H                                                        [6;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[7;19Hv': verbose = 1; break;                                  [8;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[9;9H}[10;5H                                                             [11;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [12;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[13;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [14;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[15;8HAnd xvcServer.c in the git repo             [16;8Hhttps://github.com/Xilinx/XilinxVirtualCable[17;5H// also uses uio0. (K. Okazaki)    [18;5Hfd_uio = open("/dev/uio0", O_RDWR);[19;5Hif (fd_uio < 1) {                                  [20;9Hfprintf(stderr, "Failed to Open UIO Device\n");[21;5H    return -1;[22;5H}[23;5H                                    [24;5Hs = socket(AF_INET, SOCK_STREAM, 0);[25;5H            [1;1H[26;1H[K- xvcserver.c 197/304 64%[1;1H[1;5Hint fd_uio;[2;5H                           [3;5Hstruct sockaddr_in address;[4;5H           [5;5Hopterr = 0;[6;5H                                                        [7;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[8;19Hv': verbose = 1; break;                                  [9;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[10;9H}[11;5H                                                             [12;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [13;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[14;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [15;8Hactually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[16;8HAnd xvcServer.c in the git repo             [17;8Hhttps://github.com/Xilinx/XilinxVirtualCable[18;5H// also uses uio0. (K. Okazaki)    [19;5Hfd_uio = open("/dev/uio0", O_RDWR);[20;5Hif (fd_uio < 1) {                                  [21;9Hfprintf(stderr, "Failed to Open UIO Device\n");[22;5H    return -1;[23;5H}[24;5H                                    [25;5Hs = socket(AF_INET, SOCK_STREAM, 0);[1;1H[26;1H[K- xvcserver.c 196/304 64%[1;1H[26;1H[K- xvcserver.c 195/304 64%[1;1H[26;1H[K- xvcserver.c 194/304 63%[1;1H[26;1H[K- xvcserver.c 193/304 63%[1;1H[26;1H[K- xvcserver.c 192/304 63%[1;1H[26;1H[K- xvcserver.c 191/304 62%[1;1H[26;1H[K- xvcserver.c 190/304 62%[1;1H[26;1H[K- xvcserver.c 189/304 62%[1;1H[26;1H[K- xvcserver.c 188/304 61%[1;1H[26;1H[K- xvcserver.c 187/304 61%[1;1H[1;5H           [2;5H} while (1);[3;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[4;5Hreturn 0;[5;1H}              [7;1Hint main(int argc, char **argv) {                           [8;5Hint i;                               [9;5Hint s;                                                                 [10;5Hint c;[11;5Hint fd_uio;[12;5H                                                             [13;5Hstruct sockaddr_in address;                                              [14;5H                                                                       [15;5Hopterr = 0;                                                              [16;5H                                  [17;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[18;5H        case 'v': verbose = 1; break;[19;5H        case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[20;5H    }            [21;9H                                               [22;5H// https://support.xilinx.com/s/article/974879?language=en_US[23;5H// The tutorial above says: "The original code for Zynq-7000 devices uses[24;5H// uio0, but for MPSoC devices, uio1 must be used." But debug_bridge is[25;5H// actually allocated as uio0 in CentOS 7 at Mercury XU5 on Endcap SL V1.[1;1H[26;1H[K- xvcserver.c 186/304 61%[1;1H[1;9H}[2;5H            [3;5H} while (1);                                                             [4;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[5;1H    return 0;[6;1H}[7;1H                                 [8;1Hint main(int argc, char **argv) {[9;9Hi[10;9Hs[11;9Hc;     [12;5Hint fd_uio;[13;5H                           [14;5Hstruct sockaddr_in address;[15;5H           [16;5Hopterr = 0;[17;5H                                                        [18;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[19;19Hv': verbose = 1; break;                                  [20;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[21;9H}[22;5H                                                             [23;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [24;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[25;8Huio0, but for MPSoC devices, uio1 must be used." But debug_bridge is  [1;1H[26;1H[K- xvcserver.c 185/304 60%[1;1H[1;9H    return 1;[2;9H}[3;5H            [4;5H} while (1);                                                             [5;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[6;1H    return 0;[7;1H}[8;1H                                 [9;1Hint main(int argc, char **argv) {[10;9Hi[11;9Hs[12;9Hc;     [13;5Hint fd_uio;[14;5H                           [15;5Hstruct sockaddr_in address;[16;5H           [17;5Hopterr = 0;[18;5H                                                        [19;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[20;19Hv': verbose = 1; break;                                  [21;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[22;9H}[23;5H                                                             [24;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [25;8HThe tutorial above says: "The original code for Zynq-7000 devices uses[1;1H[26;1H[K- xvcserver.c 184/304 60%[1;1H[1;13Hperror("write");[2;9H    return 1;[3;9H}[4;5H            [5;5H} while (1);                                                             [6;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[7;1H    return 0;[8;1H}[9;1H                                 [10;1Hint main(int argc, char **argv) {[11;9Hi[12;9Hs[13;9Hc;     [14;5Hint fd_uio;[15;5H                           [16;5Hstruct sockaddr_in address;[17;5H           [18;5Hopterr = 0;[19;5H                                                        [20;5Hwhile ((c = getopt(argc, argv, "v")) != -1) switch (c) {[21;19Hv': verbose = 1; break;                                  [22;9H    case '?': fprintf(stderr, "usage: %s [-v]\n", *argv); return 1;[23;9H}[24;5H                                                             [25;8Hhttps://support.xilinx.com/s/article/974879?language=en_US            [1;1H[26;1H[K- xvcserver.c 183/304 60%[1;1H[26;1H[K- xvcserver.c 182/304 59%[1;1H[26;1H[K- xvcserver.c 181/304 59%[1;1H[26;1H[K- xvcserver.c 180/304 59%[1;1H[26;1H[K- xvcserver.c 179/304 58%[1;1H[26;1H[K- xvcserver.c 178/304 58%[1;1H[26;1H[K- xvcserver.c 177/304 58%[1;1H[26;1H[K- xvcserver.c 176/304 57%[1;1H[26;1H[K- xvcserver.c 175/304 57%[1;1H[26;1H[K- xvcserver.c 174/304 57%[1;1H[1;13H    if (verbose) {[2;13H        printf("LEN : 0x%08x\n", bitsLeft);[3;9H            printf("TMS : 0x%08x\n", tms);[4;21Hprintf("TDI : 0x%08x\n", tdi);[5;5H                printf("TDO : 0x%08x\n", tdo);[6;5H            }                                                            [7;5H            break;[8;1H            }[9;9H}[10;1H        if (write(fd, result, nr_bytes) != nr_bytes) {[11;5H        perror("write");[12;5H        return 1;[13;5H    } [14;5H           [15;5H} while (1);[16;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[17;5Hreturn 0;[18;1H}              [20;1Hint main(int argc, char **argv) {                           [21;5Hint i;                               [22;5Hint s;                                                                 [23;5Hint c;[24;5Hint fd_uio;[25;5H                                                             [1;1H[26;1H[K- xvcserver.c 173/304 56%[1;1H[1;17H              [2;17Hif (verbose) {                         [3;29HLEN : 0x%08x\n", bitsLeft);[4;30HMS : 0x%08x\n", tms[5;31HI : 0x%08x\n", tdi[6;17H    printf("TDO : 0x%08x\n", tdo);[7;17H}     [8;13H    break;[9;9H    }[10;9H}                                             [11;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[12;13Hperror("write");[13;9H    return 1;[14;9H}[15;5H            [16;5H} while (1);                                                             [17;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[18;1H    return 0;[19;1H}[20;1H                                 [21;1Hint main(int argc, char **argv) {[22;9Hi[23;9Hs[24;9Hc;     [25;5Hint fd_uio;[1;1H[26;1H[K- xvcserver.c 172/304 56%[1;1H[1;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[2;17H              [3;17Hif (verbose) {                         [4;29HLEN : 0x%08x\n", bitsLeft);[5;30HMS : 0x%08x\n", tms[6;31HI : 0x%08x\n", tdi[7;17H    printf("TDO : 0x%08x\n", tdo);[8;17H}     [9;13H    break;[10;9H    }[11;9H}                                             [12;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[13;13Hperror("write");[14;9H    return 1;[15;9H}[16;5H            [17;5H} while (1);                                                             [18;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[19;1H    return 0;[20;1H}[21;1H                                 [22;1Hint main(int argc, char **argv) {[23;9Hi[24;9Hs[25;9Hc;     [1;1H[26;1H[K- xvcserver.c 171/304 56%[1;1H[1;17H                                            [2;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[3;17H              [4;17Hif (verbose) {                         [5;29HLEN : 0x%08x\n", bitsLeft);[6;30HMS : 0x%08x\n", tms[7;31HI : 0x%08x\n", tdi[8;17H    printf("TDO : 0x%08x\n", tdo);[9;17H}     [10;13H    break;[11;9H    }[12;9H}                                             [13;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[14;13Hperror("write");[15;9H    return 1;[16;9H}[17;5H            [18;5H} while (1);                                                             [19;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[20;1H    return 0;[21;1H}[22;1H                                 [23;1Hint main(int argc, char **argv) {[24;9Hi[25;9Hs[1;1H[26;1H[K- xvcserver.c 170/304 55%[1;1H[1;17Htdo = ptr->tdo_offset;[2;17H                                            [3;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[4;17H              [5;17Hif (verbose) {                         [6;29HLEN : 0x%08x\n", bitsLeft);[7;30HMS : 0x%08x\n", tms[8;31HI : 0x%08x\n", tdi[9;17H    printf("TDO : 0x%08x\n", tdo);[10;17H}     [11;13H    break;[12;9H    }[13;9H}                                             [14;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[15;13Hperror("write");[16;9H    return 1;[17;9H}[18;5H            [19;5H} while (1);                                                             [20;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[21;1H    return 0;[22;1H}[23;1H                                 [24;1Hint main(int argc, char **argv) {[25;9Hi[1;1H[26;1H[K- xvcserver.c 169/304 55%[1;1H[1;17H                      [2;17Htdo = ptr->tdo_offset;[3;17H                                            [4;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[5;17H              [6;17Hif (verbose) {                         [7;29HLEN : 0x%08x\n", bitsLeft);[8;30HMS : 0x%08x\n", tms[9;31HI : 0x%08x\n", tdi[10;17H    printf("TDO : 0x%08x\n", tdo);[11;17H}     [12;13H    break;[13;9H    }[14;9H}                                             [15;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[16;13Hperror("write");[17;9H    return 1;[18;9H}[19;5H            [20;5H} while (1);                                                             [21;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[22;1H    return 0;[23;1H}[24;1H                                 [25;1Hint main(int argc, char **argv) {[1;1H[26;1H[K- xvcserver.c 168/304 55%[1;1H[1;17Hwhile (ptr->ctrl_offset) {}[2;17H                      [3;17Htdo = ptr->tdo_offset;[4;17H                                            [5;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[6;17H              [7;17Hif (verbose) {                         [8;29HLEN : 0x%08x\n", bitsLeft);[9;30HMS : 0x%08x\n", tms[10;31HI : 0x%08x\n", tdi[11;17H    printf("TDO : 0x%08x\n", tdo);[12;17H}     [13;13H    break;[14;9H    }[15;9H}                                             [16;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[17;13Hperror("write");[18;9H    return 1;[19;9H}[20;5H            [21;5H} while (1);                                                             [22;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[23;1H    return 0;[24;1H}[25;1H                                 [1;1H[26;1H[K- xvcserver.c 167/304 54%[1;1H[1;17H/* Switch this to interrupt in next revision */[2;17Hwhile (ptr->ctrl_offset) {}[3;17H                      [4;17Htdo = ptr->tdo_offset;[5;17H                                            [6;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[7;17H              [8;17Hif (verbose) {                         [9;29HLEN : 0x%08x\n", bitsLeft);[10;30HMS : 0x%08x\n", tms[11;31HI : 0x%08x\n", tdi[12;17H    printf("TDO : 0x%08x\n", tdo);[13;17H}     [14;13H    break;[15;9H    }[16;9H}                                             [17;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[18;13Hperror("write");[19;9H    return 1;[20;9H}[21;5H            [22;5H} while (1);                                                             [23;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[24;1H    return 0;[25;1H}[1;1H[26;1H[K- xvcserver.c 166/304 54%[1;1H[1;17Hptr->ctrl_offset = 0x01;                       [2;17H/* Switch this to interrupt in next revision */[3;17Hwhile (ptr->ctrl_offset) {}[4;17H                      [5;17Htdo = ptr->tdo_offset;[6;17H                                            [7;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[8;17H              [9;17Hif (verbose) {                         [10;29HLEN : 0x%08x\n", bitsLeft);[11;30HMS : 0x%08x\n", tms[12;31HI : 0x%08x\n", tdi[13;17H    printf("TDO : 0x%08x\n", tdo);[14;17H}     [15;13H    break;[16;9H    }[17;9H}                                             [18;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[19;13Hperror("write");[20;9H    return 1;[21;9H}[22;5H            [23;5H} while (1);                                                             [24;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[25;1H    return 0;[1;1H[26;1H[K- xvcserver.c 165/304 54%[1;1H[1;17Hdsb(st);                [2;17Hptr->ctrl_offset = 0x01;                       [3;17H/* Switch this to interrupt in next revision */[4;17Hwhile (ptr->ctrl_offset) {}[5;17H                      [6;17Htdo = ptr->tdo_offset;[7;17H                                            [8;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[9;17H              [10;17Hif (verbose) {                         [11;29HLEN : 0x%08x\n", bitsLeft);[12;30HMS : 0x%08x\n", tms[13;31HI : 0x%08x\n", tdi[14;17H    printf("TDO : 0x%08x\n", tdo);[15;17H}     [16;13H    break;[17;9H    }[18;9H}                                             [19;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[20;13Hperror("write");[21;9H    return 1;[22;9H}[23;5H            [24;5H} while (1);                                                             [25;5H/* Note: Need to fix JTAG state updates, until then no exit is allowed */[1;1H[26;1H[K- xvcserver.c 164/304 53%[1;1H[1;17Hptr->tdi_offset = tdi;[2;17Hdsb(st);                [3;17Hptr->ctrl_offset = 0x01;                       [4;17H/* Switch this to interrupt in next revision */[5;17Hwhile (ptr->ctrl_offset) {}[6;17H                      [7;17Htdo = ptr->tdo_offset;[8;17H                                            [9;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[10;17H              [11;17Hif (verbose) {                         [12;29HLEN : 0x%08x\n", bitsLeft);[13;30HMS : 0x%08x\n", tms[14;31HI : 0x%08x\n", tdi[15;17H    printf("TDO : 0x%08x\n", tdo);[16;17H}     [17;13H    break;[18;9H    }[19;9H}                                             [20;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[21;13Hperror("write");[22;9H    return 1;[23;9H}[24;5H            [25;5H} while (1);                                                             [1;1H[26;1H[K- xvcserver.c 163/304 53%[1;1H[1;17Hdsb(st);              [2;17Hptr->tdi_offset = tdi;[3;17Hdsb(st);                [4;17Hptr->ctrl_offset = 0x01;                       [5;17H/* Switch this to interrupt in next revision */[6;17Hwhile (ptr->ctrl_offset) {}[7;17H                      [8;17Htdo = ptr->tdo_offset;[9;17H                                            [10;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[11;17H              [12;17Hif (verbose) {                         [13;29HLEN : 0x%08x\n", bitsLeft);[14;30HMS : 0x%08x\n", tms[15;31HI : 0x%08x\n", tdi[16;17H    printf("TDO : 0x%08x\n", tdo);[17;17H}     [18;13H    break;[19;9H    }[20;9H}                                             [21;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[22;13Hperror("write");[23;9H    return 1;[24;9H}[25;5H            [1;1H[26;1H[K- xvcserver.c 162/304 53%[1;1H[1;17Hptr->tms_offset = tms;[2;17Hdsb(st);              [3;17Hptr->tdi_offset = tdi;[4;17Hdsb(st);                [5;17Hptr->ctrl_offset = 0x01;                       [6;17H/* Switch this to interrupt in next revision */[7;17Hwhile (ptr->ctrl_offset) {}[8;17H                      [9;17Htdo = ptr->tdo_offset;[10;17H                                            [11;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[12;17H              [13;17Hif (verbose) {                         [14;29HLEN : 0x%08x\n", bitsLeft);[15;30HMS : 0x%08x\n", tms[16;31HI : 0x%08x\n", tdi[17;17H    printf("TDO : 0x%08x\n", tdo);[18;17H}     [19;13H    break;[20;9H    }[21;9H}                                             [22;9Hif (write(fd, result, nr_bytes) != nr_bytes) {[23;13Hperror("write");[24;9H    return 1;[25;9H}[1;1H[26;1H[K- xvcserver.c 161/304 52%[1;1H[26;1H[K- xvcserver.c 160/304 52%[1;1H[26;1H[K- xvcserver.c 159/304 52%[1;1H[26;1H[K- xvcserver.c 158/304 51%[1;1H[26;1H[K- xvcserver.c 157/304 51%[1;1H[26;1H[K- xvcserver.c 156/304 51%[1;1H[26;1H[K- xvcserver.c 155/304 50%[1;1H[26;1H[K- xvcserver.c 154/304 50%[1;1H[26;1H[K- xvcserver.c 153/304 50%[1;1H[26;1H[K- xvcserver.c 152/304 50%[1;1H[1;17H    printf("TDI : 0x%08x\n", tdi);[2;17H    printf("TDO : 0x%08x\n", tdo);[3;17H}                     [4;17H        [5;13H} else {                    [6;17Hmemcpy(&tms, &buffer[byteIndex], bytesLeft);   [7;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[9;17Hptr->length_offset = bitsLeft;[10;17Hdsb(st);[11;17Hptr->tms_offset = tms;                      [12;17Hdsb(st);[13;17Hptr->tdi_offset = tdi;[14;17Hdsb(st);                               [15;17Hptr->ctrl_offset = 0x01;          [16;17H/* Switch this to interrupt in next revision */[17;17Hwhile (ptr->ctrl_offset) {}       [18;17H [19;17Htdo = ptr->tdo_offset;[20;13H [21;9H        memcpy(&result[byteIndex], &tdo, bytesLeft);[22;9H                                              [23;13H    if (verbose) {[24;13H        printf("LEN : 0x%08x\n", bitsLeft);[25;9H            printf("TMS : 0x%08x\n", tms);[1;1H[26;1H[K- xvcserver.c 151/304 49%[1;1H[1;30HMS : 0x%08x\n", tms[2;31HI : 0x%08x\n", tdi[3;17H    printf("TDO : 0x%08x\n", tdo);[4;17H}[5;13H        [6;13H} else {                                        [7;26Hms, &buffer[byteIndex], bytesLeft);           [8;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[9;17H                              [10;17Hptr->length_offset = bitsLeft;[11;17Hdsb(st);              [12;17Hptr->tms_offset = tms;[13;17Hdsb(st);              [14;17Hptr->tdi_offset = tdi;[15;17Hdsb(st);                [16;17Hptr->ctrl_offset = 0x01;                       [17;17H/* Switch this to interrupt in next revision */[18;17Hwhile (ptr->ctrl_offset) {}[19;17H                      [20;17Htdo = ptr->tdo_offset;[21;17H                                            [22;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[23;17H              [24;17Hif (verbose) {                         [25;29HLEN : 0x%08x\n", bitsLeft);[1;1H[26;1H[K- xvcserver.c 150/304 49%[1;1H[1;29HLEN : 0x%08x\n", 32); [2;30HMS : 0x%08x\n", tms[3;31HI : 0x%08x\n", tdi[4;17H    printf("TDO : 0x%08x\n", tdo);[5;17H}[6;13H        [7;13H} else {                                        [8;26Hms, &buffer[byteIndex], bytesLeft);           [9;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[10;17H                              [11;17Hptr->length_offset = bitsLeft;[12;17Hdsb(st);              [13;17Hptr->tms_offset = tms;[14;17Hdsb(st);              [15;17Hptr->tdi_offset = tdi;[16;17Hdsb(st);                [17;17Hptr->ctrl_offset = 0x01;                       [18;17H/* Switch this to interrupt in next revision */[19;17Hwhile (ptr->ctrl_offset) {}[20;17H                      [21;17Htdo = ptr->tdo_offset;[22;17H                                            [23;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[24;17H              [25;17Hif (verbose) {                         [1;1H[26;1H[K- xvcserver.c 149/304 49%[1;1H[1;17Hif (verbose) {                   [2;29HLEN : 0x%08x\n", 32); [3;30HMS : 0x%08x\n", tms[4;31HI : 0x%08x\n", tdi[5;17H    printf("TDO : 0x%08x\n", tdo);[6;17H}[7;13H        [8;13H} else {                                        [9;26Hms, &buffer[byteIndex], bytesLeft);           [10;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[11;17H                              [12;17Hptr->length_offset = bitsLeft;[13;17Hdsb(st);              [14;17Hptr->tms_offset = tms;[15;17Hdsb(st);              [16;17Hptr->tdi_offset = tdi;[17;17Hdsb(st);                [18;17Hptr->ctrl_offset = 0x01;                       [19;17H/* Switch this to interrupt in next revision */[20;17Hwhile (ptr->ctrl_offset) {}[21;17H                      [22;17Htdo = ptr->tdo_offset;[23;17H                                            [24;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[25;17H              [1;1H[26;1H[K- xvcserver.c 148/304 48%[1;1H[1;17H              [2;17Hif (verbose) {                   [3;29HLEN : 0x%08x\n", 32); [4;30HMS : 0x%08x\n", tms[5;31HI : 0x%08x\n", tdi[6;17H    printf("TDO : 0x%08x\n", tdo);[7;17H}[8;13H        [9;13H} else {                                        [10;26Hms, &buffer[byteIndex], bytesLeft);           [11;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[12;17H                              [13;17Hptr->length_offset = bitsLeft;[14;17Hdsb(st);              [15;17Hptr->tms_offset = tms;[16;17Hdsb(st);              [17;17Hptr->tdi_offset = tdi;[18;17Hdsb(st);                [19;17Hptr->ctrl_offset = 0x01;                       [20;17H/* Switch this to interrupt in next revision */[21;17Hwhile (ptr->ctrl_offset) {}[22;17H                      [23;17Htdo = ptr->tdo_offset;[24;17H                                            [25;17Hmemcpy(&result[byteIndex], &tdo, bytesLeft);[1;1H[26;1H[K- xvcserver.c 147/304 48%[1;1H[26;1H[K- xvcserver.c 146/304 48%[1;1H[26;1H[K- xvcserver.c 145/304 47%[1;1H[26;1H[K- xvcserver.c 144/304 47%[1;1H[26;1H[K- xvcserver.c 143/304 47%[1;1H[26;1H[K- xvcserver.c 142/304 46%[1;1H[26;1H[K- xvcserver.c 141/304 46%[1;1H[26;1H[K- xvcserver.c 140/304 46%[1;1H[26;1H[K- xvcserver.c 139/304 45%[1;1H[26;1H[K- xvcserver.c 138/304 45%[1;1H[2;17H/* Switch this to interrupt in next revision */[3;17Hwhile (ptr->ctrl_offset) {}      [4;21H                              [5;17Htdo = ptr->tdo_offset;            [6;17Hmemcpy(&result[byteIndex], &tdo, 4);[7;17H [8;17HbytesLeft -= 4;[9;13H    bitsLeft -= 32;[10;17HbyteIndex += 4;                             [11;17H                                                       [12;17Hif (verbose) {[13;17H    printf("LEN : 0x%08x\n", 32);[14;17H    printf("TMS : 0x%08x\n", tms);[15;17H    printf("TDI : 0x%08x\n", tdi);[16;17H    printf("TDO : 0x%08x\n", tdo);[17;17H}                     [18;17H        [19;13H} else {                    [20;17Hmemcpy(&tms, &buffer[byteIndex], bytesLeft);   [21;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[23;17Hptr->length_offset = bitsLeft;[24;17Hdsb(st);[25;17Hptr->tms_offset = tms;                      [1;1H[26;1H[K- xvcserver.c 137/304 45%[1;1H[1;17Hptr->ctrl_offset = 0x01;[2;17H                                               [3;17H/* Switch this to interrupt in next revision */[4;17Hwhile (ptr->ctrl_offset) {}[5;17H                      [6;17Htdo = ptr->tdo_offset;              [7;17Hmemcpy(&result[byteIndex], &tdo, 4);[8;17H               [9;18HytesLeft -= 4[10;18HitsLeft -= 32[11;17HbyteIndex += 4;[12;17H              [13;17Hif (verbose) {                   [14;29HLEN : 0x%08x\n", 32); [15;30HMS : 0x%08x\n", tms[16;31HI : 0x%08x\n", tdi[17;17H    printf("TDO : 0x%08x\n", tdo);[18;17H}[19;13H        [20;13H} else {                                        [21;26Hms, &buffer[byteIndex], bytesLeft);           [22;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[23;17H                              [24;17Hptr->length_offset = bitsLeft;[25;17Hdsb(st);              [1;1H[26;1H[K- xvcserver.c 136/304 44%[1;1H[1;17Hdsb(st);                [2;17Hptr->ctrl_offset = 0x01;[3;17H                                               [4;17H/* Switch this to interrupt in next revision */[5;17Hwhile (ptr->ctrl_offset) {}[6;17H                      [7;17Htdo = ptr->tdo_offset;              [8;17Hmemcpy(&result[byteIndex], &tdo, 4);[9;17H               [10;18HytesLeft -= 4[11;18HitsLeft -= 32[12;17HbyteIndex += 4;[13;17H              [14;17Hif (verbose) {                   [15;29HLEN : 0x%08x\n", 32); [16;30HMS : 0x%08x\n", tms[17;31HI : 0x%08x\n", tdi[18;17H    printf("TDO : 0x%08x\n", tdo);[19;17H}[20;13H        [21;13H} else {                                        [22;26Hms, &buffer[byteIndex], bytesLeft);           [23;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[24;17H                              [25;17Hptr->length_offset = bitsLeft;[1;1H[26;1H[K- xvcserver.c 135/304 44%[1;1H[1;17Hptr->tdi_offset = tdi;[2;17Hdsb(st);                [3;17Hptr->ctrl_offset = 0x01;[4;17H                                               [5;17H/* Switch this to interrupt in next revision */[6;17Hwhile (ptr->ctrl_offset) {}[7;17H                      [8;17Htdo = ptr->tdo_offset;              [9;17Hmemcpy(&result[byteIndex], &tdo, 4);[10;17H               [11;18HytesLeft -= 4[12;18HitsLeft -= 32[13;17HbyteIndex += 4;[14;17H              [15;17Hif (verbose) {                   [16;29HLEN : 0x%08x\n", 32); [17;30HMS : 0x%08x\n", tms[18;31HI : 0x%08x\n", tdi[19;17H    printf("TDO : 0x%08x\n", tdo);[20;17H}[21;13H        [22;13H} else {                                        [23;26Hms, &buffer[byteIndex], bytesLeft);           [24;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[25;17H                              [1;1H[26;1H[K- xvcserver.c 134/304 44%[1;1H[1;17Hdsb(st);              [2;17Hptr->tdi_offset = tdi;[3;17Hdsb(st);                [4;17Hptr->ctrl_offset = 0x01;[5;17H                                               [6;17H/* Switch this to interrupt in next revision */[7;17Hwhile (ptr->ctrl_offset) {}[8;17H                      [9;17Htdo = ptr->tdo_offset;              [10;17Hmemcpy(&result[byteIndex], &tdo, 4);[11;17H               [12;18HytesLeft -= 4[13;18HitsLeft -= 32[14;17HbyteIndex += 4;[15;17H              [16;17Hif (verbose) {                   [17;29HLEN : 0x%08x\n", 32); [18;30HMS : 0x%08x\n", tms[19;31HI : 0x%08x\n", tdi[20;17H    printf("TDO : 0x%08x\n", tdo);[21;17H}[22;13H        [23;13H} else {                                        [24;26Hms, &buffer[byteIndex], bytesLeft);           [25;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], bytesLeft);[1;1H[26;1H[K- xvcserver.c 133/304 43%[1;1H[1;17Hptr->tms_offset = tms;[2;17Hdsb(st);              [3;17Hptr->tdi_offset = tdi;[4;17Hdsb(st);                [5;17Hptr->ctrl_offset = 0x01;[6;17H                                               [7;17H/* Switch this to interrupt in next revision */[8;17Hwhile (ptr->ctrl_offset) {}[9;17H                      [10;17Htdo = ptr->tdo_offset;              [11;17Hmemcpy(&result[byteIndex], &tdo, 4);[12;17H               [13;18HytesLeft -= 4[14;18HitsLeft -= 32[15;17HbyteIndex += 4;[16;17H              [17;17Hif (verbose) {                   [18;29HLEN : 0x%08x\n", 32); [19;30HMS : 0x%08x\n", tms[20;31HI : 0x%08x\n", tdi[21;17H    printf("TDO : 0x%08x\n", tdo);[22;17H}[23;13H        [24;13H} else {                                        [25;26Hms, &buffer[byteIndex], bytesLeft);           [1;1H[26;1H[K- xvcserver.c 132/304 43%[1;1H[1;17Hdsb(st);              [2;17Hptr->tms_offset = tms;[3;17Hdsb(st);              [4;17Hptr->tdi_offset = tdi;[5;17Hdsb(st);                [6;17Hptr->ctrl_offset = 0x01;[7;17H                                               [8;17H/* Switch this to interrupt in next revision */[9;17Hwhile (ptr->ctrl_offset) {}[10;17H                      [11;17Htdo = ptr->tdo_offset;              [12;17Hmemcpy(&result[byteIndex], &tdo, 4);[13;17H               [14;18HytesLeft -= 4[15;18HitsLeft -= 32[16;17HbyteIndex += 4;[17;17H              [18;17Hif (verbose) {                   [19;29HLEN : 0x%08x\n", 32); [20;30HMS : 0x%08x\n", tms[21;31HI : 0x%08x\n", tdi[22;17H    printf("TDO : 0x%08x\n", tdo);[23;17H}[24;13H        [25;13H} else {                                        [1;1H[26;1H[K- xvcserver.c 131/304 43%[1;1H[1;17Hptr->length_offset = 32;[2;17Hdsb(st);              [3;17Hptr->tms_offset = tms;[4;17Hdsb(st);              [5;17Hptr->tdi_offset = tdi;[6;17Hdsb(st);                [7;17Hptr->ctrl_offset = 0x01;[8;17H                                               [9;17H/* Switch this to interrupt in next revision */[10;17Hwhile (ptr->ctrl_offset) {}[11;17H                      [12;17Htdo = ptr->tdo_offset;              [13;17Hmemcpy(&result[byteIndex], &tdo, 4);[14;17H               [15;18HytesLeft -= 4[16;18HitsLeft -= 32[17;17HbyteIndex += 4;[18;17H              [19;17Hif (verbose) {                   [20;29HLEN : 0x%08x\n", 32); [21;30HMS : 0x%08x\n", tms[22;31HI : 0x%08x\n", tdi[23;17H    printf("TDO : 0x%08x\n", tdo);[24;17H}[25;13H        [1;1H[26;1H[K- xvcserver.c 130/304 42%[1;1H[1;17H                        [2;17Hptr->length_offset = 32;[3;17Hdsb(st);              [4;17Hptr->tms_offset = tms;[5;17Hdsb(st);              [6;17Hptr->tdi_offset = tdi;[7;17Hdsb(st);                [8;17Hptr->ctrl_offset = 0x01;[9;17H                                               [10;17H/* Switch this to interrupt in next revision */[11;17Hwhile (ptr->ctrl_offset) {}[12;17H                      [13;17Htdo = ptr->tdo_offset;              [14;17Hmemcpy(&result[byteIndex], &tdo, 4);[15;17H               [16;18HytesLeft -= 4[17;18HitsLeft -= 32[18;17HbyteIndex += 4;[19;17H              [20;17Hif (verbose) {                   [21;29HLEN : 0x%08x\n", 32); [22;30HMS : 0x%08x\n", tms[23;31HI : 0x%08x\n", tdi[24;17H    printf("TDO : 0x%08x\n", tdo);[25;17H}[1;1H[26;1H[K- xvcserver.c 129/304 42%[1;1H[1;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[2;17H                        [3;17Hptr->length_offset = 32;[4;17Hdsb(st);              [5;17Hptr->tms_offset = tms;[6;17Hdsb(st);              [7;17Hptr->tdi_offset = tdi;[8;17Hdsb(st);                [9;17Hptr->ctrl_offset = 0x01;[10;17H                                               [11;17H/* Switch this to interrupt in next revision */[12;17Hwhile (ptr->ctrl_offset) {}[13;17H                      [14;17Htdo = ptr->tdo_offset;              [15;17Hmemcpy(&result[byteIndex], &tdo, 4);[16;17H               [17;18HytesLeft -= 4[18;18HitsLeft -= 32[19;17HbyteIndex += 4;[20;17H              [21;17Hif (verbose) {                   [22;29HLEN : 0x%08x\n", 32); [23;30HMS : 0x%08x\n", tms[24;31HI : 0x%08x\n", tdi[25;17H    printf("TDO : 0x%08x\n", tdo);[1;1H[26;1H[K- xvcserver.c 128/304 42%[1;1H[1;26Hms, &buffer[byteIndex], 4);           [2;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[3;17H                        [4;17Hptr->length_offset = 32;[5;17Hdsb(st);              [6;17Hptr->tms_offset = tms;[7;17Hdsb(st);              [8;17Hptr->tdi_offset = tdi;[9;17Hdsb(st);                [10;17Hptr->ctrl_offset = 0x01;[11;17H                                               [12;17H/* Switch this to interrupt in next revision */[13;17Hwhile (ptr->ctrl_offset) {}[14;17H                      [15;17Htdo = ptr->tdo_offset;              [16;17Hmemcpy(&result[byteIndex], &tdo, 4);[17;17H               [18;18HytesLeft -= 4[19;18HitsLeft -= 32[20;17HbyteIndex += 4;[21;17H              [22;17Hif (verbose) {                   [23;29HLEN : 0x%08x\n", 32); [24;30HMS : 0x%08x\n", tms[25;31HI : 0x%08x\n", tdi[1;1H[26;1H[K- xvcserver.c 127/304 41%[1;1H[1;13Hif (bytesLeft >= 4) {                   [2;26Hms, &buffer[byteIndex], 4);           [3;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[4;17H                        [5;17Hptr->length_offset = 32;[6;17Hdsb(st);              [7;17Hptr->tms_offset = tms;[8;17Hdsb(st);              [9;17Hptr->tdi_offset = tdi;[10;17Hdsb(st);                [11;17Hptr->ctrl_offset = 0x01;[12;17H                                               [13;17H/* Switch this to interrupt in next revision */[14;17Hwhile (ptr->ctrl_offset) {}[15;17H                      [16;17Htdo = ptr->tdo_offset;              [17;17Hmemcpy(&result[byteIndex], &tdo, 4);[18;17H               [19;18HytesLeft -= 4[20;18HitsLeft -= 32[21;17HbyteIndex += 4;[22;17H              [23;17Hif (verbose) {                   [24;29HLEN : 0x%08x\n", 32); [25;30HMS : 0x%08x\n", tms[1;1H[26;1H[K- xvcserver.c 126/304 41%[1;1H[1;13Htdo = 0;             [2;13Hif (bytesLeft >= 4) {                   [3;26Hms, &buffer[byteIndex], 4);           [4;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[5;17H                        [6;17Hptr->length_offset = 32;[7;17Hdsb(st);              [8;17Hptr->tms_offset = tms;[9;17Hdsb(st);              [10;17Hptr->tdi_offset = tdi;[11;17Hdsb(st);                [12;17Hptr->ctrl_offset = 0x01;[13;17H                                               [14;17H/* Switch this to interrupt in next revision */[15;17Hwhile (ptr->ctrl_offset) {}[16;17H                      [17;17Htdo = ptr->tdo_offset;              [18;17Hmemcpy(&result[byteIndex], &tdo, 4);[19;17H               [20;18HytesLeft -= 4[21;18HitsLeft -= 32[22;17HbyteIndex += 4;[23;17H              [24;17Hif (verbose) {                   [25;29HLEN : 0x%08x\n", 32); [1;1H[26;1H[K- xvcserver.c 125/304 41%[1;1H[1;15Hi[2;13Htdo = 0;             [3;13Hif (bytesLeft >= 4) {                   [4;26Hms, &buffer[byteIndex], 4);           [5;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[6;17H                        [7;17Hptr->length_offset = 32;[8;17Hdsb(st);              [9;17Hptr->tms_offset = tms;[10;17Hdsb(st);              [11;17Hptr->tdi_offset = tdi;[12;17Hdsb(st);                [13;17Hptr->ctrl_offset = 0x01;[14;17H                                               [15;17H/* Switch this to interrupt in next revision */[16;17Hwhile (ptr->ctrl_offset) {}[17;17H                      [18;17Htdo = ptr->tdo_offset;              [19;17Hmemcpy(&result[byteIndex], &tdo, 4);[20;17H               [21;18HytesLeft -= 4[22;18HitsLeft -= 32[23;17HbyteIndex += 4;[24;17H              [25;17Hif (verbose) {                   [1;1H[26;1H[K- xvcserver.c 124/304 40%[1;1H[1;14Hms[2;15Hi[3;13Htdo = 0;             [4;13Hif (bytesLeft >= 4) {                   [5;26Hms, &buffer[byteIndex], 4);           [6;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[7;17H                        [8;17Hptr->length_offset = 32;[9;17Hdsb(st);              [10;17Hptr->tms_offset = tms;[11;17Hdsb(st);              [12;17Hptr->tdi_offset = tdi;[13;17Hdsb(st);                [14;17Hptr->ctrl_offset = 0x01;[15;17H                                               [16;17H/* Switch this to interrupt in next revision */[17;17Hwhile (ptr->ctrl_offset) {}[18;17H                      [19;17Htdo = ptr->tdo_offset;              [20;17Hmemcpy(&result[byteIndex], &tdo, 4);[21;17H               [22;18HytesLeft -= 4[23;18HitsLeft -= 32[24;17HbyteIndex += 4;[25;17H              [1;1H[26;1H[K- xvcserver.c 123/304 40%[1;1H[1;9Hwhile (bytesLeft > 0) {[2;14Hms[3;15Hi[4;13Htdo = 0;             [5;13Hif (bytesLeft >= 4) {                   [6;26Hms, &buffer[byteIndex], 4);           [7;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[8;17H                        [9;17Hptr->length_offset = 32;[10;17Hdsb(st);              [11;17Hptr->tms_offset = tms;[12;17Hdsb(st);              [13;17Hptr->tdi_offset = tdi;[14;17Hdsb(st);                [15;17Hptr->ctrl_offset = 0x01;[16;17H                                               [17;17H/* Switch this to interrupt in next revision */[18;17Hwhile (ptr->ctrl_offset) {}[19;17H                      [20;17Htdo = ptr->tdo_offset;              [21;17Hmemcpy(&result[byteIndex], &tdo, 4);[22;17H               [23;18HytesLeft -= 4[24;18HitsLeft -= 32[25;17HbyteIndex += 4;[1;1H[26;1H[K- xvcserver.c 122/304 40%[1;1H[26;1H[K- xvcserver.c 121/304 39%[1;1H[26;1H[K- xvcserver.c 120/304 39%[1;1H[26;1H[K- xvcserver.c 119/304 39%[1;1H[26;1H[K- xvcserver.c 118/304 38%[1;1H[26;1H[K- xvcserver.c 117/304 38%[1;1H[26;1H[K- xvcserver.c 116/304 38%[1;1H[26;1H[K- xvcserver.c 115/304 37%[1;1H[1;9H    printf("\n");      [2;9H}           [3;13H        [4;9Hint bytesLeft = nr_bytes;[5;9Hint bitsLeft  = len;     [6;9Hint byteIndex = 0;                          [7;9Hint tdi, tms, tdo;                                     [9;9Hwhile (bytesLeft > 0) {         [10;13Htms = 0;    [11;13Htdi = 0;                  [12;13Htdo = 0;    [13;13Hif (bytesLeft >= 4) {     [14;17Hmemcpy(&tms, &buffer[byteIndex], 4);[15;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[17;17Hptr->length_offset = 32;                       [18;17Hdsb(st);                   [19;17Hptr->tms_offset = tms;[20;17Hdsb(st);              [21;17Hptr->tdi_offset = tdi;              [22;17Hdsb(st);[23;17Hptr->ctrl_offset = 0x01;[24;17H               [25;17H/* Switch this to interrupt in next revision */[1;1H[26;1H[K- xvcserver.c 114/304 37%[1;1H[1;22HtNumber of Bytes : %d \n", nr_bytes);[2;9H    printf("\n");[3;9H}[4;9H                         [5;14HytesLeft = nr_bytes;[6;14HitsLeft  = len;[7;13HbyteIndex = 0[8;9Hint tdi, tms, tdo;[9;9H                       [10;9Hwhile (bytesLeft > 0) {[11;14Hms[12;15Hi[13;13Htdo = 0;             [14;13Hif (bytesLeft >= 4) {                   [15;26Hms, &buffer[byteIndex], 4);           [16;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[17;17H                        [18;17Hptr->length_offset = 32;[19;17Hdsb(st);              [20;17Hptr->tms_offset = tms;[21;17Hdsb(st);              [22;17Hptr->tdi_offset = tdi;[23;17Hdsb(st);                [24;17Hptr->ctrl_offset = 0x01;[25;17H                                               [1;1H[26;1H[K- xvcserver.c 113/304 37%[1;1H[1;34Hits  : %d\n", len);      [2;22HtNumber of Bytes : %d \n", nr_bytes);[3;9H    printf("\n");[4;9H}[5;9H                         [6;14HytesLeft = nr_bytes;[7;14HitsLeft  = len;[8;13HbyteIndex = 0[9;9Hint tdi, tms, tdo;[10;9H                       [11;9Hwhile (bytesLeft > 0) {[12;14Hms[13;15Hi[14;13Htdo = 0;             [15;13Hif (bytesLeft >= 4) {                   [16;26Hms, &buffer[byteIndex], 4);           [17;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[18;17H                        [19;17Hptr->length_offset = 32;[20;17Hdsb(st);              [21;17Hptr->tms_offset = tms;[22;17Hdsb(st);              [23;17Hptr->tdi_offset = tdi;[24;17Hdsb(st);                [25;17Hptr->ctrl_offset = 0x01;[1;1H[26;1H[K- xvcserver.c 112/304 36%[1;1H[1;9Hif (verbose) {                              [2;34Hits  : %d\n", len);      [3;22HtNumber of Bytes : %d \n", nr_bytes);[4;9H    printf("\n");[5;9H}[6;9H                         [7;14HytesLeft = nr_bytes;[8;14HitsLeft  = len;[9;13HbyteIndex = 0[10;9Hint tdi, tms, tdo;[11;9H                       [12;9Hwhile (bytesLeft > 0) {[13;14Hms[14;15Hi[15;13Htdo = 0;             [16;13Hif (bytesLeft >= 4) {                   [17;26Hms, &buffer[byteIndex], 4);           [18;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[19;17H                        [20;17Hptr->length_offset = 32;[21;17Hdsb(st);              [22;17Hptr->tms_offset = tms;[23;17Hdsb(st);              [24;17Hptr->tdi_offset = tdi;[25;17Hdsb(st);                [1;1H[26;1H[K- xvcserver.c 111/304 36%[1;1H[1;9H              [2;9Hif (verbose) {                              [3;34Hits  : %d\n", len);      [4;22HtNumber of Bytes : %d \n", nr_bytes);[5;9H    printf("\n");[6;9H}[7;9H                         [8;14HytesLeft = nr_bytes;[9;14HitsLeft  = len;[10;13HbyteIndex = 0[11;9Hint tdi, tms, tdo;[12;9H                       [13;9Hwhile (bytesLeft > 0) {[14;14Hms[15;15Hi[16;13Htdo = 0;             [17;13Hif (bytesLeft >= 4) {                   [18;26Hms, &buffer[byteIndex], 4);           [19;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[20;17H                        [21;17Hptr->length_offset = 32;[22;17Hdsb(st);              [23;17Hptr->tms_offset = tms;[24;17Hdsb(st);              [25;17Hptr->tdi_offset = tdi;[1;1H[26;1H[K- xvcserver.c 110/304 36%[1;1H[1;9Hmemset(result, 0, nr_bytes);[2;9H              [3;9Hif (verbose) {                              [4;34Hits  : %d\n", len);      [5;22HtNumber of Bytes : %d \n", nr_bytes);[6;9H    printf("\n");[7;9H}[8;9H                         [9;14HytesLeft = nr_bytes;[10;14HitsLeft  = len;[11;13HbyteIndex = 0[12;9Hint tdi, tms, tdo;[13;9H                       [14;9Hwhile (bytesLeft > 0) {[15;14Hms[16;15Hi[17;13Htdo = 0;             [18;13Hif (bytesLeft >= 4) {                   [19;26Hms, &buffer[byteIndex], 4);           [20;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[21;17H                        [22;17Hptr->length_offset = 32;[23;17Hdsb(st);              [24;17Hptr->tms_offset = tms;[25;17Hdsb(st);              [1;1H[26;1H[K- xvcserver.c 109/304 35%[1;1H[1;9H}                           [2;9Hmemset(result, 0, nr_bytes);[3;9H              [4;9Hif (verbose) {                              [5;34Hits  : %d\n", len);      [6;22HtNumber of Bytes : %d \n", nr_bytes);[7;9H    printf("\n");[8;9H}[9;9H                         [10;14HytesLeft = nr_bytes;[11;14HitsLeft  = len;[12;13HbyteIndex = 0[13;9Hint tdi, tms, tdo;[14;9H                       [15;9Hwhile (bytesLeft > 0) {[16;14Hms[17;15Hi[18;13Htdo = 0;             [19;13Hif (bytesLeft >= 4) {                   [20;26Hms, &buffer[byteIndex], 4);           [21;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[22;17H                        [23;17Hptr->length_offset = 32;[24;17Hdsb(st);              [25;17Hptr->tms_offset = tms;[1;1H[26;1H[K- xvcserver.c 108/304 35%[1;1H[1;9H    return 1;[2;9H}                           [3;9Hmemset(result, 0, nr_bytes);[4;9H              [5;9Hif (verbose) {                              [6;34Hits  : %d\n", len);      [7;22HtNumber of Bytes : %d \n", nr_bytes);[8;9H    printf("\n");[9;9H}[10;9H                         [11;14HytesLeft = nr_bytes;[12;14HitsLeft  = len;[13;13HbyteIndex = 0[14;9Hint tdi, tms, tdo;[15;9H                       [16;9Hwhile (bytesLeft > 0) {[17;14Hms[18;15Hi[19;13Htdo = 0;             [20;13Hif (bytesLeft >= 4) {                   [21;26Hms, &buffer[byteIndex], 4);           [22;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[23;17H                        [24;17Hptr->length_offset = 32;[25;17Hdsb(st);              [1;1H[26;1H[K- xvcserver.c 107/304 35%[1;1H[1;13Hfprintf(stderr, "reading data failed\n");[2;9H    return 1;[3;9H}                           [4;9Hmemset(result, 0, nr_bytes);[5;9H              [6;9Hif (verbose) {                              [7;34Hits  : %d\n", len);      [8;22HtNumber of Bytes : %d \n", nr_bytes);[9;9H    printf("\n");[10;9H}[11;9H                         [12;14HytesLeft = nr_bytes;[13;14HitsLeft  = len;[14;13HbyteIndex = 0[15;9Hint tdi, tms, tdo;[16;9H                       [17;9Hwhile (bytesLeft > 0) {[18;14Hms[19;15Hi[20;13Htdo = 0;             [21;13Hif (bytesLeft >= 4) {                   [22;26Hms, &buffer[byteIndex], 4);           [23;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[24;17H                        [25;17Hptr->length_offset = 32;[1;1H[26;1H[K- xvcserver.c 106/304 34%[1;1H[1;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [2;13Hfprintf(stderr, "reading data failed\n");[3;9H    return 1;[4;9H}                           [5;9Hmemset(result, 0, nr_bytes);[6;9H              [7;9Hif (verbose) {                              [8;34Hits  : %d\n", len);      [9;22HtNumber of Bytes : %d \n", nr_bytes);[10;9H    printf("\n");[11;9H}[12;9H                         [13;14HytesLeft = nr_bytes;[14;14HitsLeft  = len;[15;13HbyteIndex = 0[16;9Hint tdi, tms, tdo;[17;9H                       [18;9Hwhile (bytesLeft > 0) {[19;14Hms[20;15Hi[21;13Htdo = 0;             [22;13Hif (bytesLeft >= 4) {                   [23;26Hms, &buffer[byteIndex], 4);           [24;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[25;17H                        [1;1H[26;1H[K- xvcserver.c 105/304 34%[1;1H[1;9H                                           [2;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [3;13Hfprintf(stderr, "reading data failed\n");[4;9H    return 1;[5;9H}                           [6;9Hmemset(result, 0, nr_bytes);[7;9H              [8;9Hif (verbose) {                              [9;34Hits  : %d\n", len);      [10;22HtNumber of Bytes : %d \n", nr_bytes);[11;9H    printf("\n");[12;9H}[13;9H                         [14;14HytesLeft = nr_bytes;[15;14HitsLeft  = len;[16;13HbyteIndex = 0[17;9Hint tdi, tms, tdo;[18;9H                       [19;9Hwhile (bytesLeft > 0) {[20;14Hms[21;15Hi[22;13Htdo = 0;             [23;13Hif (bytesLeft >= 4) {                   [24;26Hms, &buffer[byteIndex], 4);           [25;17Hmemcpy(&tdi, &buffer[byteIndex + nr_bytes], 4);[1;1H[26;1H[K- xvcserver.c 104/304 34%[1;1H[1;9H}[2;9H                                           [3;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [4;13Hfprintf(stderr, "reading data failed\n");[5;9H    return 1;[6;9H}                           [7;9Hmemset(result, 0, nr_bytes);[8;9H              [9;9Hif (verbose) {                              [10;34Hits  : %d\n", len);      [11;22HtNumber of Bytes : %d \n", nr_bytes);[12;9H    printf("\n");[13;9H}[14;9H                         [15;14HytesLeft = nr_bytes;[16;14HitsLeft  = len;[17;13HbyteIndex = 0[18;9Hint tdi, tms, tdo;[19;9H                       [20;9Hwhile (bytesLeft > 0) {[21;14Hms[22;15Hi[23;13Htdo = 0;             [24;13Hif (bytesLeft >= 4) {                   [25;26Hms, &buffer[byteIndex], 4);           [1;1H[26;1H[K- xvcserver.c 103/304 33%[1;1H[26;1H[K- xvcserver.c 102/304 33%[1;1H[26;1H[K- xvcserver.c 101/304 33%[1;1H[26;1H[K- xvcserver.c 100/304 32%[1;1H[26;1H[K- xvcserver.c 99/304 32%[1;1H[26;1H[K- xvcserver.c 98/304 32%[1;1H[26;1H[K- xvcserver.c 97/304 31%[1;1H[26;1H[K- xvcserver.c 96/304 31%[1;1H[26;1H[K- xvcserver.c 95/304 31%[1;1H[26;1H[K- xvcserver.c 94/304 30%[1;1H[1;9Hint len;[2;9Hif (sread(fd, &len, 4) != 1) {[3;9H    fprintf(stderr, "reading length failed\n");[4;13Hreturn 1;                                [5;9H}            [6;9H [7;9Hint nr_bytes = (len + 7) / 8;[8;9Hif (nr_bytes * 2 > sizeof(buffer)) {[9;9H    fprintf(stderr, "buffer size exceeded\n");[10;13Hreturn 1;                               [11;9H}                                                 [12;13H             [13;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[14;13Hfprintf(stderr, "reading data failed\n");[15;9H    return 1;            [16;9H}                   [17;9Hmemset(result, 0, nr_bytes);[18;9H                  [19;9Hif (verbose) {[20;9H    printf("\tNumber of Bits  : %d\n", len);[21;13Hprintf("\tNumber of Bytes : %d \n", nr_bytes);[22;13Hprintf("\n");[23;9H}           [24;13H                     [25;9Hint bytesLeft = nr_bytes;                   [1;1H[26;1H[K- xvcserver.c 93/304 30%[1;1H[1;9H        [2;10Hnt len;                      [3;9Hif (sread(fd, &len, 4) != 1) {                 [4;13Hfprintf(stderr, "reading length failed\n");[5;9H    return 1;[6;9H}[7;9H                             [8;10Hnt nr_bytes = (len + 7) / 8;       [9;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [10;13Hfprintf(stderr, "buffer size exceeded\n");[11;9H    return 1;[12;9H}[13;9H                                           [14;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [15;13Hfprintf(stderr, "reading data failed\n");[16;9H    return 1;[17;9H}                           [18;9Hmemset(result, 0, nr_bytes);[19;9H              [20;9Hif (verbose) {                              [21;34Hits  : %d\n", len);      [22;22HtNumber of Bytes : %d \n", nr_bytes);[23;9H    printf("\n");[24;9H}[25;9H                         [1;1H[26;1H[K- xvcserver.c 92/304 30%[1;1H[1;9H}[2;9H        [3;10Hnt len;                      [4;9Hif (sread(fd, &len, 4) != 1) {                 [5;13Hfprintf(stderr, "reading length failed\n");[6;9H    return 1;[7;9H}[8;9H                             [9;10Hnt nr_bytes = (len + 7) / 8;       [10;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [11;13Hfprintf(stderr, "buffer size exceeded\n");[12;9H    return 1;[13;9H}[14;9H                                           [15;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [16;13Hfprintf(stderr, "reading data failed\n");[17;9H    return 1;[18;9H}                           [19;9Hmemset(result, 0, nr_bytes);[20;9H              [21;9Hif (verbose) {                              [22;34Hits  : %d\n", len);      [23;22HtNumber of Bytes : %d \n", nr_bytes);[24;9H    printf("\n");[25;9H}[1;1H[26;1H[K- xvcserver.c 91/304 29%[1;1H[1;9H    return 1;[2;9H}[3;9H        [4;10Hnt len;                      [5;9Hif (sread(fd, &len, 4) != 1) {                 [6;13Hfprintf(stderr, "reading length failed\n");[7;9H    return 1;[8;9H}[9;9H                             [10;10Hnt nr_bytes = (len + 7) / 8;       [11;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [12;13Hfprintf(stderr, "buffer size exceeded\n");[13;9H    return 1;[14;9H}[15;9H                                           [16;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [17;13Hfprintf(stderr, "reading data failed\n");[18;9H    return 1;[19;9H}                           [20;9Hmemset(result, 0, nr_bytes);[21;9H              [22;9Hif (verbose) {                              [23;34Hits  : %d\n", len);      [24;22HtNumber of Bytes : %d \n", nr_bytes);[25;9H    printf("\n");[1;1H[26;1H[K- xvcserver.c 90/304 29%[1;1H[1;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[2;9H    return 1;[3;9H}[4;9H        [5;10Hnt len;                      [6;9Hif (sread(fd, &len, 4) != 1) {                 [7;13Hfprintf(stderr, "reading length failed\n");[8;9H    return 1;[9;9H}[10;9H                             [11;10Hnt nr_bytes = (len + 7) / 8;       [12;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [13;13Hfprintf(stderr, "buffer size exceeded\n");[14;9H    return 1;[15;9H}[16;9H                                           [17;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [18;13Hfprintf(stderr, "reading data failed\n");[19;9H    return 1;[20;9H}                           [21;9Hmemset(result, 0, nr_bytes);[22;9H              [23;9Hif (verbose) {                              [24;34Hits  : %d\n", len);      [25;22HtNumber of Bytes : %d \n", nr_bytes);[1;1H[26;1H[K- xvcserver.c 89/304 29%[1;1H[26;1H[K- xvcserver.c 88/304 28%[1;1H[1;13H}                                          [2;9H} else {     [3;9H    fprintf(stderr, "invalid cmd '%s'\n", cmd);[4;13Hreturn 1;[5;9H}       [6;9H                              [7;9Hint len;                                       [8;9Hif (sread(fd, &len, 4) != 1) {[9;9H    fprintf(stderr, "reading length failed\n");[10;13Hreturn 1;[11;9H}                            [12;9H                                    [13;9Hint nr_bytes = (len + 7) / 8;                 [14;9Hif (nr_bytes * 2 > sizeof(buffer)) {[15;9H    fprintf(stderr, "buffer size exceeded\n");[16;13Hreturn 1;[17;9H}                                          [18;13H                                         [19;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {[20;9H    fprintf(stderr, "reading data failed\n");[21;9H    return 1;               [22;9H}[23;9Hmemset(result, 0, nr_bytes);[24;13H                                        [25;9Hif (verbose) {                                    [1;1H[26;1H[K- xvcserver.c 87/304 28%[1;1H[1;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[2;9H    }   [3;9H} else {                                       [4;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[5;9H    return 1;[6;9H}[7;9H        [8;10Hnt len;                      [9;9Hif (sread(fd, &len, 4) != 1) {                 [10;13Hfprintf(stderr, "reading length failed\n");[11;9H    return 1;[12;9H}[13;9H                             [14;10Hnt nr_bytes = (len + 7) / 8;       [15;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [16;13Hfprintf(stderr, "buffer size exceeded\n");[17;9H    return 1;[18;9H}[19;9H                                           [20;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [21;13Hfprintf(stderr, "reading data failed\n");[22;9H    return 1;[23;9H}                           [24;9Hmemset(result, 0, nr_bytes);[25;9H              [1;1H[26;1H[K- xvcserver.c 86/304 28%[1;1H[1;13Hif (verbose) {                                                  [2;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[3;9H    }   [4;9H} else {                                       [5;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[6;9H    return 1;[7;9H}[8;9H        [9;10Hnt len;                      [10;9Hif (sread(fd, &len, 4) != 1) {                 [11;13Hfprintf(stderr, "reading length failed\n");[12;9H    return 1;[13;9H}[14;9H                             [15;10Hnt nr_bytes = (len + 7) / 8;       [16;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [17;13Hfprintf(stderr, "buffer size exceeded\n");[18;9H    return 1;[19;9H}[20;9H                                           [21;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [22;13Hfprintf(stderr, "reading data failed\n");[23;9H    return 1;[24;9H}                           [25;9Hmemset(result, 0, nr_bytes);[1;1H[26;1H[K- xvcserver.c 85/304 27%[1;1H[1;17Hsread(fd, cmd, 4) != 1) return 1;[2;13Hif (verbose) {                                                  [3;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[4;9H    }   [5;9H} else {                                       [6;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[7;9H    return 1;[8;9H}[9;9H        [10;10Hnt len;                      [11;9Hif (sread(fd, &len, 4) != 1) {                 [12;13Hfprintf(stderr, "reading length failed\n");[13;9H    return 1;[14;9H}[15;9H                             [16;10Hnt nr_bytes = (len + 7) / 8;       [17;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [18;13Hfprintf(stderr, "buffer size exceeded\n");[19;9H    return 1;[20;9H}[21;9H                                           [22;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [23;13Hfprintf(stderr, "reading data failed\n");[24;9H    return 1;[25;9H}                           [1;1H[26;1H[K- xvcserver.c 84/304 27%[1;1H[1;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [2;17Hsread(fd, cmd, 4) != 1) return 1;[3;13Hif (verbose) {                                                  [4;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[5;9H    }   [6;9H} else {                                       [7;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[8;9H    return 1;[9;9H}[10;9H        [11;10Hnt len;                      [12;9Hif (sread(fd, &len, 4) != 1) {                 [13;13Hfprintf(stderr, "reading length failed\n");[14;9H    return 1;[15;9H}[16;9H                             [17;10Hnt nr_bytes = (len + 7) / 8;       [18;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [19;13Hfprintf(stderr, "buffer size exceeded\n");[20;9H    return 1;[21;9H}[22;9H                                           [23;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [24;13Hfprintf(stderr, "reading data failed\n");[25;9H    return 1;[1;1H[26;1H[K- xvcserver.c 83/304 27%[1;1H[1;9H    break;                             [2;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [3;17Hsread(fd, cmd, 4) != 1) return 1;[4;13Hif (verbose) {                                                  [5;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[6;9H    }   [7;9H} else {                                       [8;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[9;9H    return 1;[10;9H}[11;9H        [12;10Hnt len;                      [13;9Hif (sread(fd, &len, 4) != 1) {                 [14;13Hfprintf(stderr, "reading length failed\n");[15;9H    return 1;[16;9H}[17;9H                             [18;10Hnt nr_bytes = (len + 7) / 8;       [19;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [20;13Hfprintf(stderr, "buffer size exceeded\n");[21;9H    return 1;[22;9H}[23;9H                                           [24;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [25;13Hfprintf(stderr, "reading data failed\n");[1;1H[26;1H[K- xvcserver.c 82/304 26%[1;1H[1;13H}     [2;9H    break;                             [3;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [4;17Hsread(fd, cmd, 4) != 1) return 1;[5;13Hif (verbose) {                                                  [6;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[7;9H    }   [8;9H} else {                                       [9;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[10;9H    return 1;[11;9H}[12;9H        [13;10Hnt len;                      [14;9Hif (sread(fd, &len, 4) != 1) {                 [15;13Hfprintf(stderr, "reading length failed\n");[16;9H    return 1;[17;9H}[18;9H                             [19;10Hnt nr_bytes = (len + 7) / 8;       [20;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [21;13Hfprintf(stderr, "buffer size exceeded\n");[22;9H    return 1;[23;9H}[24;9H                                           [25;9Hif (sread(fd, buffer, nr_bytes * 2) != 1) {  [1;1H[26;1H[K- xvcserver.c 81/304 26%[1;1H[1;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[2;13H}     [3;9H    break;                             [4;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [5;17Hsread(fd, cmd, 4) != 1) return 1;[6;13Hif (verbose) {                                                  [7;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[8;9H    }   [9;9H} else {                                       [10;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[11;9H    return 1;[12;9H}[13;9H        [14;10Hnt len;                      [15;9Hif (sread(fd, &len, 4) != 1) {                 [16;13Hfprintf(stderr, "reading length failed\n");[17;9H    return 1;[18;9H}[19;9H                             [20;10Hnt nr_bytes = (len + 7) / 8;       [21;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [22;13Hfprintf(stderr, "buffer size exceeded\n");[23;9H    return 1;[24;9H}[25;9H                                           [1;1H[26;1H[K- xvcserver.c 80/304 26%[1;1H[1;25H%u : Received command: 'settck'\n", (int)time(NULL));[2;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[3;13H}     [4;9H    break;                             [5;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [6;17Hsread(fd, cmd, 4) != 1) return 1;[7;13Hif (verbose) {                                                  [8;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[9;9H    }   [10;9H} else {                                       [11;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[12;9H    return 1;[13;9H}[14;9H        [15;10Hnt len;                      [16;9Hif (sread(fd, &len, 4) != 1) {                 [17;13Hfprintf(stderr, "reading length failed\n");[18;9H    return 1;[19;9H}[20;9H                             [21;10Hnt nr_bytes = (len + 7) / 8;       [22;9Hif (nr_bytes * 2 > sizeof(buffer)) {          [23;13Hfprintf(stderr, "buffer size exceeded\n");[24;9H    return 1;[25;9H}[1;1H[26;1H[K- xvcserver.c 79/304 25%[1;1H[26;1H[K- xvcserver.c 78/304 25%[1;1H[26;1H[K- xvcserver.c 77/304 25%[1;1H[1;17Hreturn 1;                                                    [2;13H}                                                    [3;13Hif (verbose) {[4;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[5;9H        printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[6;13H}                                    [7;13Hbreak;        [8;9H} else if (memcmp(cmd, "sh", 2) == 0) {                             [9;13Hif (sread(fd, cmd, 4) != 1) return 1;[10;9H    if (verbose) {[11;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[12;13H}        [13;11Helse {[14;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[15;9H    return 1;[16;9H}                             [17;13H                                           [18;9Hint len;     [19;9Hif (sread(fd, &len, 4) != 1) {[20;13Hfprintf(stderr, "reading length failed\n");[21;9H    return 1;                [22;9H}                                   [23;13H                                          [24;9Hint nr_bytes = (len + 7) / 8;[25;9Hif (nr_bytes * 2 > sizeof(buffer)) {[1;1H[26;1H[K- xvcserver.c 76/304 25%[1;1H[1;17Hperror("write");[2;13H    return 1;[3;13H}             [4;13Hif (verbose) {                                                   [5;25H%u : Received command: 'settck'\n", (int)time(NULL));[6;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[7;13H}     [8;9H    break;                             [9;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [10;17Hsread(fd, cmd, 4) != 1) return 1;[11;13Hif (verbose) {                                                  [12;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[13;9H    }   [14;9H} else {                                       [15;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[16;9H    return 1;[17;9H}[18;9H        [19;10Hnt len;                      [20;9Hif (sread(fd, &len, 4) != 1) {                 [21;13Hfprintf(stderr, "reading length failed\n");[22;9H    return 1;[23;9H}[24;9H                             [25;10Hnt nr_bytes = (len + 7) / 8;       [1;1H[26;1H[K- xvcserver.c 75/304 24%[1;1H[1;13Hif (write(fd, result, 4) != 4) {[2;17Hperror("write");[3;13H    return 1;[4;13H}             [5;13Hif (verbose) {                                                   [6;25H%u : Received command: 'settck'\n", (int)time(NULL));[7;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[8;13H}     [9;9H    break;                             [10;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [11;17Hsread(fd, cmd, 4) != 1) return 1;[12;13Hif (verbose) {                                                  [13;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[14;9H    }   [15;9H} else {                                       [16;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[17;9H    return 1;[18;9H}[19;9H        [20;10Hnt len;                      [21;9Hif (sread(fd, &len, 4) != 1) {                 [22;13Hfprintf(stderr, "reading length failed\n");[23;9H    return 1;[24;9H}[25;9H                             [1;1H[26;1H[K- xvcserver.c 74/304 24%[1;1H[1;13Hmemcpy(result, cmd + 5, 4);     [2;13Hif (write(fd, result, 4) != 4) {[3;17Hperror("write");[4;13H    return 1;[5;13H}             [6;13Hif (verbose) {                                                   [7;25H%u : Received command: 'settck'\n", (int)time(NULL));[8;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[9;13H}     [10;9H    break;                             [11;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [12;17Hsread(fd, cmd, 4) != 1) return 1;[13;13Hif (verbose) {                                                  [14;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[15;9H    }   [16;9H} else {                                       [17;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[18;9H    return 1;[19;9H}[20;9H        [21;10Hnt len;                      [22;9Hif (sread(fd, &len, 4) != 1) {                 [23;13Hfprintf(stderr, "reading length failed\n");[24;9H    return 1;[25;9H}[1;1H[26;1H[K- xvcserver.c 73/304 24%[1;1H[1;13Hif (sread(fd, cmd, 9) != 1) return 1;[2;13Hmemcpy(result, cmd + 5, 4);     [3;13Hif (write(fd, result, 4) != 4) {[4;17Hperror("write");[5;13H    return 1;[6;13H}             [7;13Hif (verbose) {                                                   [8;25H%u : Received command: 'settck'\n", (int)time(NULL));[9;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[10;13H}     [11;9H    break;                             [12;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [13;17Hsread(fd, cmd, 4) != 1) return 1;[14;13Hif (verbose) {                                                  [15;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[16;9H    }   [17;9H} else {                                       [18;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[19;9H    return 1;[20;9H}[21;9H        [22;10Hnt len;                      [23;9Hif (sread(fd, &len, 4) != 1) {                 [24;13Hfprintf(stderr, "reading length failed\n");[25;9H    return 1;[1;1H[26;1H[K- xvcserver.c 72/304 23%[1;1H[1;9H} else if (memcmp(cmd, "se", 2) == 0) {  [2;13Hif (sread(fd, cmd, 9) != 1) return 1;[3;13Hmemcpy(result, cmd + 5, 4);     [4;13Hif (write(fd, result, 4) != 4) {[5;17Hperror("write");[6;13H    return 1;[7;13H}             [8;13Hif (verbose) {                                                   [9;25H%u : Received command: 'settck'\n", (int)time(NULL));[10;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[11;13H}     [12;9H    break;                             [13;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [14;17Hsread(fd, cmd, 4) != 1) return 1;[15;13Hif (verbose) {                                                  [16;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[17;9H    }   [18;9H} else {                                       [19;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[20;9H    return 1;[21;9H}[22;9H        [23;10Hnt len;                      [24;9Hif (sread(fd, &len, 4) != 1) {                 [25;13Hfprintf(stderr, "reading length failed\n");[1;1H[26;1H[K- xvcserver.c 71/304 23%[1;1H[1;9H    break;                             [2;9H} else if (memcmp(cmd, "se", 2) == 0) {  [3;13Hif (sread(fd, cmd, 9) != 1) return 1;[4;13Hmemcpy(result, cmd + 5, 4);     [5;13Hif (write(fd, result, 4) != 4) {[6;17Hperror("write");[7;13H    return 1;[8;13H}             [9;13Hif (verbose) {                                                   [10;25H%u : Received command: 'settck'\n", (int)time(NULL));[11;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[12;13H}     [13;9H    break;                             [14;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [15;17Hsread(fd, cmd, 4) != 1) return 1;[16;13Hif (verbose) {                                                  [17;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[18;9H    }   [19;9H} else {                                       [20;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[21;9H    return 1;[22;9H}[23;9H        [24;10Hnt len;                      [25;9Hif (sread(fd, &len, 4) != 1) {                 [1;1H[26;1H[K- xvcserver.c 70/304 23%[1;1H[1;13H}     [2;9H    break;                             [3;9H} else if (memcmp(cmd, "se", 2) == 0) {  [4;13Hif (sread(fd, cmd, 9) != 1) return 1;[5;13Hmemcpy(result, cmd + 5, 4);     [6;13Hif (write(fd, result, 4) != 4) {[7;17Hperror("write");[8;13H    return 1;[9;13H}             [10;13Hif (verbose) {                                                   [11;25H%u : Received command: 'settck'\n", (int)time(NULL));[12;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[13;13H}     [14;9H    break;                             [15;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [16;17Hsread(fd, cmd, 4) != 1) return 1;[17;13Hif (verbose) {                                                  [18;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[19;9H    }   [20;9H} else {                                       [21;13Hfprintf(stderr, "invalid cmd '%s'\n", cmd);[22;9H    return 1;[23;9H}[24;9H        [25;10Hnt len;                      [1;1H[26;1H[K- xvcserver.c 69/304 22%[1;1H[26;1H[K- xvcserver.c 68/304 22%[1;1H[26;1H[K- xvcserver.c 67/304 22%[1;1H[26;1H[K- xvcserver.c 66/304 21%[1;1H[26;1H[K- xvcserver.c 65/304 21%[1;1H[26;1H[K- xvcserver.c 64/304 21%[1;1H[26;1H[K- xvcserver.c 63/304 20%[1;1H[26;1H[K- xvcserver.c 62/304 20%[1;1H[1;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[2;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[3;9H        perror("write");               [4;13H    return 1;                        [5;13H}                          [6;17Hverbose) {                  [7;18Hrintf("%u : Received command: 'getinfo'\n", (int)time(NULL));[8;17Hprintf("\t Replied with %s\n", xvcInfo);[10;13Hbreak;        [11;9H} else if (memcmp(cmd, "se", 2) == 0) {                              [12;13Hif (sread(fd, cmd, 9) != 1) return 1;                [13;13Hmemcpy(result, cmd + 5, 4);[14;13Hif (write(fd, result, 4) != 4) {[15;9H        perror("write");               [16;13H    return 1;                        [17;13H}             [18;13Hif (verbose) {                                                  [19;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[20;9H        printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[21;13H}                                          [22;13Hbreak;   [23;11Helse if (memcmp(cmd, "sh", 2) == 0) {[24;13Hif (sread(fd, cmd, 4) != 1) return 1;[25;9H    if (verbose) {[1;1H[26;1H[K- xvcserver.c 61/304 20%[1;1H[1;13Hif (sread(fd, cmd, 6) != 1) return 1;    [2;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [3;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[4;17Hperror("write");[5;13H    return 1;[6;13H}             [7;13Hif (verbose) {                                                    [8;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[9;13H    printf("\t Replied with %s\n", xvcInfo);[10;13H}     [11;9H    break;                             [12;9H} else if (memcmp(cmd, "se", 2) == 0) {  [13;13Hif (sread(fd, cmd, 9) != 1) return 1;[14;13Hmemcpy(result, cmd + 5, 4);     [15;13Hif (write(fd, result, 4) != 4) {[16;17Hperror("write");[17;13H    return 1;[18;13H}             [19;13Hif (verbose) {                                                   [20;25H%u : Received command: 'settck'\n", (int)time(NULL));[21;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[22;13H}     [23;9H    break;                             [24;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [25;17Hsread(fd, cmd, 4) != 1) return 1;[1;1H[26;1H[K- xvcserver.c 60/304 19%[1;1H[1;9Hif (memcmp(cmd, "ge", 2) == 0) {         [2;13Hif (sread(fd, cmd, 6) != 1) return 1;    [3;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [4;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[5;17Hperror("write");[6;13H    return 1;[7;13H}             [8;13Hif (verbose) {                                                    [9;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[10;13H    printf("\t Replied with %s\n", xvcInfo);[11;13H}     [12;9H    break;                             [13;9H} else if (memcmp(cmd, "se", 2) == 0) {  [14;13Hif (sread(fd, cmd, 9) != 1) return 1;[15;13Hmemcpy(result, cmd + 5, 4);     [16;13Hif (write(fd, result, 4) != 4) {[17;17Hperror("write");[18;13H    return 1;[19;13H}             [20;13Hif (verbose) {                                                   [21;25H%u : Received command: 'settck'\n", (int)time(NULL));[22;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[23;13H}     [24;9H    break;                             [25;9H} else if (memcmp(cmd, "sh", 2) == 0) {  [1;1H[26;1H[K- xvcserver.c 59/304 19%[1;1H[1;9H                                [2;9Hif (memcmp(cmd, "ge", 2) == 0) {         [3;13Hif (sread(fd, cmd, 6) != 1) return 1;    [4;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [5;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[6;17Hperror("write");[7;13H    return 1;[8;13H}             [9;13Hif (verbose) {                                                    [10;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[11;13H    printf("\t Replied with %s\n", xvcInfo);[12;13H}     [13;9H    break;                             [14;9H} else if (memcmp(cmd, "se", 2) == 0) {  [15;13Hif (sread(fd, cmd, 9) != 1) return 1;[16;13Hmemcpy(result, cmd + 5, 4);     [17;13Hif (write(fd, result, 4) != 4) {[18;17Hperror("write");[19;13H    return 1;[20;13H}             [21;13Hif (verbose) {                                                   [22;25H%u : Received command: 'settck'\n", (int)time(NULL));[23;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[24;13H}     [25;9H    break;                             [1;1H[26;1H[K- xvcserver.c 58/304 19%[1;1H[1;9Hif (sread(fd, cmd, 2) != 1) return 1;[2;9H                                [3;9Hif (memcmp(cmd, "ge", 2) == 0) {         [4;13Hif (sread(fd, cmd, 6) != 1) return 1;    [5;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [6;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[7;17Hperror("write");[8;13H    return 1;[9;13H}             [10;13Hif (verbose) {                                                    [11;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[12;13H    printf("\t Replied with %s\n", xvcInfo);[13;13H}     [14;9H    break;                             [15;9H} else if (memcmp(cmd, "se", 2) == 0) {  [16;13Hif (sread(fd, cmd, 9) != 1) return 1;[17;13Hmemcpy(result, cmd + 5, 4);     [18;13Hif (write(fd, result, 4) != 4) {[19;17Hperror("write");[20;13H    return 1;[21;13H}             [22;13Hif (verbose) {                                                   [23;25H%u : Received command: 'settck'\n", (int)time(NULL));[24;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[25;13H}     [1;1H[26;1H[K- xvcserver.c 57/304 18%[1;1H[1;9H                                     [2;9Hif (sread(fd, cmd, 2) != 1) return 1;[3;9H                                [4;9Hif (memcmp(cmd, "ge", 2) == 0) {         [5;13Hif (sread(fd, cmd, 6) != 1) return 1;    [6;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [7;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[8;17Hperror("write");[9;13H    return 1;[10;13H}             [11;13Hif (verbose) {                                                    [12;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[13;13H    printf("\t Replied with %s\n", xvcInfo);[14;13H}     [15;9H    break;                             [16;9H} else if (memcmp(cmd, "se", 2) == 0) {  [17;13Hif (sread(fd, cmd, 9) != 1) return 1;[18;13Hmemcpy(result, cmd + 5, 4);     [19;13Hif (write(fd, result, 4) != 4) {[20;17Hperror("write");[21;13H    return 1;[22;13H}             [23;13Hif (verbose) {                                                   [24;25H%u : Received command: 'settck'\n", (int)time(NULL));[25;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[1;1H[26;1H[K- xvcserver.c 56/304 18%[1;1H[1;9Hmemset(cmd, 0, 16);[2;9H                                     [3;9Hif (sread(fd, cmd, 2) != 1) return 1;[4;9H                                [5;9Hif (memcmp(cmd, "ge", 2) == 0) {         [6;13Hif (sread(fd, cmd, 6) != 1) return 1;    [7;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [8;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[9;17Hperror("write");[10;13H    return 1;[11;13H}             [12;13Hif (verbose) {                                                    [13;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[14;13H    printf("\t Replied with %s\n", xvcInfo);[15;13H}     [16;9H    break;                             [17;9H} else if (memcmp(cmd, "se", 2) == 0) {  [18;13Hif (sread(fd, cmd, 9) != 1) return 1;[19;13Hmemcpy(result, cmd + 5, 4);     [20;13Hif (write(fd, result, 4) != 4) {[21;17Hperror("write");[22;13H    return 1;[23;13H}             [24;13Hif (verbose) {                                                   [25;25H%u : Received command: 'settck'\n", (int)time(NULL));[1;1H[26;1H[K- xvcserver.c 55/304 18%[1;1H[26;1H[K- xvcserver.c 54/304 17%[1;1H[26;1H[K- xvcserver.c 53/304 17%[1;1H[26;1H[K- xvcserver.c 52/304 17%[1;1H[26;1H[K- xvcserver.c 51/304 16%[1;1H[26;1H[K- xvcserver.c 50/304 16%[1;1H[26;1H[K- xvcserver.c 49/304 16%[1;1H[1;9H                   [2;1Hint handle_data(int fd, volatile jtag_t *ptr) {[3;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[5;5Hdo {                                [6;9Hchar          cmd[16];                   [7;9Hunsigned char buffer[8192], result[1024];    [8;9Hmemset(cmd, 0, 16);                                             [9;17H                [10;9Hif (sread(fd, cmd, 2) != 1) return 1;[11;13H [12;9Hif (memcmp(cmd, "ge", 2) == 0) {[13;13Hif (sread(fd, cmd, 6) != 1) return 1;                             [14;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));   [15;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[16;13H    perror("write");[17;9H        return 1;                      [18;13H}                                    [19;13Hif (verbose) {             [20;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[21;18Hrintf("\t Replied with %s\n", xvcInfo);[22;13H}            [23;13Hbreak;[24;9H} else if (memcmp(cmd, "se", 2) == 0) {[25;13Hif (sread(fd, cmd, 9) != 1) return 1;                            [1;1H[26;1H[K- xvcserver.c 48/304 15%[1;1H[1;1H}[2;1H                                               [3;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [4;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[5;5H    [6;5Hdo {                      [7;9Hchar          cmd[16];                   [8;9Hunsigned char buffer[8192], result[1024];[9;9Hmemset(cmd, 0, 16);[10;9H                                     [11;9Hif (sread(fd, cmd, 2) != 1) return 1;[12;9H                                [13;9Hif (memcmp(cmd, "ge", 2) == 0) {         [14;13Hif (sread(fd, cmd, 6) != 1) return 1;    [15;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [16;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[17;17Hperror("write");[18;13H    return 1;[19;13H}             [20;13Hif (verbose) {                                                    [21;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[22;13H    printf("\t Replied with %s\n", xvcInfo);[23;13H}     [24;9H    break;                             [25;9H} else if (memcmp(cmd, "se", 2) == 0) {  [1;1H[26;1H[K- xvcserver.c 47/304 15%[1;1H[1;1H    return 1;[2;1H}[3;1H                                               [4;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [5;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[6;5H    [7;5Hdo {                      [8;9Hchar          cmd[16];                   [9;9Hunsigned char buffer[8192], result[1024];[10;9Hmemset(cmd, 0, 16);[11;9H                                     [12;9Hif (sread(fd, cmd, 2) != 1) return 1;[13;9H                                [14;9Hif (memcmp(cmd, "ge", 2) == 0) {         [15;13Hif (sread(fd, cmd, 6) != 1) return 1;    [16;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [17;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[18;17Hperror("write");[19;13H    return 1;[20;13H}             [21;13Hif (verbose) {                                                    [22;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[23;13H    printf("\t Replied with %s\n", xvcInfo);[24;13H}     [25;9H    break;                             [1;1H[26;1H[K- xvcserver.c 46/304 15%[1;1H[1;5H}        [2;1H    return 1;[3;1H}[4;1H                                               [5;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [6;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[7;5H    [8;5Hdo {                      [9;9Hchar          cmd[16];                   [10;9Hunsigned char buffer[8192], result[1024];[11;9Hmemset(cmd, 0, 16);[12;9H                                     [13;9Hif (sread(fd, cmd, 2) != 1) return 1;[14;9H                                [15;9Hif (memcmp(cmd, "ge", 2) == 0) {         [16;13Hif (sread(fd, cmd, 6) != 1) return 1;    [17;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [18;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[19;17Hperror("write");[20;13H    return 1;[21;13H}             [22;13Hif (verbose) {                                                    [23;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[24;13H    printf("\t Replied with %s\n", xvcInfo);[25;13H}     [1;1H[26;1H[K- xvcserver.c 45/304 14%[1;1H[1;5H    len -= r;[2;5H}        [3;1H    return 1;[4;1H}[5;1H                                               [6;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [7;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[8;5H    [9;5Hdo {                      [10;9Hchar          cmd[16];                   [11;9Hunsigned char buffer[8192], result[1024];[12;9Hmemset(cmd, 0, 16);[13;9H                                     [14;9Hif (sread(fd, cmd, 2) != 1) return 1;[15;9H                                [16;9Hif (memcmp(cmd, "ge", 2) == 0) {         [17;13Hif (sread(fd, cmd, 6) != 1) return 1;    [18;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [19;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[20;17Hperror("write");[21;13H    return 1;[22;13H}             [23;13Hif (verbose) {                                                    [24;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[25;13H    printf("\t Replied with %s\n", xvcInfo);[1;1H[26;1H[K- xvcserver.c 44/304 14%[1;1H[1;9Ht += r;  [2;5H    len -= r;[3;5H}        [4;1H    return 1;[5;1H}[6;1H                                               [7;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [8;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[9;5H    [10;5Hdo {                      [11;9Hchar          cmd[16];                   [12;9Hunsigned char buffer[8192], result[1024];[13;9Hmemset(cmd, 0, 16);[14;9H                                     [15;9Hif (sread(fd, cmd, 2) != 1) return 1;[16;9H                                [17;9Hif (memcmp(cmd, "ge", 2) == 0) {         [18;13Hif (sread(fd, cmd, 6) != 1) return 1;    [19;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [20;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[21;17Hperror("write");[22;13H    return 1;[23;13H}             [24;13Hif (verbose) {                                                    [25;25H%u : Received command: 'getinfo'\n", (int)time(NULL));[1;1H[26;1H[K- xvcserver.c 43/304 14%[1;1H[1;9Hif (r <= 0) return r;[2;9Ht += r;  [3;5H    len -= r;[4;5H}        [5;1H    return 1;[6;1H}[7;1H                                               [8;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [9;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[10;5H    [11;5Hdo {                      [12;9Hchar          cmd[16];                   [13;9Hunsigned char buffer[8192], result[1024];[14;9Hmemset(cmd, 0, 16);[15;9H                                     [16;9Hif (sread(fd, cmd, 2) != 1) return 1;[17;9H                                [18;9Hif (memcmp(cmd, "ge", 2) == 0) {         [19;13Hif (sread(fd, cmd, 6) != 1) return 1;    [20;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [21;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[22;17Hperror("write");[23;13H    return 1;[24;13H}             [25;13Hif (verbose) {                                                    [1;1H[26;1H[K- xvcserver.c 42/304 13%[1;1H[1;10Hnt r = read(fd, t, len);[2;9Hif (r <= 0) return r;[3;9Ht += r;  [4;5H    len -= r;[5;5H}        [6;1H    return 1;[7;1H}[8;1H                                               [9;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [10;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[11;5H    [12;5Hdo {                      [13;9Hchar          cmd[16];                   [14;9Hunsigned char buffer[8192], result[1024];[15;9Hmemset(cmd, 0, 16);[16;9H                                     [17;9Hif (sread(fd, cmd, 2) != 1) return 1;[18;9H                                [19;9Hif (memcmp(cmd, "ge", 2) == 0) {         [20;13Hif (sread(fd, cmd, 6) != 1) return 1;    [21;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));                   [22;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[23;17Hperror("write");[24;13H    return 1;[25;13H}             [1;1H[26;1H[K- xvcserver.c 41/304 13%[1;1H[26;1H[K- xvcserver.c 40/304 13%[1;1H[26;1H[K- xvcserver.c 39/304 12%[1;1H[26;1H[K- xvcserver.c 38/304 12%[1;1H[26;1H[K- xvcserver.c 37/304 12%[1;1H[1;1Hstatic int verbose = 0;          [2;9H                     [3;1Hstatic int sread(int fd, void *target, int len) {[4;5Hunsigned char *t = target;[5;5Hwhile (len) {[6;5H    int r = read(fd, t, len);[7;1H        if (r <= 0) return r;[8;9Ht += r;[9;1H        len -= r;                              [10;5H}                                              [11;5Hreturn 1;[12;1H}       [13;9H                      [14;1Hint handle_data(int fd, volatile jtag_t *ptr) {  [15;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[17;5Hdo {                                     [18;9Hchar          cmd[16];[19;9Hunsigned char buffer[8192], result[1024];[20;9Hmemset(cmd, 0, 16);                      [21;13H                                         [22;9Hif (sread(fd, cmd, 2) != 1) return 1;                           [23;17H                [24;9Hif (memcmp(cmd, "ge", 2) == 0) {[25;13Hif (sread(fd, cmd, 6) != 1) return 1;[1;1H[26;1H[K- xvcserver.c 36/304 11%[1;1H[1;1H                       [2;1Hstatic int verbose = 0;[3;1H                                                 [4;1Hstatic int sread(int fd, void *target, int len) {[5;5Hunsigned char *t = target;[6;5Hwhile (len) {                [7;10Hnt r = read(fd, t, len);[8;9Hif (r <= 0) return r;[9;9Ht += r;  [10;5H    len -= r;[11;5H}        [12;1H    return 1;[13;1H}[14;1H                                               [15;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [16;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[17;5H    [18;5Hdo {                      [19;9Hchar          cmd[16];                   [20;9Hunsigned char buffer[8192], result[1024];[21;9Hmemset(cmd, 0, 16);[22;9H                                     [23;9Hif (sread(fd, cmd, 2) != 1) return 1;[24;9H                                [25;9Hif (memcmp(cmd, "ge", 2) == 0) {         [1;1H[26;1H[K- xvcserver.c 35/304 11%[1;1H[1;1H} jtag_t;[2;1H                       [3;1Hstatic int verbose = 0;[4;1H                                                 [5;1Hstatic int sread(int fd, void *target, int len) {[6;5Hunsigned char *t = target;[7;5Hwhile (len) {                [8;10Hnt r = read(fd, t, len);[9;9Hif (r <= 0) return r;[10;9Ht += r;  [11;5H    len -= r;[12;5H}        [13;1H    return 1;[14;1H}[15;1H                                               [16;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [17;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[18;5H    [19;5Hdo {                      [20;9Hchar          cmd[16];                   [21;9Hunsigned char buffer[8192], result[1024];[22;9Hmemset(cmd, 0, 16);[23;9H                                     [24;9Hif (sread(fd, cmd, 2) != 1) return 1;[25;9H                                [1;1H[26;1H[K- xvcserver.c 34/304 11%[1;1H[1;1H    uint32_t ctrl_offset;[2;1H} jtag_t;[3;1H                       [4;1Hstatic int verbose = 0;[5;1H                                                 [6;1Hstatic int sread(int fd, void *target, int len) {[7;5Hunsigned char *t = target;[8;5Hwhile (len) {                [9;10Hnt r = read(fd, t, len);[10;9Hif (r <= 0) return r;[11;9Ht += r;  [12;5H    len -= r;[13;5H}        [14;1H    return 1;[15;1H}[16;1H                                               [17;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [18;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[19;5H    [20;5Hdo {                      [21;9Hchar          cmd[16];                   [22;9Hunsigned char buffer[8192], result[1024];[23;9Hmemset(cmd, 0, 16);[24;9H                                     [25;9Hif (sread(fd, cmd, 2) != 1) return 1;[1;1H[26;1H[K- xvcserver.c 33/304 10%[1;1H[1;14Htdo_offset; [2;1H    uint32_t ctrl_offset;[3;1H} jtag_t;[4;1H                       [5;1Hstatic int verbose = 0;[6;1H                                                 [7;1Hstatic int sread(int fd, void *target, int len) {[8;5Hunsigned char *t = target;[9;5Hwhile (len) {                [10;10Hnt r = read(fd, t, len);[11;9Hif (r <= 0) return r;[12;9Ht += r;  [13;5H    len -= r;[14;5H}        [15;1H    return 1;[16;1H}[17;1H                                               [18;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [19;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[20;5H    [21;5Hdo {                      [22;9Hchar          cmd[16];                   [23;9Hunsigned char buffer[8192], result[1024];[24;9Hmemset(cmd, 0, 16);[25;9H                                     [1;1H[26;1H[K- xvcserver.c 32/304 10%[1;1H[1;16Hi[2;14Htdo_offset; [3;1H    uint32_t ctrl_offset;[4;1H} jtag_t;[5;1H                       [6;1Hstatic int verbose = 0;[7;1H                                                 [8;1Hstatic int sread(int fd, void *target, int len) {[9;5Hunsigned char *t = target;[10;5Hwhile (len) {                [11;10Hnt r = read(fd, t, len);[12;9Hif (r <= 0) return r;[13;9Ht += r;  [14;5H    len -= r;[15;5H}        [16;1H    return 1;[17;1H}[18;1H                                               [19;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [20;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[21;5H    [22;5Hdo {                      [23;9Hchar          cmd[16];                   [24;9Hunsigned char buffer[8192], result[1024];[25;9Hmemset(cmd, 0, 16);[1;1H[26;1H[K- xvcserver.c 31/304 10%[1;1H[1;15Hms[2;16Hi[3;14Htdo_offset; [4;1H    uint32_t ctrl_offset;[5;1H} jtag_t;[6;1H                       [7;1Hstatic int verbose = 0;[8;1H                                                 [9;1Hstatic int sread(int fd, void *target, int len) {[10;5Hunsigned char *t = target;[11;5Hwhile (len) {                [12;10Hnt r = read(fd, t, len);[13;9Hif (r <= 0) return r;[14;9Ht += r;  [15;5H    len -= r;[16;5H}        [17;1H    return 1;[18;1H}[19;1H                                               [20;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [21;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[22;5H    [23;5Hdo {                      [24;9Hchar          cmd[16];                   [25;9Hunsigned char buffer[8192], result[1024];[1;1H[26;1H[K- xvcserver.c 30/304 9%[1;1H[1;14Hlength_offset;[2;15Hms[3;16Hi[4;14Htdo_offset; [5;1H    uint32_t ctrl_offset;[6;1H} jtag_t;[7;1H                       [8;1Hstatic int verbose = 0;[9;1H                                                 [10;1Hstatic int sread(int fd, void *target, int len) {[11;5Hunsigned char *t = target;[12;5Hwhile (len) {                [13;10Hnt r = read(fd, t, len);[14;9Hif (r <= 0) return r;[15;9Ht += r;  [16;5H    len -= r;[17;5H}        [18;1H    return 1;[19;1H}[20;1H                                               [21;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [22;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[23;5H    [24;5Hdo {                      [25;9Hchar          cmd[16];                   [1;1H[26;1H[K- xvcserver.c 29/304 9%[1;1H[1;1Htypedef struct {           [2;14Hlength_offset;[3;15Hms[4;16Hi[5;14Htdo_offset; [6;1H    uint32_t ctrl_offset;[7;1H} jtag_t;[8;1H                       [9;1Hstatic int verbose = 0;[10;1H                                                 [11;1Hstatic int sread(int fd, void *target, int len) {[12;5Hunsigned char *t = target;[13;5Hwhile (len) {                [14;10Hnt r = read(fd, t, len);[15;9Hif (r <= 0) return r;[16;9Ht += r;  [17;5H    len -= r;[18;5H}        [19;1H    return 1;[20;1H}[21;1H                                               [22;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [23;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[24;5H    [25;5Hdo {                      [1;1H[26;1H[K- xvcserver.c 28/304 9%[1;1H[1;1H                [2;1Htypedef struct {           [3;14Hlength_offset;[4;15Hms[5;16Hi[6;14Htdo_offset; [7;1H    uint32_t ctrl_offset;[8;1H} jtag_t;[9;1H                       [10;1Hstatic int verbose = 0;[11;1H                                                 [12;1Hstatic int sread(int fd, void *target, int len) {[13;5Hunsigned char *t = target;[14;5Hwhile (len) {                [15;10Hnt r = read(fd, t, len);[16;9Hif (r <= 0) return r;[17;9Ht += r;  [18;5H    len -= r;[19;5H}        [20;1H    return 1;[21;1H}[22;1H                                               [23;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [24;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[25;5H    [1;1H[26;1H[K- xvcserver.c 27/304 8%[1;1H[1;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[2;1H                [3;1Htypedef struct {           [4;14Hlength_offset;[5;15Hms[6;16Hi[7;14Htdo_offset; [8;1H    uint32_t ctrl_offset;[9;1H} jtag_t;[10;1H                       [11;1Hstatic int verbose = 0;[12;1H                                                 [13;1Hstatic int sread(int fd, void *target, int len) {[14;5Hunsigned char *t = target;[15;5Hwhile (len) {                [16;10Hnt r = read(fd, t, len);[17;9Hif (r <= 0) return r;[18;9Ht += r;  [19;5H    len -= r;[20;5H}        [21;1H    return 1;[22;1H}[23;1H                                               [24;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [25;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[1;1H[26;1H[K- xvcserver.c 26/304 8%[1;1H[1;9HMAP_SIZE 0x10000                                     [2;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[3;1H                [4;1Htypedef struct {           [5;14Hlength_offset;[6;15Hms[7;16Hi[8;14Htdo_offset; [9;1H    uint32_t ctrl_offset;[10;1H} jtag_t;[11;1H                       [12;1Hstatic int verbose = 0;[13;1H                                                 [14;1Hstatic int sread(int fd, void *target, int len) {[15;5Hunsigned char *t = target;[16;5Hwhile (len) {                [17;10Hnt r = read(fd, t, len);[18;9Hif (r <= 0) return r;[19;9Ht += r;  [20;5H    len -= r;[21;5H}        [22;1H    return 1;[23;1H}[24;1H                                               [25;1Hint handle_data(int fd, volatile jtag_t *ptr) {    [1;1H[26;1H[K- xvcserver.c 25/304 8%[1;1H[1;1H                        [2;9HMAP_SIZE 0x10000                                     [3;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[4;1H                [5;1Htypedef struct {           [6;14Hlength_offset;[7;15Hms[8;16Hi[9;14Htdo_offset; [10;1H    uint32_t ctrl_offset;[11;1H} jtag_t;[12;1H                       [13;1Hstatic int verbose = 0;[14;1H                                                 [15;1Hstatic int sread(int fd, void *target, int len) {[16;5Hunsigned char *t = target;[17;5Hwhile (len) {                [18;10Hnt r = read(fd, t, len);[19;9Hif (r <= 0) return r;[20;9Ht += r;  [21;5H    len -= r;[22;5H}        [23;1H    return 1;[24;1H}[25;1H                                               [1;1H[26;1H[K- xvcserver.c 24/304 7%[1;1H[1;1H#include <unistd.h>[2;1H                        [3;9HMAP_SIZE 0x10000                                     [4;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[5;1H                [6;1Htypedef struct {           [7;14Hlength_offset;[8;15Hms[9;16Hi[10;14Htdo_offset; [11;1H    uint32_t ctrl_offset;[12;1H} jtag_t;[13;1H                       [14;1Hstatic int verbose = 0;[15;1H                                                 [16;1Hstatic int sread(int fd, void *target, int len) {[17;5Hunsigned char *t = target;[18;5Hwhile (len) {                [19;10Hnt r = read(fd, t, len);[20;9Hif (r <= 0) return r;[21;9Ht += r;  [22;5H    len -= r;[23;5H}        [24;1H    return 1;[25;1H}[1;1H[26;1H[K- xvcserver.c 23/304 7%[1;1H[1;11Htime.h>  [2;1H#include <unistd.h>[3;1H                        [4;9HMAP_SIZE 0x10000                                     [5;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[6;1H                [7;1Htypedef struct {           [8;14Hlength_offset;[9;15Hms[10;16Hi[11;14Htdo_offset; [12;1H    uint32_t ctrl_offset;[13;1H} jtag_t;[14;1H                       [15;1Hstatic int verbose = 0;[16;1H                                                 [17;1Hstatic int sread(int fd, void *target, int len) {[18;5Hunsigned char *t = target;[19;5Hwhile (len) {                [20;10Hnt r = read(fd, t, len);[21;9Hif (r <= 0) return r;[22;9Ht += r;  [23;5H    len -= r;[24;5H}        [25;1H    return 1;[1;1H[26;1H[K- xvcserver.c 22/304 7%[1;1H[1;11Hsys/types.h>[2;11Htime.h>  [3;1H#include <unistd.h>[4;1H                        [5;9HMAP_SIZE 0x10000                                     [6;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[7;1H                [8;1Htypedef struct {           [9;14Hlength_offset;[10;15Hms[11;16Hi[12;14Htdo_offset; [13;1H    uint32_t ctrl_offset;[14;1H} jtag_t;[15;1H                       [16;1Hstatic int verbose = 0;[17;1H                                                 [18;1Hstatic int sread(int fd, void *target, int len) {[19;5Hunsigned char *t = target;[20;5Hwhile (len) {                [21;10Hnt r = read(fd, t, len);[22;9Hif (r <= 0) return r;[23;9Ht += r;  [24;5H    len -= r;[25;5H}        [1;1H[26;1H[K- xvcserver.c 21/304 6%[1;1H[26;1H[K- xvcserver.c 20/304 6%[1;1H[26;1H[K- xvcserver.c 19/304 6%[1;1H[26;1H[K- xvcserver.c 18/304 5%[1;1H[26;1H[K- xvcserver.c 17/304 5%[1;1H[26;1H[K- xvcserver.c 16/304 5%[1;1H[26;1H[K- xvcserver.c 15/304 4%[1;1H[26;1H[K- xvcserver.c 14/304 4%[1;1H[26;1H[K- xvcserver.c 13/304 4%[1;1H[26;1H[K- xvcserver.c 12/304 3%[1;1H[26;1H[K- xvcserver.c 11/304 3%[1;1H[1;1H                      [2;11Hfcntl.h>[3;11Hnetinet/in.h>[4;1H#include <netinet/tcp.h>[5;2Hinclude <pthread.h>    [6;2Hinclude <stdint.h>                                          [7;1H#include <stdio.h>[8;1H#include <stdlib.h>[9;1H#include <string.h>        [10;1H#include <sys/mman.h>   [11;1H#include <sys/socket.h> [12;1H#include <sys/types.h>  [13;1H#include <time.h>        [14;1H#include <unistd.h>[16;1H#define MAP_SIZE 0x10000[17;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[18;1H                                                 [19;1Htypedef struct {              [20;5Huint32_t length_offset;[21;5Huint32_t tms_offset;         [22;5Huint32_t tdi_offset;     [23;5Huint32_t tdo_offset;[24;5Huint32_t ctrl_offset;[25;1H} jtag_t;[1;1H[26;1H[K- xvcserver.c 10/304 3%[1;1H[1;2H*/[2;1H                  [3;11Hfcntl.h>     [4;19Hin.h> [5;11Hnetinet/tcp.h>[6;11Hpthread.h>[7;15Hnt.h>[8;14Hio.h> [9;13Hdlib[10;12Htring.h>  [11;15Hmman.h>  [12;15Hsocket.h>[13;11Hsys/types.h>[14;11Htime.h>  [15;1H#include <unistd.h>[16;1H                        [17;9HMAP_SIZE 0x10000                                     [18;1H#define dsb(scope) asm volatile("dsb " #scope : : : "memory")[19;1H                [20;1Htypedef struct {           [21;14Hlength_offset;[22;15Hms[23;16Hi[24;14Htdo_offset; [25;1H    uint32_t ctrl_offset;[1;1H[26;1H[K- xvcserver.c 9/304 2%[1;1H[2;1H[26;1H[K- xvcserver.c 10/304 3%[2;1H[3;1H[26;1H[K- xvcserver.c 11/304 3%[3;1H[4;1H[26;1H[K- xvcserver.c 12/304 3%[4;1H[5;1H[26;1H[K- xvcserver.c 13/304 4%[5;1H[6;1H[26;1H[K- xvcserver.c 14/304 4%[6;1H[7;1H[26;1H[K- xvcserver.c 15/304 4%[7;1H[8;1H[26;1H[K- xvcserver.c 16/304 5%[8;1H[9;1H[26;1H[K- xvcserver.c 17/304 5%[9;1H[10;1H[26;1H[K- xvcserver.c 18/304 5%[10;1H[11;1H[26;1H[K- xvcserver.c 19/304 6%[11;1H[12;1H[26;1H[K- xvcserver.c 20/304 6%[12;1H[13;1H[26;1H[K- xvcserver.c 21/304 6%[13;1H[14;1H[26;1H[K- xvcserver.c 22/304 7%[14;1H[15;1H[26;1H[K- xvcserver.c 23/304 7%[15;1H[16;1H[26;1H[K- xvcserver.c 24/304 7%[16;1H[17;1H[26;1H[K- xvcserver.c 25/304 8%[17;1H[18;1H[26;1H[K- xvcserver.c 26/304 8%[18;1H[19;1H[26;1H[K- xvcserver.c 27/304 8%[19;1H[20;1H[26;1H[K- xvcserver.c 28/304 9%[20;1H[21;1H[26;1H[K- xvcserver.c 29/304 9%[21;1H[22;1H[26;1H[K- xvcserver.c 30/304 9%[22;1H[23;1H[26;1H[K- xvcserver.c 31/304 10%[23;1H[24;1H[26;1H[K- xvcserver.c 32/304 10%[24;1H[25;1H[26;1H[K- xvcserver.c 33/304 10%[25;1H[1;2H  [2;1H#include <fcntl.h>[3;11Hnetinet/in.h>[4;19Htcp.h>[5;11Hpthread.h>    [6;11Hstdint.h> [7;15Ho.h> [8;14Hlib.h>[9;13Hring[10;12Hys/mman.h>[11;15Hsocket.h>[12;15Htypes.h> [13;11Htime.h>     [14;11Hunistd.h>[15;1H                   [16;1H#define MAP_SIZE 0x10000[17;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[18;1H                                                             [19;1Htypedef struct {[20;1H    uint32_t length_offset;[21;14Htms_offset;   [22;15Hdi[23;16Ho[24;14Hctrl_offset;[25;1H} jtag_t;                [25;1H[26;1H[K- xvcserver.c 34/304 11%[25;1H[1;1H#include <fcntl.h>[2;11Hnetinet/in.h>[3;19Htcp.h>[4;11Hpthread.h>    [5;11Hstdint.h> [6;15Ho.h> [7;14Hlib.h>[8;13Hring[9;12Hys/mman.h>[10;15Hsocket.h>[11;15Htypes.h> [12;11Htime.h>     [13;11Hunistd.h>[14;1H                   [15;1H#define MAP_SIZE 0x10000[16;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[17;1H                                                             [18;1Htypedef struct {[19;1H    uint32_t length_offset;[20;14Htms_offset;   [21;15Hdi[22;16Ho[23;14Hctrl_offset;[24;1H} jtag_t;                [25;1H         [25;1H[26;1H[K- xvcserver.c 35/304 11%[25;1H[1;11Hnetinet/in.h>[2;19Htcp.h>[3;11Hpthread.h>    [4;11Hstdint.h> [5;15Ho.h> [6;14Hlib.h>[7;13Hring[8;12Hys/mman.h>[9;15Hsocket.h>[10;15Htypes.h> [11;11Htime.h>     [12;11Hunistd.h>[13;1H                   [14;1H#define MAP_SIZE 0x10000[15;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[16;1H                                                             [17;1Htypedef struct {[18;1H    uint32_t length_offset;[19;14Htms_offset;   [20;15Hdi[21;16Ho[22;14Hctrl_offset;[23;1H} jtag_t;                [24;1H         [25;1Hstatic int verbose = 0;[25;1H[26;1H[K- xvcserver.c 36/304 11%[25;1H[1;19Htcp.h>[2;11Hpthread.h>    [3;11Hstdint.h> [4;15Ho.h> [5;14Hlib.h>[6;13Hring[7;12Hys/mman.h>[8;15Hsocket.h>[9;15Htypes.h> [10;11Htime.h>     [11;11Hunistd.h>[12;1H                   [13;1H#define MAP_SIZE 0x10000[14;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[15;1H                                                             [16;1Htypedef struct {[17;1H    uint32_t length_offset;[18;14Htms_offset;   [19;15Hdi[20;16Ho[21;14Hctrl_offset;[22;1H} jtag_t;                [23;1H         [24;1Hstatic int verbose = 0;[25;1H                       [25;1H[26;1H[K- xvcserver.c 37/304 12%[25;1H[1;11Hpthread.h>    [2;11Hstdint.h> [3;15Ho.h> [4;14Hlib.h>[5;13Hring[6;12Hys/mman.h>[7;15Hsocket.h>[8;15Htypes.h> [9;11Htime.h>     [10;11Hunistd.h>[11;1H                   [12;1H#define MAP_SIZE 0x10000[13;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[14;1H                                                             [15;1Htypedef struct {[16;1H    uint32_t length_offset;[17;14Htms_offset;   [18;15Hdi[19;16Ho[20;14Hctrl_offset;[21;1H} jtag_t;                [22;1H         [23;1Hstatic int verbose = 0;[24;1H                       [25;1Hstatic int sread(int fd, void *target, int len) {[25;1H[26;1H[K- xvcserver.c 38/304 12%[25;1H[1;11Hstdint.h> [2;15Ho.h> [3;14Hlib.h>[4;13Hring[5;12Hys/mman.h>[6;15Hsocket.h>[7;15Htypes.h> [8;11Htime.h>     [9;11Hunistd.h>[10;1H                   [11;1H#define MAP_SIZE 0x10000[12;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[13;1H                                                             [14;1Htypedef struct {[15;1H    uint32_t length_offset;[16;14Htms_offset;   [17;15Hdi[18;16Ho[19;14Hctrl_offset;[20;1H} jtag_t;                [21;1H         [22;1Hstatic int verbose = 0;[23;1H                       [24;1Hstatic int sread(int fd, void *target, int len) {[25;1H    unsigned char *t = target;                   [25;1H[26;1H[K- xvcserver.c 39/304 12%[25;1H[1;15Ho.h> [2;14Hlib.h>[3;13Hring[4;12Hys/mman.h>[5;15Hsocket.h>[6;15Htypes.h> [7;11Htime.h>     [8;11Hunistd.h>[9;1H                   [10;1H#define MAP_SIZE 0x10000[11;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[12;1H                                                             [13;1Htypedef struct {[14;1H    uint32_t length_offset;[15;14Htms_offset;   [16;15Hdi[17;16Ho[18;14Hctrl_offset;[19;1H} jtag_t;                [20;1H         [21;1Hstatic int verbose = 0;[22;1H                       [23;1Hstatic int sread(int fd, void *target, int len) {[24;1H    unsigned char *t = target;                   [25;5Hwhile (len) {             [25;1H[26;1H[K- xvcserver.c 40/304 13%[25;1H[1;14Hlib.h>[2;13Hring[3;12Hys/mman.h>[4;15Hsocket.h>[5;15Htypes.h> [6;11Htime.h>     [7;11Hunistd.h>[8;1H                   [9;1H#define MAP_SIZE 0x10000[10;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[11;1H                                                             [12;1Htypedef struct {[13;1H    uint32_t length_offset;[14;14Htms_offset;   [15;15Hdi[16;16Ho[17;14Hctrl_offset;[18;1H} jtag_t;                [19;1H         [20;1Hstatic int verbose = 0;[21;1H                       [22;1Hstatic int sread(int fd, void *target, int len) {[23;1H    unsigned char *t = target;                   [24;5Hwhile (len) {             [25;5H    int r = read(fd, t, len);[25;1H[26;1H[K- xvcserver.c 41/304 13%[25;1H[1;13Hring[2;12Hys/mman.h>[3;15Hsocket.h>[4;15Htypes.h> [5;11Htime.h>     [6;11Hunistd.h>[7;1H                   [8;1H#define MAP_SIZE 0x10000[9;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[10;1H                                                             [11;1Htypedef struct {[12;1H    uint32_t length_offset;[13;14Htms_offset;   [14;15Hdi[15;16Ho[16;14Hctrl_offset;[17;1H} jtag_t;                [18;1H         [19;1Hstatic int verbose = 0;[20;1H                       [21;1Hstatic int sread(int fd, void *target, int len) {[22;1H    unsigned char *t = target;                   [23;5Hwhile (len) {             [24;5H    int r = read(fd, t, len);[25;10Hf (r <= 0) return r;    [25;1H[26;1H[K- xvcserver.c 42/304 13%[25;1H[1;12Hys/mman.h>[2;15Hsocket.h>[3;15Htypes.h> [4;11Htime.h>     [5;11Hunistd.h>[6;1H                   [7;1H#define MAP_SIZE 0x10000[8;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[9;1H                                                             [10;1Htypedef struct {[11;1H    uint32_t length_offset;[12;14Htms_offset;   [13;15Hdi[14;16Ho[15;14Hctrl_offset;[16;1H} jtag_t;                [17;1H         [18;1Hstatic int verbose = 0;[19;1H                       [20;1Hstatic int sread(int fd, void *target, int len) {[21;1H    unsigned char *t = target;                   [22;5Hwhile (len) {             [23;5H    int r = read(fd, t, len);[24;10Hf (r <= 0) return r;    [25;9Ht += r;              [25;1H[26;1H[K- xvcserver.c 43/304 14%[25;1H[1;15Hsocket.h>[2;15Htypes.h> [3;11Htime.h>     [4;11Hunistd.h>[5;1H                   [6;1H#define MAP_SIZE 0x10000[7;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[8;1H                                                             [9;1Htypedef struct {[10;1H    uint32_t length_offset;[11;14Htms_offset;   [12;15Hdi[13;16Ho[14;14Hctrl_offset;[15;1H} jtag_t;                [16;1H         [17;1Hstatic int verbose = 0;[18;1H                       [19;1Hstatic int sread(int fd, void *target, int len) {[20;1H    unsigned char *t = target;                   [21;5Hwhile (len) {             [22;5H    int r = read(fd, t, len);[23;10Hf (r <= 0) return r;    [24;9Ht += r;              [25;9Hlen -= r;[25;1H[26;1H[K- xvcserver.c 44/304 14%[25;1H[1;15Htypes.h> [2;11Htime.h>     [3;11Hunistd.h>[4;1H                   [5;1H#define MAP_SIZE 0x10000[6;9Hdsb(scope) asm volatile("dsb " #scope : : : "memory")[7;1H                                                             [8;1Htypedef struct {[9;1H    uint32_t length_offset;[10;14Htms_offset;   [11;15Hdi[12;16Ho[13;14Hctrl_offset;[14;1H} jtag_t;                [15;1H         [16;1Hstatic int verbose = 0;[17;1H                       [18;1Hstatic int sread(int fd, void *target, int len) {[19;1H    unsigned char *t = target;                   [20;5Hwhile (len) {             [21;5H    int r = read(fd, t, len);[22;10Hf (r <= 0) return r;    [23;9Ht += r;              [24;9Hlen -= r;[25;5H}            [25;1H[26;1H[K- xvcserver.c 45/304 14%[25;1H[26;1H[K- xvcserver.c 46/304 15%[25;1H[26;1H[K- xvcserver.c 47/304 15%[25;1H[26;1H[K- xvcserver.c 48/304 15%[25;1H[26;1H[K- xvcserver.c 49/304 16%[25;1H[26;1H[K- xvcserver.c 50/304 16%[25;1H[26;1H[K- xvcserver.c 51/304 16%[25;1H[1;1Htypedef struct {      [2;1H    uint32_t length_offset;[3;1H    uint32_t tms_offset;[4;5Huint32_t tdi_offset;[5;1H    uint32_t tdo_offset;[6;1H    uint32_t ctrl_offset;                                    [7;1H} jtag_t;[8;1H                [9;1Hstatic int verbose = 0;    [10;5H                    [11;1Hstatic int sread(int fd, void *target, int len) {[12;6Hnsigned char *t = target;[13;5Hwhile (len) {        [14;1H        int r = read(fd, t, len);[15;9Hif (r <= 0) return r;[16;1H        t += r;        [17;9Hlen -= r;[18;1H    }                                            [19;5Hreturn 1;                 [20;1H}                [21;9H                         [22;1Hint handle_data(int fd, volatile jtag_t *ptr) {[23;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[24;9H         [25;5Hdo {[25;1H[26;1H[K- xvcserver.c 52/304 17%[25;1H[1;1H    uint32_t length_offset;[2;14Htms_offset;   [3;15Hdi[4;16Ho[5;14Hctrl_offset;[6;1H} jtag_t;                [7;1H         [8;1Hstatic int verbose = 0;[9;1H                       [10;1Hstatic int sread(int fd, void *target, int len) {[11;1H    unsigned char *t = target;                   [12;5Hwhile (len) {             [13;5H    int r = read(fd, t, len);[14;10Hf (r <= 0) return r;    [15;9Ht += r;              [16;9Hlen -= r;[17;5H}            [18;5Hreturn 1;[19;1H}            [20;1H [21;1Hint handle_data(int fd, volatile jtag_t *ptr) {[22;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[23;5H                                               [24;5Hdo {[25;5H    char          cmd[16];[25;1H[26;1H[K- xvcserver.c 53/304 17%[25;1H[1;14Htms_offset;   [2;15Hdi[3;16Ho[4;14Hctrl_offset;[5;1H} jtag_t;                [6;1H         [7;1Hstatic int verbose = 0;[8;1H                       [9;1Hstatic int sread(int fd, void *target, int len) {[10;1H    unsigned char *t = target;                   [11;5Hwhile (len) {             [12;5H    int r = read(fd, t, len);[13;10Hf (r <= 0) return r;    [14;9Ht += r;              [15;9Hlen -= r;[16;5H}            [17;5Hreturn 1;[18;1H}            [19;1H [20;1Hint handle_data(int fd, volatile jtag_t *ptr) {[21;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[22;5H                                               [23;5Hdo {[24;5H    char          cmd[16];[25;9Hunsigned char buffer[8192], result[1024];[25;1H[26;1H[K- xvcserver.c 54/304 17%[25;1H[1;15Hdi[2;16Ho[3;14Hctrl_offset;[4;1H} jtag_t;                [5;1H         [6;1Hstatic int verbose = 0;[7;1H                       [8;1Hstatic int sread(int fd, void *target, int len) {[9;1H    unsigned char *t = target;                   [10;5Hwhile (len) {             [11;5H    int r = read(fd, t, len);[12;10Hf (r <= 0) return r;    [13;9Ht += r;              [14;9Hlen -= r;[15;5H}            [16;5Hreturn 1;[17;1H}            [18;1H [19;1Hint handle_data(int fd, volatile jtag_t *ptr) {[20;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[21;5H                                               [22;5Hdo {[23;5H    char          cmd[16];[24;9Hunsigned char buffer[8192], result[1024];[25;9Hmemset(cmd, 0, 16);                      [25;1H[26;1H[K- xvcserver.c 55/304 18%[25;1H[1;16Ho[2;14Hctrl_offset;[3;1H} jtag_t;                [4;1H         [5;1Hstatic int verbose = 0;[6;1H                       [7;1Hstatic int sread(int fd, void *target, int len) {[8;1H    unsigned char *t = target;                   [9;5Hwhile (len) {             [10;5H    int r = read(fd, t, len);[11;10Hf (r <= 0) return r;    [12;9Ht += r;              [13;9Hlen -= r;[14;5H}            [15;5Hreturn 1;[16;1H}            [17;1H [18;1Hint handle_data(int fd, volatile jtag_t *ptr) {[19;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[20;5H                                               [21;5Hdo {[22;5H    char          cmd[16];[23;9Hunsigned char buffer[8192], result[1024];[24;9Hmemset(cmd, 0, 16);                      [25;9H                   [25;1H[26;1H[K- xvcserver.c 56/304 18%[25;1H[1;14Hctrl_offset;[2;1H} jtag_t;                [3;1H         [4;1Hstatic int verbose = 0;[5;1H                       [6;1Hstatic int sread(int fd, void *target, int len) {[7;1H    unsigned char *t = target;                   [8;5Hwhile (len) {             [9;5H    int r = read(fd, t, len);[10;10Hf (r <= 0) return r;    [11;9Ht += r;              [12;9Hlen -= r;[13;5H}            [14;5Hreturn 1;[15;1H}            [16;1H [17;1Hint handle_data(int fd, volatile jtag_t *ptr) {[18;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[19;5H                                               [20;5Hdo {[21;5H    char          cmd[16];[22;9Hunsigned char buffer[8192], result[1024];[23;9Hmemset(cmd, 0, 16);                      [24;9H                   [25;9Hif (sread(fd, cmd, 2) != 1) return 1;[25;1H[26;1H[K- xvcserver.c 57/304 18%[25;1H[1;1H} jtag_t;                [2;1H         [3;1Hstatic int verbose = 0;[4;1H                       [5;1Hstatic int sread(int fd, void *target, int len) {[6;1H    unsigned char *t = target;                   [7;5Hwhile (len) {             [8;5H    int r = read(fd, t, len);[9;10Hf (r <= 0) return r;    [10;9Ht += r;              [11;9Hlen -= r;[12;5H}            [13;5Hreturn 1;[14;1H}            [15;1H [16;1Hint handle_data(int fd, volatile jtag_t *ptr) {[17;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[18;5H                                               [19;5Hdo {[20;5H    char          cmd[16];[21;9Hunsigned char buffer[8192], result[1024];[22;9Hmemset(cmd, 0, 16);                      [23;9H                   [24;9Hif (sread(fd, cmd, 2) != 1) return 1;[25;9H                                     [25;1H[26;1H[K- xvcserver.c 58/304 19%[25;1H[1;1H         [2;1Hstatic int verbose = 0;[3;1H                       [4;1Hstatic int sread(int fd, void *target, int len) {[5;1H    unsigned char *t = target;                   [6;5Hwhile (len) {             [7;5H    int r = read(fd, t, len);[8;10Hf (r <= 0) return r;    [9;9Ht += r;              [10;9Hlen -= r;[11;5H}            [12;5Hreturn 1;[13;1H}            [14;1H [15;1Hint handle_data(int fd, volatile jtag_t *ptr) {[16;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[17;5H                                               [18;5Hdo {[19;5H    char          cmd[16];[20;9Hunsigned char buffer[8192], result[1024];[21;9Hmemset(cmd, 0, 16);                      [22;9H                   [23;9Hif (sread(fd, cmd, 2) != 1) return 1;[24;9H                                     [25;9Hif (memcmp(cmd, "ge", 2) == 0) {[25;1H[26;1H[K- xvcserver.c 59/304 19%[25;1H[1;1Hstatic int verbose = 0;[2;1H                       [3;1Hstatic int sread(int fd, void *target, int len) {[4;1H    unsigned char *t = target;                   [5;5Hwhile (len) {             [6;5H    int r = read(fd, t, len);[7;10Hf (r <= 0) return r;    [8;9Ht += r;              [9;9Hlen -= r;[10;5H}            [11;5Hreturn 1;[12;1H}            [13;1H [14;1Hint handle_data(int fd, volatile jtag_t *ptr) {[15;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[16;5H                                               [17;5Hdo {[18;5H    char          cmd[16];[19;9Hunsigned char buffer[8192], result[1024];[20;9Hmemset(cmd, 0, 16);                      [21;9H                   [22;9Hif (sread(fd, cmd, 2) != 1) return 1;[23;9H                                     [24;9Hif (memcmp(cmd, "ge", 2) == 0) {[25;9H    if (sread(fd, cmd, 6) != 1) return 1;[25;1H[26;1H[K- xvcserver.c 60/304 19%[25;1H[1;1H                       [2;1Hstatic int sread(int fd, void *target, int len) {[3;1H    unsigned char *t = target;                   [4;5Hwhile (len) {             [5;5H    int r = read(fd, t, len);[6;10Hf (r <= 0) return r;    [7;9Ht += r;              [8;9Hlen -= r;[9;5H}            [10;5Hreturn 1;[11;1H}            [12;1H [13;1Hint handle_data(int fd, volatile jtag_t *ptr) {[14;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[15;5H                                               [16;5Hdo {[17;5H    char          cmd[16];[18;9Hunsigned char buffer[8192], result[1024];[19;9Hmemset(cmd, 0, 16);                      [20;9H                   [21;9Hif (sread(fd, cmd, 2) != 1) return 1;[22;9H                                     [23;9Hif (memcmp(cmd, "ge", 2) == 0) {[24;9H    if (sread(fd, cmd, 6) != 1) return 1;[25;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[25;1H[26;1H[K- xvcserver.c 61/304 20%[25;1H[1;1Hstatic int sread(int fd, void *target, int len) {[2;1H    unsigned char *t = target;                   [3;5Hwhile (len) {             [4;5H    int r = read(fd, t, len);[5;10Hf (r <= 0) return r;    [6;9Ht += r;              [7;9Hlen -= r;[8;5H}            [9;5Hreturn 1;[10;1H}            [11;1H [12;1Hint handle_data(int fd, volatile jtag_t *ptr) {[13;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[14;5H                                               [15;5Hdo {[16;5H    char          cmd[16];[17;9Hunsigned char buffer[8192], result[1024];[18;9Hmemset(cmd, 0, 16);                      [19;9H                   [20;9Hif (sread(fd, cmd, 2) != 1) return 1;[21;9H                                     [22;9Hif (memcmp(cmd, "ge", 2) == 0) {[23;9H    if (sread(fd, cmd, 6) != 1) return 1;[24;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[25;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[25;1H[26;1H[K- xvcserver.c 62/304 20%[25;1H[26;1H[K- xvcserver.c 63/304 20%[25;1H[26;1H[K- xvcserver.c 64/304 21%[25;1H[26;1H[K- xvcserver.c 65/304 21%[25;1H[26;1H[K- xvcserver.c 66/304 21%[25;1H[26;1H[K- xvcserver.c 67/304 22%[25;1H[26;1H[K- xvcserver.c 68/304 22%[25;1H[26;1H[K- xvcserver.c 69/304 22%[25;1H[26;1H[K- xvcserver.c 70/304 23%[25;1H[26;1H[K- xvcserver.c 71/304 23%[25;1H[26;1H[K- xvcserver.c 72/304 23%[25;1H[1;1Hint handle_data(int fd, volatile jtag_t *ptr) {  [2;5Hconst char xvcInfo[] = "xvcServer_v1.0:2048\n";[3;5H             [4;5Hdo {                         [5;9Hchar          cmd[16];[6;9Hunsigned char buffer[8192], result[1024];[7;9Hmemset(cmd, 0, 16);[8;5H [9;5H    if (sread(fd, cmd, 2) != 1) return 1;[10;1H [11;9Hif (memcmp(cmd, "ge", 2) == 0) {[12;1H            if (sread(fd, cmd, 6) != 1) return 1;[13;5H        memcpy(result, xvcInfo, strlen(xvcInfo));[14;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[15;5H            perror("write");[16;9H        return 1;     [17;9H    }                                    [18;9H    if (verbose) { [19;17Hprintf("%u : Received command: 'getinfo'\n", (int)time(NULL));[20;9H        printf("\t Replied with %s\n", xvcInfo);[21;13H}[22;9H    break;                      [23;9H} else if (memcmp(cmd, "se", 2) == 0) {  [24;13Hif (sread(fd, cmd, 9) != 1) return 1;    [25;13Hmemcpy(result, cmd + 5, 4);                                 [25;1H[26;1H[K- xvcserver.c 73/304 24%[25;1H[1;1H    const char xvcInfo[] = "xvcServer_v1.0:2048\n";[2;5H                                               [3;5Hdo {[4;5H    char          cmd[16];[5;9Hunsigned char buffer[8192], result[1024];[6;9Hmemset(cmd, 0, 16);                      [7;9H                   [8;9Hif (sread(fd, cmd, 2) != 1) return 1;[9;9H                                     [10;9Hif (memcmp(cmd, "ge", 2) == 0) {[11;9H    if (sread(fd, cmd, 6) != 1) return 1;[12;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[13;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[14;13H    perror("write");                                        [15;17Hreturn 1;       [16;13H}            [17;13Hif (verbose) {[18;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[19;25H\t Replied with %s\n", xvcInfo);                      [20;13H}                                           [21;13Hbreak;[22;9H} else if (memcmp(cmd, "se", 2) == 0) {[23;9H    if (sread(fd, cmd, 9) != 1) return 1;[24;13Hmemcpy(result, cmd + 5, 4);          [25;13Hif (write(fd, result, 4) != 4) {[25;1H[26;1H[K- xvcserver.c 74/304 24%[25;1H[1;5H                                               [2;5Hdo {[3;5H    char          cmd[16];[4;9Hunsigned char buffer[8192], result[1024];[5;9Hmemset(cmd, 0, 16);                      [6;9H                   [7;9Hif (sread(fd, cmd, 2) != 1) return 1;[8;9H                                     [9;9Hif (memcmp(cmd, "ge", 2) == 0) {[10;9H    if (sread(fd, cmd, 6) != 1) return 1;[11;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[12;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[13;13H    perror("write");                                        [14;17Hreturn 1;       [15;13H}            [16;13Hif (verbose) {[17;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[18;25H\t Replied with %s\n", xvcInfo);                      [19;13H}                                           [20;13Hbreak;[21;9H} else if (memcmp(cmd, "se", 2) == 0) {[22;9H    if (sread(fd, cmd, 9) != 1) return 1;[23;13Hmemcpy(result, cmd + 5, 4);          [24;13Hif (write(fd, result, 4) != 4) {[25;13H    perror("write");            [25;1H[26;1H[K- xvcserver.c 75/304 24%[25;1H[1;5Hdo {[2;5H    char          cmd[16];[3;9Hunsigned char buffer[8192], result[1024];[4;9Hmemset(cmd, 0, 16);                      [5;9H                   [6;9Hif (sread(fd, cmd, 2) != 1) return 1;[7;9H                                     [8;9Hif (memcmp(cmd, "ge", 2) == 0) {[9;9H    if (sread(fd, cmd, 6) != 1) return 1;[10;13Hmemcpy(result, xvcInfo, strlen(xvcInfo));[11;13Hif (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[12;13H    perror("write");                                        [13;17Hreturn 1;       [14;13H}            [15;13Hif (verbose) {[16;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[17;25H\t Replied with %s\n", xvcInfo);                      [18;13H}                                           [19;13Hbreak;[20;9H} else if (memcmp(cmd, "se", 2) == 0) {[21;9H    if (sread(fd, cmd, 9) != 1) return 1;[22;13Hmemcpy(result, cmd + 5, 4);          [23;13Hif (write(fd, result, 4) != 4) {[24;13H    perror("write");            [25;17Hreturn 1;       [25;1H[26;1H[K- xvcserver.c 76/304 25%[25;1H[26;1H[K- xvcserver.c 77/304 25%[25;1H[26;1H[K- xvcserver.c 78/304 25%[25;1H[26;1H[K- xvcserver.c 79/304 25%[25;1H[26;1H[K- xvcserver.c 80/304 26%[25;1H[26;1H[K- xvcserver.c 81/304 26%[25;1H[26;1H[K- xvcserver.c 82/304 26%[25;1H[26;1H[K- xvcserver.c 83/304 27%[25;1H[26;1H[K- xvcserver.c 84/304 27%[25;1H[26;1H[K- xvcserver.c 85/304 27%[25;1H[1;5H        if (write(fd, result, strlen(xvcInfo)) != strlen(xvcInfo)) {[2;9H        perror("write");[3;9H        return 1;                        [4;9H    }              [5;13Hif (verbose) {[6;9H        printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[7;17Hprintf("\t Replied with %s\n", xvcInfo);[8;9H    }                           [9;13Hbreak;                               [10;9H} else if (memcmp(cmd, "se", 2) == 0) {      [11;17Hsread(fd, cmd, 9) != 1) return 1;                       [12;13Hmemcpy(result, cmd + 5, 4);[13;13Hif (write(fd, result, 4) != 4) {[14;13H    perror("write");[15;13H    return 1; [16;13H}                                                                 [17;13Hif (verbose) {                              [18;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[19;13H    printf("\t Replied with '%.*s'\n\n", 4, cmd + 5);[20;9H    }                                  [21;13Hbreak;                               [22;9H} else if (memcmp(cmd, "sh", 2) == 0) {[23;17Hsread(fd, cmd, 4) != 1) return 1;[24;13Hif (verbose) {      [25;17Hprintf("%u : Received command: 'shift'\n", (int)time(NULL));[25;1H[26;1H[K- xvcserver.c 86/304 28%[25;1H[1;13H    perror("write");                                        [2;17Hreturn 1;       [3;13H}            [4;13Hif (verbose) {[5;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[6;25H\t Replied with %s\n", xvcInfo);                      [7;13H}                                           [8;13Hbreak;[9;9H} else if (memcmp(cmd, "se", 2) == 0) {[10;9H    if (sread(fd, cmd, 9) != 1) return 1;[11;13Hmemcpy(result, cmd + 5, 4);          [12;13Hif (write(fd, result, 4) != 4) {[13;13H    perror("write");            [14;17Hreturn 1;       [15;13H}            [16;13Hif (verbose) {[17;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[18;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [19;13H}                                                    [20;13Hbreak;[21;9H} else if (memcmp(cmd, "sh", 2) == 0) {[22;9H    if (sread(fd, cmd, 4) != 1) return 1;[23;17Hverbose) {                       [24;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[25;13H}                                                               [25;1H[26;1H[K- xvcserver.c 87/304 28%[25;1H[1;17Hreturn 1;       [2;13H}            [3;13Hif (verbose) {[4;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[5;25H\t Replied with %s\n", xvcInfo);                      [6;13H}                                           [7;13Hbreak;[8;9H} else if (memcmp(cmd, "se", 2) == 0) {[9;9H    if (sread(fd, cmd, 9) != 1) return 1;[10;13Hmemcpy(result, cmd + 5, 4);          [11;13Hif (write(fd, result, 4) != 4) {[12;13H    perror("write");            [13;17Hreturn 1;       [14;13H}            [15;13Hif (verbose) {[16;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[17;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [18;13H}                                                    [19;13Hbreak;[20;9H} else if (memcmp(cmd, "sh", 2) == 0) {[21;9H    if (sread(fd, cmd, 4) != 1) return 1;[22;17Hverbose) {                       [23;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[24;13H}                                                               [25;9H} else {[25;1H[26;1H[K- xvcserver.c 88/304 28%[25;1H[1;13H}            [2;13Hif (verbose) {[3;13H    printf("%u : Received command: 'getinfo'\n", (int)time(NULL));[4;25H\t Replied with %s\n", xvcInfo);                      [5;13H}                                           [6;13Hbreak;[7;9H} else if (memcmp(cmd, "se", 2) == 0) {[8;9H    if (sread(fd, cmd, 9) != 1) return 1;[9;13Hmemcpy(result, cmd + 5, 4);          [10;13Hif (write(fd, result, 4) != 4) {[11;13H    perror("write");            [12;17Hreturn 1;       [13;13H}            [14;13Hif (verbose) {[15;13H    printf("%u : Received command: 'settck'\n", (int)time(NULL));[16;25H\t Replied with '%.*s'\n\n", 4, cmd + 5);            [17;13H}                                                    [18;13Hbreak;[19;9H} else if (memcmp(cmd, "sh", 2) == 0) {[20;9H    if (sread(fd, cmd, 4) != 1) return 1;[21;17Hverbose) {                       [22;13H    printf("%u : Received command: 'shift'\n", (int)time(NULL));[23;13H}                                                               [24;9H} else {[25;9H    fprintf(stderr, "invalid cmd '%s'\n", cmd);[25;1H[26;1H[K- xvcserver.c 89/304 29%[25;1H[25;1H[26;1H[K[7m'^X' is not implemented[m[25;1H[26;1H[K- xvcserver.c 89/304 29%[25;1H[26;1H[K:q[25;1H[25;1H[26;1H[K- xvcserver.c 89/304 29%[25;1H[26;1H[K[?1049lroot@plnx_MercuryXU5_EndcapSL:~/xvcserver# 
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# 
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# 
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# ls
Makefile     xvcserver.c
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# make
-sh: make: command not found
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# cat Makefile 
APP = xvcserver

# Add any other object files to this list below
APP_OBJS = xvcserver.o

all: build

build: $(APP)

$(APP): $(APP_OBJS)
	$(CC) -o $@ $(APP_OBJS) $(LDFLAGS) $(LDLIBS)
clean:
	rm -f $(APP) *.o

root@plnx_MercuryXU5_EndcapSL:~/xvcserver# gvv    cc xvcserver.c -o xvcserver.c
-sh: gcc: command not found
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# at pt install -y gcc
-sh: apt: command not found
root@plnx_MercuryXU5_EndcapSL:~/xvcserver# 